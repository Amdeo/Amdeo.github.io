<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++1x标准</title>
    <url>/2019/11/25/C++1x%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>C++98到C++11经历了长达十年之久的积累，C++14则是作为对C++11的重要补充和优化，所有这些新标准中补充的特性，给C++这门语言注入新的活力。</p>
<p>C++1x，现在有C++11/14/17甚至还有C++20，C++一直在进行发展，增加很多新的元素，auto关键字的修改使我们更加有信心来操控复杂的模板的模板类型，同时还对语言运行期进行了大量的强化，Lambda 表达式的出现让 C++ 具有了『匿名函数』的『闭包』特性，而这一特性几乎在现代的编程语言（诸如 Python/Swift/… ）中已经司空见惯，右值引用的出现解决了 C++ 长期以来被人诟病的临时对象效率问题等等。</p>
<p>C++1x 为自身的标准库增加了非常多的工具和方法，诸如在语言层面上提供了 <code>std::thread</code> 支持了并发编程，在不同平台上不再依赖于系统底层的 API，实现了语言层面的跨平台支持；<code>std::regex</code>提供了完整的正则表达式支持等等。</p>
<h2 id="怎么使用C-11或者C-14"><a href="#怎么使用C-11或者C-14" class="headerlink" title="怎么使用C++11或者C++14"></a>怎么使用C++11或者C++14</h2><p>使用-std=c++11的编译选项</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -<span class="built_in">std</span>=c++<span class="number">11</span></span><br><span class="line">g++ main.cpp -<span class="built_in">std</span>=c++<span class="number">14</span></span><br></pre></td></tr></table></figure>

<h2 id="被弃用的特性"><a href="#被弃用的特性" class="headerlink" title="被弃用的特性"></a>被弃用的特性</h2><ul>
<li><p><strong>如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。</strong></p>
</li>
<li><p><strong>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。</strong></p>
</li>
<li><p><strong>C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。</strong></p>
</li>
<li><p><strong>auto_ptr 被弃用，应使用 unique_ptr。</strong></p>
</li>
<li><p><strong>register 关键字被弃用。</strong></p>
</li>
<li><p><strong>bool 类型的 ++ 操作被弃用。</strong></p>
</li>
<li><p><strong>C 语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。</strong></p>
</li>
</ul>
<h2 id="与-C-的兼容性"><a href="#与-C-的兼容性" class="headerlink" title="与 C 的兼容性"></a>与 C 的兼容性</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br></pre></td></tr></table></figure>

<p>extern “C”表示的一种编译和连接规约，而不是一种语言，仅指定编译和连接规约，但不影响语义，如果是C++项目指定了extern “C”，仍然要遵守C++的类型检测、参数转换等规则。它只是让程序按照类C的编译和连接规约来编译和链接</p>
<h2 id="nullptr-与-constexpr"><a href="#nullptr-与-constexpr" class="headerlink" title="nullptr 与 constexpr"></a>nullptr 与 constexpr</h2><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>nullptr出现的目的是为了替代了NULL，在某种意义上会把NULL和0视为同一种东西，这取决于编译器如何定义NULL，有的编译器会将NULL定义为((void*)0),</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>那么编译这行代码时，NULL只好被定义为0，二这将导致C++重载特性发生混乱</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于这两个函数来说，如果 <code>NULL</code> 又被定义为了 <code>0</code> 那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直观。</p>
<p>C++11引入了nullptr关键字，专门用来区分空指针，<code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>constexpr可以用来修饰变量、函数、构造函数，一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[func()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error : 函数调用在常量表达式中必须具有常量值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[func()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>

<p>则编译通过<br>编译期大胆地将func()做了优化，在编译期就确定了func计算出的值10而无需等到运行时再去计算。</p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto可以进行类型自动推导</p>
<p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。在以前我们需要这样来书写一个迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用auto</span></span><br><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> itr = vec.cbegin(); itr != vec.cend(); ++itr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<code>auto</code> 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）：</p>
</blockquote>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p><code>decltype</code> 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>sizeof</code> 很相似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;<span class="comment">//这里我们可以推导出x+y的类型</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++14</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强类型枚举enum-class"><a href="#强类型枚举enum-class" class="headerlink" title="强类型枚举enum class"></a>强类型枚举enum class</h2><p>原来enum</p>
<h2 id="区间迭代"><a href="#区间迭代" class="headerlink" title="区间迭代"></a>区间迭代</h2><h3 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="headerlink" title="基于范围的 for 循环"></a>基于范围的 for 循环</h3><p>终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里auto &amp;x,在代码块中的x可以修改，不允许修改可以const auto &amp;x修改。</span></span><br></pre></td></tr></table></figure>

<h3 id="C-for-each"><a href="#C-for-each" class="headerlink" title="C++ for_each()"></a>C++ for_each()</h3><p>std::for_each()函数是基于C++容器的迭代器，实现容器内元素的遍历，并对每个函数执行回调函数。</p>
<p>std::for_each()函数第一个参数是起始迭代器，第二参数是终止迭代器，第三个参数是回调函数（回调函数的形参是元素类型）。for_each()内部遍历起始，终止迭代器中间的每个元素，并把元素对象传递作为回调函数的参数，调用回调函数。</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>在c++11之前列表初始化</p>
<p>传统 C++中，普通数组、没有构造析构和虚函数的类或结构体都可以使用 {} 进行初始化，也就是我们所说的初始化列表。<br>而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行，不支持{}。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;    <span class="comment">//普通数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure>

<p>C++11新增加初始化列表std::initializer_list&lt;&gt;类型，可以通过{}语法来构造初始化列表，初始化列表是常数；一旦被创建，其成员均不能被改变，成员中的数据也不能够被变动。函数能够使用初始化列表作为参数。</p>
<p>在引入C++ 11之前，有各种不同的初始化语法。在C++ 11中，仍可以使用这些初始化语法，但也可以选择使用新引入的统一的初始化语法。统一的初始化语法用一对大括号{}表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1 = &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"welcome"</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11引入了一个新的初始化方式，称为初始化列表(List Initialize)，具体的初始化方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> static_arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> static_arr2[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;; <span class="comment">// 等号要以省略</span></span><br><span class="line"><span class="keyword">int</span>* dynamic_arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stl_vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; stl_set&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>&gt; stl_map</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">"Alice"</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"Bob"</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"Cindy"</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11将初始化列表解释成一个initializer_list<T>类型的变量（T是列表中元素的类型）。<br>它相当于一个只读的容器，只有三个成员函数：size()，begin()和end()。<br>在上面这个例子中，我们用初始化列表为STL容器提供初值。<br>C++11为STL容器新增了一种构造函数，它可以接收一个initializer_list。</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt; // This header is required</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_ilist</span>(<span class="title">const</span> <span class="title">initializer_list</span>&lt;Tp&gt; &amp;<span class="title">ilist</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ilist.<span class="built_in">begin</span>(); it != ilist.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vals[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Foo(<span class="keyword">const</span> <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; &amp;ilist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : ilist)</span><br><span class="line">            vals[n++] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; empty_ilist;</span><br><span class="line">    empty_ilist = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; empty_ilist.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    Foo foo&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="function">Foo <span class="title">bar</span><span class="params">(empty_ilist)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bar.n = "</span> &lt;&lt; bar.n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="keyword">float</span>&gt; float_ilist&#123; <span class="number">1.0</span>, <span class="number">1.2</span>, <span class="number">1.5</span>, <span class="number">2.0</span> &#125;;</span><br><span class="line">    print_ilist(float_ilist);</span><br><span class="line">    print_ilist(&#123; <span class="string">"Reimu"</span>, <span class="string">"Marisa"</span>, <span class="string">"Sanae"</span>, <span class="string">"Reisen"</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前所有的STL容器都支持初始化列表，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m = &#123; &#123;<span class="number">1</span>, <span class="string">"a"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"b"</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="模板增强"><a href="#模板增强" class="headerlink" title="模板增强"></a>模板增强</h2><p>在传统C++的编译器中，&gt;&gt;一律被当做右移运算来进行处理，但实际上我们很容易就写出了嵌套模板的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; wow;</span><br></pre></td></tr></table></figure>

<p>这在传统C++编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。</p>
<h3 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h3><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的。</strong>在传统 C++中，<code>typedef</code> 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">int</span> value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuckType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a;</span><br><span class="line">    U b;</span><br><span class="line">    SuckType():a(value),b(value)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">typedef</span> SuckType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, U, <span class="number">1</span>&gt; NewType; <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure>

<p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：</p>
<blockquote>
<p>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="built_in">process</span>)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;  <span class="comment">// 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">process</span> = <span class="keyword">int</span>(*)(<span class="keyword">void</span> *); <span class="comment">// 同上, 更加直观</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> NewType = SuckType&lt;<span class="keyword">int</span>, T, <span class="number">1</span>&gt;;    <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<h3 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>, <span class="keyword">typename</span> U = <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> add(T x, U y) -&gt; <span class="keyword">decltype</span>(x+y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><p>模板一直是 C++ 所独有的黑魔法（一起念：<strong>Dark Magic</strong>）之一。在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br></pre></td></tr></table></figure>

<p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;int,</span></span><br><span class="line"><span class="class">            std::vector&lt;int&gt;,</span></span><br><span class="line"><span class="class">            std::map&lt;std::string, std::vector&lt;int&gt;&gt;&gt; <span class="title">darkMagic</span>;</span></span><br></pre></td></tr></table></figure>

<p>既然是任意形式，所以个数为0的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。</p>
<p>如果不希望产生的模板参数个数为0，可以手动的定义至少一个模板参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br></pre></td></tr></table></figure>

<p>首先，我们可以使用 <code>sizeof...</code> 来计算参数的个数，：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以传递任意个参数给 <code>magic</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">magic();        <span class="comment">// 输出0</span></span><br><span class="line">magic(<span class="number">1</span>);       <span class="comment">// 输出1</span></span><br><span class="line">magic(<span class="number">1</span>, <span class="string">""</span>);   <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<h3 id="1-递归模板函数"><a href="#1-递归模板函数" class="headerlink" title="1. 递归模板函数"></a><strong>1. 递归模板函数</strong></h3><p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归的向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"123"</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化列表展开"><a href="#2-初始化列表展开" class="headerlink" title="2. 初始化列表展开"></a><strong>2. 初始化列表展开</strong></h3><blockquote>
<p>这个方法需要之后介绍的知识，读者可以简单阅读以下，将这个代码段保存，在后面的内容了解过了之后再回过头来阅读此处方法会大有收获。</p>
</blockquote>
<p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p>
<p>这里介绍一种使用初始化列表展开的黑魔法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译这个代码需要开启 -std=c++14</span></span><br><span class="line"><span class="comment">// 因为版本原因，实验环境中的 g++ 尚不支持此特性，此处可以使用 clang++ 替代 g++</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print</span><span class="params">(T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.1</span>, <span class="string">"123"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象增强"><a href="#面向对象增强" class="headerlink" title="面向对象增强"></a>面向对象增强</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;  <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    Base() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> value) : Base() &#123;                          <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;  <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h3><p>在传统 C++中，经常容易发生意外重载虚函数的事情。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p>
<p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="title">final</span>:</span> Base &#123;</span><br><span class="line">&#125;;                  <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123;</span><br><span class="line">&#125;;                  <span class="comment">// 非法, SubClass 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h3><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、复制构造、赋值算符以及析构函数。另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。当程序员有需要时，可以重载这部分函数。</p>
<p>这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将赋值构造函数与赋值算符声明为 <code>private</code>。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p>
<p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。若用户定义了任何构造函数，编译器将不再生成默认构造函数，但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p>
<p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Magic() = <span class="keyword">default</span>;  <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">    Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">    Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lamdba表达式其实在其他语言中广泛使用，它就是一个匿名函数,用于定义并创建一个匿名函数对象，以减缓函数工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[函数对象参数]（操作符重载函数参数）<span class="keyword">mutable</span> 或 exception 声明 -&gt;返回类型（函数体）</span><br></pre></td></tr></table></figure>

<h3 id="1-函数对象参数"><a href="#1-函数对象参数" class="headerlink" title="1)函数对象参数"></a>1)函数对象参数</h3><p>Lambda表达式的开始，不能省略。</p>
<ul>
<li><code>空</code>   没有任何函数对象参数<ul>
<li><code>=</code>  函数体中可以使用lambda所在范围所有可见的局部变量（包括lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li>
</ul>
</li>
<li><code>&amp;</code> 函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。</li>
<li><code>this</code> 函数体内可以使用lambda所在类的成员变量</li>
<li><code>a</code> 将a按值进行传递，按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的，要修改传递进来的拷贝，可以添加mutable修饰符。</li>
<li><code>a</code> <code>&amp;b</code> ,a将按值传递，b按引用进行传递</li>
<li>=，&amp;a，&amp;b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。</li>
<li>&amp;，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。</li>
</ul>
<h3 id="2）操作符重载函数参数"><a href="#2）操作符重载函数参数" class="headerlink" title="2）操作符重载函数参数"></a>2）操作符重载函数参数</h3><p>标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&amp;a, &amp;b)) 两种方式进行传递。</p>
<h3 id="3）mutable-或-exception-声明"><a href="#3）mutable-或-exception-声明" class="headerlink" title="3）mutable 或 exception 声明"></a>3）mutable 或 exception 声明</h3><p>这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。</p>
<h3 id="4）-gt-返回值类型"><a href="#4）-gt-返回值类型" class="headerlink" title="4） -&gt; 返回值类型"></a>4） -&gt; 返回值类型</h3><p>标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p>
<h3 id="5）-函数体"><a href="#5）-函数体" class="headerlink" title="5）{函数体}"></a>5）{函数体}</h3><p>标识函数的实现，这部分不能省略，但函数体可以为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数lambda</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">//无参匿名函数</span></span><br><span class="line">    <span class="keyword">auto</span> func1 = []() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"无参匿名函数不能使用任何外部变量"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//参数x是值传递,参数y是传引用</span></span><br><span class="line">    <span class="keyword">auto</span> func2 = [x, &amp;y](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"参数x是值传递,参数y是传引用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> func3 = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"所有参数都是传引用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> func4 = [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"所有参数都是值引用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> func5 = [&amp;, x](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x是按值传递,其他参数都是按引用传递"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> func6 = [=, &amp;x](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x按引用传递,其他参数按照值传递"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    func1();</span><br><span class="line">    func2(x, y);</span><br><span class="line">    func3(x, y, z);</span><br><span class="line">    func4(x, y, z);</span><br><span class="line">    func5(x, y, z);</span><br><span class="line">    func6(x, y, z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++关键字</title>
    <url>/2017/11/25/C++%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="C-知识点"><a href="#C-知识点" class="headerlink" title="C++知识点"></a><strong>C++知识点</strong></h2><h3 id="C-不常用关键字"><a href="#C-不常用关键字" class="headerlink" title="C++不常用关键字"></a><strong>C++不常用关键字</strong></h3><h4 id="1-asm"><a href="#1-asm" class="headerlink" title="1. asm"></a><strong>1. asm</strong></h4><blockquote>
<p>asm(指令字符串)：允许在C++程序中嵌入汇编代码。</p>
</blockquote>
<h4 id="2-auto"><a href="#2-auto" class="headerlink" title="2. auto"></a><strong>2. auto</strong></h4><blockquote>
<p>auto（自动，automatic）是存储类型标识符，表明变量”自动”具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。</p>
</blockquote>
<h4 id="3-bool"><a href="#3-bool" class="headerlink" title="3. bool"></a><strong>3. bool</strong></h4><blockquote>
<p>bool代表为布尔类型，值为true(真)或者false（假），C++中bool类型可以和int混用，0代表false，非0代表为true。bool类型常用于条件判断和函数返回值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br></pre></td></tr></table></figure>


<h4 id="4-catch"><a href="#4-catch" class="headerlink" title="4. catch"></a><strong>4. catch</strong></h4><blockquote>
<p>catch 和 try 语句一起用于异常处理。</p>
</blockquote>
<h4 id="5-const"><a href="#5-const" class="headerlink" title="5. const"></a><strong>5. const</strong></h4><ol>
<li>修饰变量，说明该变量不能被改变。</li>
</ol>
<ol start="2">
<li>修饰指针，分为指向常量的指针和指向常量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;	<span class="comment">//指针指向的变量不能修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;	<span class="comment">//指针不能修改</span></span><br></pre></td></tr></table></figure>


<ol start="3">
<li>常量引用，经常用于形参类型，避免了拷贝，有避免了函数对值的修改。</li>
</ol>
<ol start="4">
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>


<h4 id="6-static"><a href="#6-static" class="headerlink" title="6. static"></a><strong>6. static</strong></h4><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<h4 id="7-extern-“C”"><a href="#7-extern-“C”" class="headerlink" title="7. extern “C”"></a><strong>7. extern “C”</strong></h4><blockquote>
<ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和连接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//如果采用C++，如下代码使用C编译器</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<h4 id="8-explicit"><a href="#8-explicit" class="headerlink" title="8. explicit"></a><strong>8. explicit</strong></h4><blockquote>
<p>explicit（显式的）的作用是”禁止单参数构造函数”被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。</p>
</blockquote>
<p>C++编译器默认有隐式类型转换，使用explicit可以禁止构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()  &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">char</span> a,<span class="keyword">int</span> b = <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a, <span class="keyword">char</span> b) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = <span class="number">2</span>) &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;   <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">//调用A(int a) &#123;&#125;</span></span><br><span class="line">    A c = <span class="number">1</span>; <span class="comment">//调用A(int a) &#123;&#125;,C++编译器针对只有一个参数的构造函数，会隐式类型转换,通过右值类型直接调用参数类型相同（排除默认参数的构造函数也是符合的）的构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">//A(int a, int b, int c = 2) &#123;&#125;</span></span><br><span class="line">    A e = <span class="string">'A'</span>; <span class="comment">// A(char a,int b = 1) &#123;&#125; 这里也是隐式类型转化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对隐式类型转化，我们可以通过关键字explicit修饰构造函数，这样定义类变量时，只能显示的调用构造函数才能定义变量，<em>例如</em>：explicit A(char a,int b = 1)；</p>
<h4 id="9-register"><a href="#9-register" class="headerlink" title="9. register"></a><strong>9. register</strong></h4><blockquote>
<p>register关键字请求编译器让变量直接放在寄存器里面，速度快</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2019/06/09/C-STL/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>容器（containers）</li>
<li>算法（algorithms)</li>
<li>迭代器（iterators）</li>
<li>仿函数（function）</li>
<li>配接器（adapter）</li>
<li>空间配置器（allocator）</li>
</ul>
<h3 id="STL容器种类和功能"><a href="#STL容器种类和功能" class="headerlink" title="STL容器种类和功能"></a>STL容器种类和功能</h3><ul>
<li>序列容器    (vector、list、deque)</li>
<li>排序容器    (set、multiset、map、multimap)</li>
<li>哈希容器    (unordered_set、unordered_multiset、unordered_map、unordered_multimap)</li>
</ul>
<table>
<thead>
<tr>
<th>容器</th>
<th>对应的迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set / multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map / multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map / unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set / unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><table>
<thead>
<tr>
<th>迭代器定义方式</th>
<th>具体格式</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td>容器类名::iterator 迭代器名;</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>容器类名::const_iterator 迭代器名;</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>容器类名::reverse_iterator 迭代器名;</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>容器类名::const_reverse_iterator 迭代器名;</td>
</tr>
</tbody></table>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/2-1P911110REB.jpg" alt="img"> </p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><blockquote>
<p>数组容器其长度就是固定不变，这意味着能增加或删除元素，只能改变某个元素的值。</p>
</blockquote>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义个int型数组，大小为5</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr1&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//和数组一样，通过operator[]访问</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定index，获取元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr.at(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取最后一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取指向内存中数组的第一个元素的指针</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get非array的成员方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取容量"><a href="#获取容量" class="headerlink" title="获取容量"></a>获取容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数组是否为空，true为空，false为非空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; arr.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组元素的个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取数组可容纳的最大个数，因为每个 std::array&lt;T, N&gt; 都是固定大小容器，故 max_size 返回的值等于 N</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义个int型数组，大小为5</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; arr1 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将val这个值赋值给容器中的每个元素</span></span><br><span class="line">    arr.<span class="built_in">fill</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数组的值</span></span><br><span class="line">    arr.swap(arr1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义个int型数组，大小为5</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 7&gt; arr = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到返回迭代器的位置，找不到就返回last</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">find</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>实现原理：元素不够时在重新分配内存，拷贝原来的数组的元素到新分配的数组中。</p>
<h4 id="vector创建"><a href="#vector创建" class="headerlink" title="vector创建"></a>vector创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(x)                              \</span></span><br><span class="line">    &#123;                                         \</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); i++) \</span><br><span class="line">        &#123;                                     \</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x[i] &lt;&lt; <span class="string">" "</span>;              \</span><br><span class="line">        &#125;                                     \</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;                         \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//空vector</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector具有10个整型元素的向量</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector具有10个整型元素，每个元素为1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值构造函数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新vector，将c向量的第一个元素到第三个元素的值赋值给e向量</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">e</span><span class="params">(c.<span class="built_in">begin</span>(), c.<span class="built_in">begin</span>() + <span class="number">3</span>)</span></span>;</span><br><span class="line">    PRINT(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//创建新vector，将数组f的第一个元素到第三个元素的值赋值给g向量</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(f, f + <span class="number">3</span>)</span></span>;</span><br><span class="line">    PRINT(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; a.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预留容器空间</span></span><br><span class="line">    a.reserve(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变容器的大小</span></span><br><span class="line">    a.resize(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除未使用的容量</span></span><br><span class="line">    a.shrink_to_fit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    a.insert(a.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    a.insert(a.<span class="built_in">end</span>(), vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定位置直接生成元素</span></span><br><span class="line">    a.emplace(a.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在序列尾部生成一个元素</span></span><br><span class="line">    a.emplace_back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素添加到容器末尾</span></span><br><span class="line">    a.push_back(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除末元素</span></span><br><span class="line">    a.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变容器的可存储元素的个数</span></span><br><span class="line">    a.resize(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换内容</span></span><br><span class="line">    vec.swap(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//倒置容器</span></span><br><span class="line">    reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用swap清空vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;().swap(myvector);	<span class="comment">//清空myvector</span></span><br></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>设计原理：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/2-19121316430U40.gif" alt="deque容器的底层实现"> </p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建空的deque</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个具有n个元素的deque容器</span></span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个具有n个元素的deque容器，并为每个元素都指定初始值</span></span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(d)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问-2"><a href="#元素访问-2" class="headerlink" title="元素访问"></a>元素访问</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过index访问指定的元素，会进行越界检查</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问指定的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问第一元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问最后一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-1"><a href="#容量-1" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查容器是否为空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; a.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回容纳的元素数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回可容纳的最大元素数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过释放未使用的内存，减少内存的使用</span></span><br><span class="line">    a.shrink_to_fit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;int&gt; a &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;插入元素</span><br><span class="line">    a.insert(a.begin(), 10);</span><br><span class="line">    deque&lt;int&gt; b &#x3D; &#123;5, 4, 3, 2, 1&#125;;</span><br><span class="line">    a.insert(a.begin(), b.begin(), b.end());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将元素添加到容器末尾</span><br><span class="line">    a.push_back(10);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;插入元素到容器起始</span><br><span class="line">    a.push_front(10);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除末元素</span><br><span class="line">    a.pop_back();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除首元素</span><br><span class="line">    a.pop_front();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在指定位置，生成一个元素</span><br><span class="line">    a.emplace(a.begin());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在容器尾部生成一个元素</span><br><span class="line">    a.emplace_back();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在容器首部生成一个元素</span><br><span class="line">    a.emplace_front();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除指定位置的元素</span><br><span class="line">    a.erase(a.begin());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除指定范围的元素</span><br><span class="line">    a.erase(a.begin(), a.begin() + 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;改变容器中可存储元素的个数</span><br><span class="line">    a.resize(100);</span><br><span class="line"></span><br><span class="line">    a.swap(b);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><blockquote>
<p>双链表</p>
</blockquote>
<h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个任何元素空list容器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个包含n个元素的list容器</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个包含10个元素并且都为5个容器</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问-3"><a href="#元素访问-3" class="headerlink" title="元素访问"></a>元素访问</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-2"><a href="#容量-2" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; a.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; value1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//返回第一个元素的引用</span></span><br><span class="line">    value1.front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最后一个元素的引用</span></span><br><span class="line">    value1.back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在新元素替换容器中原有内容</span></span><br><span class="line">    value1.assign(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器头部生成一个元素</span></span><br><span class="line">    value1.emplace(value1.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器头部生成一个元素</span></span><br><span class="line">    value1.emplace_front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器尾部生成一个元素</span></span><br><span class="line">    value1.emplace_back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器头部插入一个元素</span></span><br><span class="line">    value1.push_front(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器尾部插入一个元素</span></span><br><span class="line">    value1.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除容器头部一个元素</span></span><br><span class="line">    value1.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除容器尾部一个元素</span></span><br><span class="line">    value1.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器中的指定位置插入元素</span></span><br><span class="line">    value1.insert(value1.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除指定迭代器位置的元素</span></span><br><span class="line">    value1.erase(value1.<span class="built_in">begin</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; value1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1 = &#123; <span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list2 = &#123; <span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    list1.sort();	<span class="comment">//排序</span></span><br><span class="line">    list2.sort();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//合并二个已排序</span></span><br><span class="line">    list1.merge(list2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list3 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list4 = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从一个 list 转移元素给另一个。</span></span><br><span class="line">    list1.splice(it, list2);</span><br><span class="line">    </span><br><span class="line">    list2.splice(list2.<span class="built_in">begin</span>(), list1, list1.<span class="built_in">begin</span>();</span><br><span class="line">, list1.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list5 = &#123; <span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">-1</span>,<span class="number">12</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    list5.<span class="built_in">remove</span>(<span class="number">1</span>); <span class="comment">// 移除两个等于 1 的元素</span></span><br><span class="line">    list5.remove_if([](<span class="keyword">int</span> n)&#123; <span class="keyword">return</span> n &gt; <span class="number">10</span>; &#125;); <span class="comment">// 移除全部大于 10 的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒置</span></span><br><span class="line">    list5.reverse();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    x.unique();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清除内容</span></span><br><span class="line">    value1.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（例如 array、vector、deque 等）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 { } 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void splice (iterator position, list&amp; x);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator i);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td>
</tr>
</tbody></table>
<h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>forward_list是单链表</p>
<p>链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过指针来维持。</p>
<blockquote>
<p>效率高是选用forward_list而弃用list容器最主要的原因，如果list和forward_list容器都能实现的操作，应优先选择forward_list容器</p>
</blockquote>
<h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; values = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt;arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt;values(arr.<span class="built_in">begin</span>()+<span class="number">2</span>, arr.<span class="built_in">end</span>());<span class="comment">//拷贝arr容器中的&#123;13,14,15&#125;</span></span><br></pre></td></tr></table></figure>

<p>其他大多数方法和list一样</p>
<h4 id="元素访问-4"><a href="#元素访问-4" class="headerlink" title="元素访问"></a>元素访问</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-3"><a href="#容量-3" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; value.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    value.insert_after(value.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line">    value.insert_after(value.<span class="built_in">begin</span>(), &#123;<span class="number">10</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器中的指定位置后插入新元素</span></span><br><span class="line">    value.emplace_after(value.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入新元素到容器起始</span></span><br><span class="line">    value.emplace_front();</span><br><span class="line"></span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素后的元素</span></span><br><span class="line">    l.erase_after(l.before_begin());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在容器的起始位置</span></span><br><span class="line">    l.push_front(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除首元素</span></span><br><span class="line">    l.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变容器中可存储元素的个数</span></span><br><span class="line">    l.resize(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个容器的</span></span><br><span class="line">    value.swap(l);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; list1 = &#123; <span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; list2 = &#123; <span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    list1.sort();</span><br><span class="line">    list2.sort();</span><br><span class="line">    </span><br><span class="line">    list1.merge(list2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; l1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; l2 = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    l2.splice_after(l2.cbegin(), l1, l1.cbegin(), l1.cend());</span><br><span class="line">    </span><br><span class="line">    l.<span class="built_in">remove</span>(<span class="number">1</span>); <span class="comment">// 移除两个等于 1 的元素</span></span><br><span class="line">    l.remove_if([](<span class="keyword">int</span> n)&#123; <span class="keyword">return</span> n &gt; <span class="number">10</span>; &#125;); <span class="comment">// 移除全部大于 10 的元素</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    list1.reverse();</span><br><span class="line">    </span><br><span class="line">    list1.unique();</span><br><span class="line">    </span><br><span class="line">    list1.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote>
<p>使用容器存储的数据，其各个元素的键必须是唯一的，改容器会根据元素键的大小，默认进行升序排序</p>
</blockquote>
<p> 底层实现都是红黑树（RB-Tree） </p>
<h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的map容器</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建map容器，也可以进行初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123;&#123;<span class="string">"小明"</span>, <span class="number">10</span>&#125;, &#123;<span class="string">"小李"</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过pair创建map</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; myMap&#123;<span class="built_in">std</span>::make_pair(<span class="string">"小明"</span>, <span class="number">10</span>), <span class="built_in">std</span>::make_pair(<span class="string">"小李"</span>, <span class="number">20</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;newMap(myMap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素访问-5"><a href="#元素访问-5" class="headerlink" title="元素访问"></a>元素访问</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建map容器，也可以进行初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; myMap&#123;&#123;<span class="number">1</span>, <span class="string">"小明"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"小李"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//myMap[key] 获取value</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMap[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMap.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-4"><a href="#容量-4" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; myMap&#123;&#123;<span class="number">1</span>, <span class="string">"小明"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"小李"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; myMap.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMap.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; myMap&#123;&#123;<span class="number">1</span>, <span class="string">"小明"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"小李"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    myMap.insert(&#123;<span class="number">3</span>, <span class="string">"小袁"</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的移动构造函数</span></span><br><span class="line">    m.emplace(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"a"</span>), <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"a"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的转换移动构造函数</span></span><br><span class="line">    m.emplace(<span class="built_in">std</span>::make_pair(<span class="string">"b"</span>, <span class="string">"abcd"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的模板构造函数</span></span><br><span class="line">    m.emplace(<span class="string">"d"</span>, <span class="string">"ddd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的逐片构造函数</span></span><br><span class="line">    m.emplace(<span class="built_in">std</span>::piecewise_construct,</span><br><span class="line">              <span class="built_in">std</span>::forward_as_tuple(<span class="string">"c"</span>),</span><br><span class="line">              <span class="built_in">std</span>::forward_as_tuple(<span class="number">10</span>, <span class="string">'c'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; c = &#123;&#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"two"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"three"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"four"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"five"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"six"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回匹配特定键的元素数量数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c.count(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c.erase(c.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; example = &#123;&#123;<span class="number">1</span>, <span class="string">'a'</span>&#125;, &#123;<span class="number">2</span>, <span class="string">'b'</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> search = example.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (search != example.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *&gt; example1&#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="string">"zero"</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">"two"</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回匹配特定键的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> p = example1.equal_range(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q = p.first; q != p.second; ++q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"m["</span> &lt;&lt; q-&gt;first &lt;&lt; <span class="string">"] = "</span> &lt;&lt; q-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指向首个不小于给定键的元素的迭代器</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; example1.lower_bound(<span class="number">1</span>)-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指向首个大于给定键的元素的迭代器</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; example1.upper_bound(<span class="number">1</span>)-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><blockquote>
<p><code>set</code> 是关联容器，含有 <code>Key</code> 类型对象的已排序集。</p>
</blockquote>
<h4 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认初始化器</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; a;</span><br><span class="line">    a.insert(<span class="string">"cat"</span>);</span><br><span class="line">    a.insert(<span class="string">"dog"</span>);</span><br><span class="line">    a.insert(<span class="string">"horse"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;str : a)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器初始化器</span></span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">b</span><span class="params">(a.<span class="built_in">find</span>(<span class="string">"dog"</span>), a.<span class="built_in">end</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//列表构造初始化</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; e&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"five"</span>, <span class="string">"eight"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-5"><a href="#容量-5" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//列表构造初始化</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; e&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"five"</span>, <span class="string">"eight"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; e.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//列表构造初始化</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; e&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"five"</span>, <span class="string">"eight"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    e.insert(<span class="string">"nine"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = myset.emplace(<span class="string">"yuandongbin"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret.iter = &lt;"</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">", "</span> &lt;&lt; ret.second &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; myset1;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = myset1.emplace_hint(myset1.<span class="built_in">begin</span>(), <span class="string">"yuandongbin"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"myset size = "</span> &lt;&lt; myset1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myset2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="keyword">int</span> num = myset2.erase(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、myset size = "</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter1 = myset2.erase(myset2.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、myset size = "</span> &lt;&lt; myset2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter-&gt;"</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator iter2 = myset2.erase(myset2.<span class="built_in">begin</span>(), --myset2.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、myset size = "</span> &lt;&lt; myset2.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"iter2-&gt;"</span> &lt;&lt; *iter2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emplace()的返回值的类型为pair类型，其中包含2个元素，一个迭代器和一个bool值</p>
<ul>
<li>当改方法将目标元素成功添加到set容器中时，其返回的迭代器指向新插入的元素，同时bool值为true</li>
<li>当添加失败时，则表明原set容器中已存在相同的元素，此时返回的迭代器指向容器中具有相同键的这个元素，同时bool值为false。</li>
</ul>
<p>emplace_hint()</p>
<ul>
<li>改方法需要额外传入一个迭代器，用来指明新元素添加到set容器的<code>具体位置</code>(新元素会添加到改迭代器指向元素的前面)</li>
<li>返回值是一个迭代器，而不再是pair对象，当成功添加元素时，返回迭代器指向新添加的元素，反之，如果添加失败，则迭代器就指向set容器和要添加元素的值相同的元素。</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; example = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> search = example.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (search != example.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Found "</span> &lt;&lt; (*search) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">4</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">4</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : m)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span></span><br><span class="line">            &lt;&lt; p.first &lt;&lt; <span class="string">' '</span> &lt;&lt; p.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-6"><a href="#容量-6" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m = &#123;&#123;<span class="string">"xx"</span>, <span class="string">"xxx"</span>&#125;, &#123;<span class="string">"11"</span>, <span class="string">"111"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; m.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; mmap&#123;&#123;<span class="number">2</span>, <span class="string">"foo"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"bar"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"baz"</span>&#125;, &#123;<span class="number">1</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"def"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 value_type 插入</span></span><br><span class="line">    mmap.insert(<span class="keyword">decltype</span>(mmap)::value_type(<span class="number">5</span>, <span class="string">"pqr"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 make_pair 插入</span></span><br><span class="line">    mmap.insert(<span class="built_in">std</span>::make_pair(<span class="number">6</span>, <span class="string">"uvw"</span>));</span><br><span class="line"></span><br><span class="line">    mmap.insert(&#123;<span class="number">7</span>, <span class="string">"xyz"</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的移动构造函数</span></span><br><span class="line">    m.emplace(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"a"</span>), <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"a"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的转换移动构造函数</span></span><br><span class="line">    m.emplace(<span class="built_in">std</span>::make_pair(<span class="string">"b"</span>, <span class="string">"abcd"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的模板构造函数</span></span><br><span class="line">    m.emplace(<span class="string">"d"</span>, <span class="string">"ddd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pair 的逐片构造函数</span></span><br><span class="line">    m.emplace(<span class="built_in">std</span>::piecewise_construct,</span><br><span class="line">              <span class="built_in">std</span>::forward_as_tuple(<span class="string">"c"</span>),</span><br><span class="line">              <span class="built_in">std</span>::forward_as_tuple(<span class="number">10</span>, <span class="string">'c'</span>));</span><br><span class="line"></span><br><span class="line">    m.emplace_hint(m.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="string">"xyz"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定位置</span></span><br><span class="line">    m.erase(m.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; p.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; mmap&#123;&#123;<span class="number">2</span>, <span class="string">"foo"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"bar"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"baz"</span>&#125;, &#123;<span class="number">1</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"def"</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//返回指定key的元素的个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mmap.count(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> search = mmap.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (search != mmap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; search-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; search-&gt;second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><h4 id="创建-6"><a href="#创建-6" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mymultiset;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mymultiset1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mymultiset2</span><span class="params">(mymultiset1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容量-7"><a href="#容量-7" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mymultiset1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; mymultiset1.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultiset1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultiset1.max_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作-7"><a href="#操作-7" class="headerlink" title="操作"></a>操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mymultiset&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    mymultiset.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除容器中所有值为2的元素</span></span><br><span class="line">    <span class="keyword">int</span> num = mymultiset.erase(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入新元素到容器</span></span><br><span class="line">    mymultiset.emplace(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    mymultiset.emplace_hint(mymultiset.<span class="built_in">begin</span>(), <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : mymultiset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="allocaotr"><a href="#allocaotr" class="headerlink" title="allocaotr"></a>allocaotr</h3><p>STL的分配器用于封装STL容器在内存管理上的底层细节。</p>
<p>alloc::allocate()用来申请内存</p>
<p>alloc::deallocate()用来释放内存</p>
<p> 对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p> 同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。 </p>
<h3 id="内存池技术"><a href="#内存池技术" class="headerlink" title="内存池技术"></a>内存池技术</h3><p>使用目的：</p>
<ul>
<li>减少new、delete的调用，减少运行时间</li>
<li>避免内存碎片</li>
</ul>
<p>内存池的原理是，在真正的使用内存之前，预先申请分配一定数量，大小预设的内存块留作备用，当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存，当内存释放后就回归到内存块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。 </p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ pair</title>
    <url>/2020/06/18/C-pair/</url>
    <content><![CDATA[<h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>pair可以将两个数据组合成一个数据</p>
<p>头文件： <code>#include &lt;utility&gt;</code></p>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">std::pair&lt;string, string&gt; getpair()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_pair(<span class="string">"yuan"</span>, <span class="string">"dongbin"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair2("hello", "world");</span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair3(pair2);</span><br><span class="line">    <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair4(make_pair("hello", "world"));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair5(string("hello"), string("world"));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair1: "</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair3: "</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair4: "</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair5: "</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step::判断"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pair2 == pair5)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"两个pair数据相等"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step::赋值1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pair2.first = <span class="string">"你好"</span>;</span><br><span class="line">    pair2.second = <span class="string">"世界"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step::赋值2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pair2 = make_pair(<span class="string">"nihao"</span>, <span class="string">"shijie"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair2: "</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step::pair作为返回值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    pair5 = getpair();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pair5: "</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>C++内存泄漏检查器</title>
    <url>/2020/05/24/C-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    <content><![CDATA[<p>我们只需要重载new、delete。</p>
<p>LeakDetector.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LeakDetector.hpp</span></span><br><span class="line"><span class="comment">//  LeakDetector</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by changkun on 16/9/13.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016 shiyanlou.com, all rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LEAK_DETECTOR__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LEAK_DETECTOR__</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> _size, <span class="keyword">char</span> *_file, <span class="keyword">unsigned</span> <span class="keyword">int</span> _line)</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> _size, <span class="keyword">char</span> *_file, <span class="keyword">unsigned</span> <span class="keyword">int</span> _line);</span><br><span class="line"><span class="comment">// 此处宏的作用在 LeakDetector.cpp 中说明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NEW_OVERLOAD_IMPLEMENTATION__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> new	new(__FILE__, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">leak_detector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> callCount;</span><br><span class="line">    _leak_detector() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ++callCount;</span><br><span class="line">    &#125;</span><br><span class="line">    ~_leak_detector() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (--callCount == <span class="number">0</span>)</span><br><span class="line">            LeakDetector();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LeakDetector</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> _leak_detector _exit_counter;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>LeakDetector.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LeakDetector.cpp</span></span><br><span class="line"><span class="comment">//  LeakDetector</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by changkun on 16/9/13.</span></span><br><span class="line"><span class="comment">//  Copyright © 2016 shiyanlou.com, all rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此处定义 _DEBUG_NEW_ 宏, 从而在这个实现文件中不再重载 new 运算符, 从而防止编译冲突</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NEW_OVERLOAD_IMPLEMENTATION__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LeakDetector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MemoryList</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  _<span class="title">MemoryList</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> 	<span class="built_in">size</span>;       <span class="comment">// 申请内存的大小</span></span><br><span class="line">    <span class="keyword">bool</span>    isArray;    <span class="comment">// 是否申请了数组</span></span><br><span class="line">    <span class="keyword">char</span>    *file;      <span class="comment">// 存储所在文件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">line</span>;  <span class="comment">// 保存所在行</span></span><br><span class="line">&#125; _MemoryList;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _memory_allocated = <span class="number">0</span>;     <span class="comment">// 保存未释放的内存大小</span></span><br><span class="line"><span class="keyword">static</span> _MemoryList _root = &#123;</span><br><span class="line">    &amp;_root, &amp;_root, <span class="comment">// 第一个元素的前向后向指针均指向自己</span></span><br><span class="line">    <span class="number">0</span>, <span class="literal">false</span>,               <span class="comment">// 其申请的内存大小为 0, 且不是数组</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="number">0</span>                 <span class="comment">// 文件指针为空, 行号为0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _leak_detector::callCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 _MemoryList 头部开始分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">AllocateMemory</span><span class="params">(<span class="keyword">size_t</span> _size, <span class="keyword">bool</span> _array, <span class="keyword">char</span> *_file, <span class="keyword">unsigned</span> _line)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算新的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> newSize = <span class="keyword">sizeof</span>(_MemoryList) + _size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于 new 已经被重载，我们只能使用 malloc 来分配内存</span></span><br><span class="line">    _MemoryList *newElem = (_MemoryList*)<span class="built_in">malloc</span>(newSize);</span><br><span class="line">    </span><br><span class="line">    newElem-&gt;next = _root.next;</span><br><span class="line">    newElem-&gt;prev = &amp;_root;</span><br><span class="line">    newElem-&gt;<span class="built_in">size</span> = _size;</span><br><span class="line">    newElem-&gt;isArray = _array;</span><br><span class="line">    newElem-&gt;file = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有文件信息，则保存下来</span></span><br><span class="line">    <span class="keyword">if</span> (_file) &#123;</span><br><span class="line">        newElem-&gt;file = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(_file)+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(newElem-&gt;file, _file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存行号</span></span><br><span class="line">    newElem-&gt;<span class="built_in">line</span> = _line;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新列表</span></span><br><span class="line">    _root.next-&gt;prev = newElem;</span><br><span class="line">    _root.next = newElem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录到未释放内存数中</span></span><br><span class="line">    _memory_allocated += _size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回申请的内存</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newElem + <span class="keyword">sizeof</span>(_MemoryList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">DeleteMemory</span><span class="params">(<span class="keyword">void</span>* _ptr, <span class="keyword">bool</span> _array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 MemoryList 开始处</span></span><br><span class="line">    _MemoryList *currentElem = (_MemoryList *)((<span class="keyword">char</span> *)_ptr - <span class="keyword">sizeof</span>(_MemoryList));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentElem-&gt;isArray != _array) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新列表</span></span><br><span class="line">    currentElem-&gt;prev-&gt;next = currentElem-&gt;next;</span><br><span class="line">    currentElem-&gt;next-&gt;prev = currentElem-&gt;prev;</span><br><span class="line">    _memory_allocated -= currentElem-&gt;<span class="built_in">size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记得释放存放文件信息时申请的内存</span></span><br><span class="line">    <span class="keyword">if</span> (currentElem-&gt;file) <span class="built_in">free</span>(currentElem-&gt;file);</span><br><span class="line">    <span class="built_in">free</span>(currentElem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 new 运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> _size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AllocateMemory(_size, <span class="literal">false</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> _size) &#123;</span><br><span class="line">    <span class="keyword">return</span> AllocateMemory(_size, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> _size, <span class="keyword">char</span> *_file, <span class="keyword">unsigned</span> <span class="keyword">int</span> _line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AllocateMemory(_size, <span class="literal">false</span>, _file, _line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> _size, <span class="keyword">char</span> *_file, <span class="keyword">unsigned</span> <span class="keyword">int</span> _line) &#123;</span><br><span class="line">    <span class="keyword">return</span> AllocateMemory(_size, <span class="literal">true</span>, _file, _line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载 delete 运算符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *_ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    DeleteMemory(_ptr, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *_ptr) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    DeleteMemory(_ptr, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">_leak_detector::LeakDetector</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历整个列表, 如果有内存泄露，那么 _LeakRoot.next 总不是指向自己的</span></span><br><span class="line">    _MemoryList *ptr = _root.next;</span><br><span class="line">    <span class="keyword">while</span> (ptr &amp;&amp; ptr != &amp;_root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出存在内存泄露的相关信息, 如泄露大小, 产生泄露的位置</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;isArray)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"泄露[] "</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"泄露   "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptr &lt;&lt; <span class="string">" 大小 "</span> &lt;&lt; ptr-&gt;<span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;file)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" (位于 "</span> &lt;&lt; ptr-&gt;file &lt;&lt; <span class="string">" 第 "</span> &lt;&lt; ptr-&gt;<span class="built_in">line</span> &lt;&lt; <span class="string">" 行)"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" (无文件信息)"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">        ++count;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"存在"</span> &lt;&lt; count &lt;&lt; <span class="string">"处内存泄露, 共包括 "</span>&lt;&lt; _memory_allocated &lt;&lt; <span class="string">" byte."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础</title>
    <url>/2019/11/25/C-C-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="语言翻译"><a href="#语言翻译" class="headerlink" title="语言翻译"></a>语言翻译</h2><p>计算器可以识别<strong>机器语言</strong>，人往往使用编程语言来编程，这就涉及到编程语言源代码到机器语言的转化，通常，翻译器分为两类：解释器和编译器。</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释器将源代码转化成机器语言并立即执行，它一般是边转化边执行，遇到之前重复的内容还需要重新翻译和执行，可想而知这个效率上并不好，例如python解释器，将源代码转化为一种中间语言，然后由执行速度更快的解释器来执行。</p>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译器直接将源代码转化成汇编语言或机器指令。编译器生成的程序往往只需要较少的运行空间，并且执行速度更快。更重要的是例如C语言可以分别编译各段程序，最后使用连接器将各段程序连接成一个完成可执行程序，这个成为<code>分段编译</code>。</p>
<h3 id="C语言编译"><a href="#C语言编译" class="headerlink" title="C语言编译"></a>C语言编译</h3><p>gcc的编译流程分为四个步骤：</p>
<ul>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>连接</li>
</ul>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><blockquote>
<p> 预处理程序是一个简单的程序，它用程序员定义好的代码替代需要预处理的代码，预处理可以节省输入，增加代码的可读性。</p>
<p> 也可以这么理解，预处理基本上针对“#“ 修饰的代码进行处理。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure>

<p>选项<code>-o</code>是指目标文件，<code>.i</code>文件为已经预处理后的C原始代码。</p>
<p><code>#</code>的使用</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#define</td>
<td>定义一个预处理宏 或者定义一个常量</td>
</tr>
<tr>
<td>#undef</td>
<td>取消宏的定义</td>
</tr>
<tr>
<td>#if</td>
<td>预处理中的条件命令，相当于C中的if语句</td>
</tr>
<tr>
<td>#ifdef</td>
<td>判断一个宏是否被定义，若定义，执行后面的语句</td>
</tr>
<tr>
<td>#ifndef</td>
<td>判断一个宏如果没有被定义</td>
</tr>
<tr>
<td>#elif</td>
<td>相当于C中eles-if</td>
</tr>
<tr>
<td>#else</td>
<td>相当于C中的else</td>
</tr>
<tr>
<td>#endif</td>
<td>与#if, #ifdef, #ifndef配套使用</td>
</tr>
<tr>
<td>#include</td>
<td>引用头文件</td>
</tr>
</tbody></table>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><blockquote>
<p>有条件的去编译，经典应用，头文件、跨平台编译</p>
</blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(或者<span class="meta-keyword">ifdef</span>)</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(或者<span class="meta-keyword">ifndef</span>)</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ()</span></span><br><span class="line"><span class="comment">//代码段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> ()</span></span><br><span class="line"><span class="comment">//代码段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//代码段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>应用</strong>一：防止头文件重复引用</p>
<p>假如有一个头文件 hello.h（宏我们一般大写）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HELLO_H__ <span class="comment">//(或者写成 #if !define __HELLO_H__) 如果这个宏没有定义,往下执行，如果宏已经被定义了，下面内容不会被引用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HELLO_H__ <span class="comment">//定义这个宏，只有第一次引用头文件会执行到这里</span></span></span><br><span class="line"><span class="comment">//声明、定义语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>应用二</strong>：使用DEBUG进行调试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//#define DEBUG 如果想要编译预定义宏DEBUG内的代码，需要取消注释。 或者使用#undef取消宏定义也是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h5><p>带参数的宏。利用宏可以提高代码的运行效率，子程序的调用需要压栈出栈，这一过程会过于频繁会消耗大量的cpu运算资源。</p>
<p><strong>建议</strong>：一些代码量小但运行频繁的代码可以采用带参数宏来实现会提高代码的运行效率，例如：参数校验、获取长度等等经常需要用到的。C++中也可以inline（内联函数），它们的效率是一样的。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>宏不像函数，不会检查入参和返回值，相对不安全</p>
</li>
<li><p>不容易调试</p>
</li>
<li><p>大量的引用宏会使代码膨胀</p>
</li>
</ol>
<p><strong>宏的特殊符号</strong></p>
<blockquote>
<p>#和##是两个特殊符号</p>
</blockquote>
<ol>
<li>#表示将一个宏参数变成一个字符串</li>
<li>##表示把两个字符串粘在一起</li>
</ol>
<p>应用场景：（使用一个宏创建一个一种速记方式打印变量字符串化的表达式）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(A) cout &lt;&lt; #A &lt;&lt;<span class="meta-string">": "</span> &lt;&lt; A &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(A)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 这里可以通过是否存在宏定义DEBUG，使得P(A) 表达式是否起作用</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	P(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h5><p>例举我们常用的几个：</p>
<ul>
<li><code>__LINE__</code></li>
<li><code>__FILE__</code></li>
<li><code>__DATE__</code></li>
<li><code>__TIME__</code></li>
<li><code>__STDC__</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"该输出行在源程序中的位置：%d\n"</span>, __LINE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"该程序的文件名为：%s\n"</span>, __FILE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"当前日期为：%s\n"</span>, __DATE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"当前时间为：%s\n"</span>, __TIME__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>assert宏</p>
<p>头文件：assert.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">assert(布尔值)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(<span class="number">1</span> == <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line"><span class="meta">#</span><span class="bash"> -S选项进行编译而不进行汇编</span></span><br></pre></td></tr></table></figure>

<p>先检查语法处理，在检查无误之后，将代码转化为汇编语言。</p>
<h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line"><span class="meta">#</span><span class="bash"> -c选项将.s文件转化为二进制文件</span></span><br></pre></td></tr></table></figure>

<p>汇编阶段将<code>.s</code> 文件转化为<code>.o</code>文件（又称为目标文件）的二进制文件。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译是针对一个源文件的，有多少个源文件就需要编译多少次，就会生成多少个目标文件。</p>
</blockquote>
<p>链接阶段就是代码连接库文件。</p>
<p>库文件一般分为静态库和动态库，静态库是指将编译连接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时就不需要库文件了，后缀一般为<code>.a</code>，动态库是在程序执行过程中链接加载库。这样可以节省系统的开销。动态库一般的后缀名为<code>.so</code>。</p>
<h4 id="连接器如何查找库"><a href="#连接器如何查找库" class="headerlink" title="连接器如何查找库"></a>连接器如何查找库</h4><p>当C要对函数和变量进行外部引用时，根据引用情况，如果为遇到过这个函数或者变量的定义，连接器会将它的标识符加到<code>未解析第引用</code>列表中。如果连接器遇到过函数或者变量定义，就标记已解决第引用，最后总的统计下有未解析的引用，就说明函数或者变量没有定义。</p>
<h4 id="包含头文件的方式"><a href="#包含头文件的方式" class="headerlink" title="包含头文件的方式"></a>包含头文件的方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>用尖括号来指定文件时，预处理器是去特定的路径去找头文件，这个路径一般是环境中或编译器中指定的某个路径（不同场景下的路径肯定有所不同）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br></pre></td></tr></table></figure>

<p>预处理器先从当前的目录去寻找头文件，如果没有找到就是用尖括号同样的方式去寻找。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>C/C++语言是强类型语言，变量需要先定义再使用，下面是C语言的一些数据类型。</p>
<p>数据类型</p>
<p>基本数据类型：int、float 、double、char</p>
<p>构造数据类型：struct、union、enum</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>unsigned char</td>
<td>1</td>
<td>0 ~ 2^8 - 1</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>- 2^7 ~ 2^7 -1</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2</td>
<td>0 ~ 2^16 -1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-2^15 ~ 2^15 -1</td>
</tr>
<tr>
<td>unsigned int</td>
<td>4</td>
<td>0 ~ 2^32 - 1</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>- 2^31 ~ 2^31 -1</td>
</tr>
<tr>
<td>unsigned long</td>
<td>8</td>
<td>0 ~ 2^64 - 1</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>- 2^63 ~ 2^63 - 1</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>-3.4 *10^38～+3.4 *10^38 (有效数字 6 -7)</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>-1.7 *10^-308~1.7 *10^308(有效数字 15 -16)</td>
</tr>
<tr>
<td>long double</td>
<td>12</td>
<td>-1.2 *10^-4932~1.2 *10^4932(有效数字 18 -19)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>说  明</th>
<th>字符型</th>
<th>短整型</th>
<th>整型</th>
<th>长整型</th>
<th>单精度浮点型</th>
<th>双精度浮点型</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>char</td>
<td>short</td>
<td>int</td>
<td>long</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>长  度</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h4 id="小数在内存中怎么存储的"><a href="#小数在内存中怎么存储的" class="headerlink" title="小数在内存中怎么存储的"></a>小数在内存中怎么存储的</h4><p>小数是用float、double类型的存放小数的。</p>
<p>定点数</p>
<p>假设我们用4个字节（32位）来存储无符号的定点数，并且约定，前16位表示整数部分，后16位表示小数部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1134205554-0.png" alt="img"></p>
<p>整数部分始终占用16位（不足16位前置补0），小数部分也始终占用16位（不足16位后置补0）。例如，在内存中存储了 10101111  00110001  01011100  11000011，那么对应的小数就是 10101111 00110001 <strong>.</strong> 01011100 11000011，非常直观。 </p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数据类型 + 变量名 = 定义变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line"><span class="keyword">float</span> c;</span><br></pre></td></tr></table></figure>

<h3 id="声明和定义的区别？"><a href="#声明和定义的区别？" class="headerlink" title="声明和定义的区别？"></a>声明和定义的区别？</h3><p>在学习C语言时，经常会被提及变量声明和定义的区别。</p>
<p>定义包含变量的声明，在编译原理上来说，声明是仅仅告诉编译器，有个变量在别的地方会被定义，但是这个编译器不会给它分配任何内存，定义就是分配内存。</p>
<blockquote>
<p>声明可以有多个，定义只能有一个。</p>
</blockquote>
<p>在我们C语言编程中，定义变量就不必说，声明变量往往不知道在哪使用。</p>
<p>a.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">//定义一个变量</span></span><br></pre></td></tr></table></figure>

<p>a.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a; <span class="comment">//告诉编译器a是定义在其他文件中的，在这里进行声明而已</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"a = %d"</span>,a)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用typedef为变量定义别名"><a href="#使用typedef为变量定义别名" class="headerlink" title="使用typedef为变量定义别名"></a>使用typedef为变量定义别名</h3><blockquote>
<p>typedef表示“类型定义”，但使用别名来描述可能更精确</p>
</blockquote>
<p>作用：</p>
<ol>
<li>对于复杂的类型，我们可以使用typedef来少敲几个键</li>
<li>有些类型名在不同平台上可能不同，可以使用typedef将需要使用类型名定义别名。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 原类型名 别名</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Int4</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Int4 a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="keyword">typeid</span>(a).name()  &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output: int</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*callback)</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>变量定义，不赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a; <span class="comment">//定义一个整型变量，不赋值</span></span><br><span class="line"><span class="keyword">int</span> a,b; <span class="comment">//定义两个整型变量，不赋值</span></span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//给变量赋值</span></span><br><span class="line">b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>变量定义，并且赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;b = <span class="number">4</span>; <span class="comment">//同时定义两个int变量</span></span><br></pre></td></tr></table></figure>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符以<code>\</code>或者<code>\x</code>开头，以<code>\</code>开头表示后跟<strong>八进制</strong>形式的编码值，以<code>\x</code>开头表示后跟<strong>十六进制</strong>形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">65</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,a); <span class="comment">//十进制</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\101"</span>); <span class="comment">//八进制</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\x41"</span>); <span class="comment">//十六进制</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\x68\164\164\x70://c.biancheng.\x6e\145\x74"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">http:<span class="comment">//c.biancheng.net</span></span><br></pre></td></tr></table></figure>





<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h5 id="输出字符串的拼接"><a href="#输出字符串的拼接" class="headerlink" title="输出字符串的拼接"></a>输出字符串的拼接</h5><p>如果两个加引号第字符数组邻接，并且他们之间没有标点，编译器会将两个字符串，合并成一个字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"111"</span></span><br><span class="line">		<span class="string">"222"</span></span><br><span class="line">		<span class="string">"333"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p>将一些其他数据类型组合成新的数据类型,称为结构体。</p>
<p>结构体使用</p>
<p><strong>方式一</strong>：先创建一个结构体，在定义变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个结构体，</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];	<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;	<span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;	<span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体变量，student就是标识符</span></span><br><span class="line">person stu1; <span class="comment">//现在大多数编译器支持这种方式进行定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">stu2</span>;</span></span><br><span class="line"><span class="comment">//上面这两种方式一样的</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二</strong>：创建结构体的同时定义变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];	<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;	<span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;	<span class="comment">//身高</span></span><br><span class="line">&#125; stu1,stu2;</span><br></pre></td></tr></table></figure>

<p><strong>方式三</strong>：创建结构体的同时定义变量，但是忽略标识符。</p>
<p>由于结构体没有标识符，说明这个结构体<code>只能</code>在创建结构体同时创建变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];	<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;	<span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;	<span class="comment">//身高</span></span><br><span class="line">&#125; stu1,stu2;</span><br></pre></td></tr></table></figure>

<p><strong>方式四</strong>：使用typedef将结构体取别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];	<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;	<span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;	<span class="comment">//身高</span></span><br><span class="line">&#125;STUDENGT;</span><br><span class="line"></span><br><span class="line">STUDENGT stu1;</span><br></pre></td></tr></table></figure>

<h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>在结构体中，不同的成员在结构体中都具有单独的内存位置，共用体成员则共有一个内存位置，也就是说，所有成员都是从相同的内存地址开始，同一个时刻只能有一个成员允许含有一个值，称为共用体或者联合体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从结构上来看，共用体和结构体是一样的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个类型可以存储一个整数、一个浮点数、字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">union</span> Data var,myData[<span class="number">100</span>]; <span class="comment">//定义一个共用体变量和变量数组。</span></span><br><span class="line"></span><br><span class="line">var.i = <span class="number">10</span>;</span><br><span class="line">var.x = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(var.str,<span class="string">"yuandongbin"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><p>枚举</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> week &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Sun &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Mon &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Tue &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//100</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Wed &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//101</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Thu &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//102</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Fri &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//103</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Sat &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//104</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在编译器中，默认会将第一个枚举量赋值0，下一给位1，依次往下加1</span></span><br><span class="line">    <span class="comment">//每个枚举值的枚举量不能重复定义</span></span><br><span class="line">    <span class="comment">//不定义变量直接使用枚举值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> week &#123; Sun, Mon, Tue = <span class="number">100</span>, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Sun &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Mon &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Tue &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Wed &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Thu &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Fri &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//5</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Sat &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//6</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在编译器中，默认会将第一个枚举量赋值0，下一给位1，依次往下加1,如果为其中一枚举量赋值，之后的枚举量的在赋值的枚举量上依次加1。</span></span><br><span class="line">    <span class="comment">//不定义变量直接使用枚举值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="struct、union-、enum的大小"><a href="#struct、union-、enum的大小" class="headerlink" title="struct、union 、enum的大小"></a>struct、union 、enum的大小</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">设置字节对齐</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)  <span class="comment">//设置4字节对齐 等价于#pragma pack(push,2)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()   <span class="comment">//取消自定义字节对齐方式  等价于#pragma pack(pop)</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4字节对齐</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a       <span class="comment">//1 + 3 不够4字节，补齐到4字节</span></span><br><span class="line">    <span class="keyword">int</span> b;       <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">long</span> c;      <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">10</span>];    <span class="comment">//40</span></span><br><span class="line">&#125;e;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment">sizeof(e)输出:52</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;       <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">long</span> b;      <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">10</span>];    <span class="comment">//40</span></span><br><span class="line">&#125;e;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment">sizeof(e)输出:40</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">&#125;d;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment">sizeof(d)输出:4</span></span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h3><ul>
<li><p>存储中的每个字节拥有唯一的内存</p>
</li>
<li><p>字节是最小第可寻址内存单元</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1129246-20190901103222306-961055256-1581940910717.png" alt="img"></p>
<p> 栈区（stack）： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。  </p>
<p> 堆区（heap） ： 一般由程序员分配释放， 若程序员不释放，在程序结束时，操作系统回收。 </p>
<p> BSS段（Block Started by Symbol）：.bss段被用来存放那些没有初始化或者初始化为0的全局变量。bss段只占运行时的内存空间而不占文件空间。在程序运行的整个周期内，.bss段的数据一直存在 。</p>
<p> 全局区（静态区）：全局变量和静态变量的存储是放在一块的， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 在程序序结束后由系统释放。  </p>
<p> DATA区（初始化的数据段）：为数据分配空间，数据保存在目标文件中 </p>
<p> 文字（只读）常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放  </p>
<p> 代码段（TXT）：存放函数体的二进制代码 </p>
<h3 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在所有函数体之外定义的变量，与程序的生命周期一样。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>函数体内定义的变量，离开函数体之外就无效。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>每个大括号就是一个作用域，在大括号内定义的变量，只能在括号内使用，离开大括号就是失效了，多层括号嵌套时，作用域时自上到下作用的，上层定义变量下层的作用域内都可以使用，反正不行，多层括号包含内层。</p>
<p>在if和for的代码块中定义的变量，变量的生命周期只有在if和for的范围中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if的生命周期</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt; a &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//编译报错，变量未定义</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的修饰"><a href="#变量的修饰" class="headerlink" title="变量的修饰"></a>变量的修饰</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>有时候我们想要局部变量的生命周期和整个程序一样，可以使用static进行修饰。</p>
<p>从这个解释来看不是和全局变量一样了吗，那我们为什么不用全局变量？</p>
<p>1. static修饰局部变量的生命周期虽然变长了，但是作用域还是没有变，不能在作用域之外使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    total = total + x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"func::total= "</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    total = total + x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"func1::total= "</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func(<span class="number">1</span>);</span><br><span class="line">    func(<span class="number">1</span>);	</span><br><span class="line">    func1(<span class="number">1</span>);</span><br><span class="line">    func1(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func::total= 1</span></span><br><span class="line"><span class="comment">func::total= 1  局部变量在离开作用域就自动释放了,每次调用函数时变量定义---变量释放</span></span><br><span class="line"><span class="comment">func1::total= 1</span></span><br><span class="line"><span class="comment">func1::total= 2	被static修饰的局部变量生命周期和程序一样，第一次调用函数时定义变量后，再调用函数时不会重新定义变量了，因为之前定义的变量没有被释放，但是只能在定义的作用域中使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>2. static如果修饰全局变量，那这个全局变量的作用域是整个文件，离开文件不能被外部的文件进行调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_COMMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TEST_COMMON_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"全局变量a = "</span>  &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt;"全局变量a = "  &lt;&lt; a &lt;&lt; std::endl;</span></span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在main函数中调用在common中static修饰的全局变量会<code>编译失败</code>，但是在变量定义所在的文件中是可以使用的。</p>
<p>3. static修饰类成员变量，由于成员变量的生命周期和整个程序一样，多个实例共用一个成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    myclass(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> myclass::b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">myclass <span class="title">x</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">myclass <span class="title">y</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"x.b = "</span> &lt;&lt; x.b &lt;&lt; <span class="string">" 地址为："</span> &lt;&lt; (<span class="keyword">long</span>)(&amp;(x.b)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"y.b = "</span> &lt;&lt; y.b &lt;&lt; <span class="string">" 地址为："</span> &lt;&lt; (<span class="keyword">long</span>)(&amp;(y.b)) &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x.b = 1 地址为：4450234600</span></span><br><span class="line"><span class="comment">y.b = 1 地址为：4450234600</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>4. static修饰成员函数，只能操作static修饰静态成员变量，其他的成员变量不能操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    myclass(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//编译失败</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>被const修饰的变量不能被修改。</p>
<p>(1) 定义const变量</p>
<blockquote>
<p>定义时必须初始化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* b = <span class="string">"xxx"</span>;</span><br></pre></td></tr></table></figure>

<p>(2) const常量和#define宏定义常量的区别</p>
<p>const常量具有类型，编译器可以进行安全检查，#define只是简单的字符串的替换，不能进行安全检查</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a 10</span></span><br></pre></td></tr></table></figure>

<p>(3) const修饰函数入参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>;  <span class="comment">//函数参数不会被修改</span></span><br></pre></td></tr></table></figure>

<p>(4) const修饰的全局变量</p>
<blockquote>
<p>非const修饰的变量默认为extern，要使const变量能够在其他文件中访问，必须在文件中显示地指定它为extern</p>
</blockquote>
<p>a.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>(5) const 修饰指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p; <span class="comment">// const修饰*p，即修饰p指向的内存不能修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p; <span class="comment">// const修饰p，即修饰的指针变量p不能修改</span></span><br></pre></td></tr></table></figure>

<p>(6) const 修改类成员变量</p>
<p>被const修饰的变量只能，定义时初始化，const修饰的成员变量，也是同样的不能通过构造函数赋值，只能通过<code>列表初始化</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo(<span class="keyword">int</span> a,<span class="keyword">int</span> b): b(b) <span class="comment">//成员变量b只能这样赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">A</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>const修饰类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 常指针，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 常指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>



<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><blockquote>
<p>告诉编译器不知道在何时会改变，请编译器不需要因为优化而省略，且要求每次直接读取。</p>
</blockquote>
<p> 精确地说就是，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在<a href="https://baike.baidu.com/item/寄存器" target="_blank" rel="noopener">寄存器</a>里的备份。 </p>
<h3 id="运算符和数据转换"><a href="#运算符和数据转换" class="headerlink" title="运算符和数据转换"></a>运算符和数据转换</h3><h4 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h4><p>包括：加（+）、减（-）、乘（*）、除（/）和取模（%）</p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>包括：小于（&lt;）、小于等于（&lt;=）、大于（&gt;）、大于等于（&gt;=）、等于（==）、不等于（!=）</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>包括：与（&amp;&amp;）、或（||）和非（!）</p>
<h4 id="移位位运算符"><a href="#移位位运算符" class="headerlink" title="移位位运算符"></a>移位位运算符</h4><p>对位进行操作，位左移(&lt;&lt;)和右移(&gt;&gt;)</p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>++、–、&amp;、*、-&gt; 这些对一个变量进行操作的</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a &gt; b ? a:b</span><br></pre></td></tr></table></figure>

<p>一个if-else的简写，可以看做一个语法糖。</p>
<h4 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h4><p>sizeof单独作为一个运算符，它给我们提供有关数据项目所分配的内存大小。</p>
<p>数据多输入和输出</p>
<ul>
<li>用putchar函数输出一个字符</li>
<li>用getchar函数输入一个字符</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/wm.jpeg" alt="wm"></p>
<p>数据位数越长，优先级越高，因为位数长可以表示位数小，反之需要丢失精度。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>C语言中使用<strong>#define</strong>定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br></pre></td></tr></table></figure>

<p>C++中使用const进行定义常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>条件控制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>condition为布尔值，为真才可以执行do something</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//do something1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//do something2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>condition为真，执行do something1,否则执行do something2</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>哪个condition为真，就执行哪个大括号代码，else内容是兜底。</li>
</ul>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a) ｛</span><br><span class="line">	<span class="keyword">case</span> b : to <span class="keyword">do</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> c : to <span class="keyword">do</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> d : to <span class="keyword">do</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> e : to <span class="keyword">do</span>; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">do</span> something</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>传入a匹配上<code>b</code> <code>c</code> <code>d</code> <code>e</code>其中一个，就执行后面代码，再执行break，之后的代码不会执行了。</p>
<p>如果没有break，匹配上那个case之后所有代码都会被执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (a)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; <span class="string">"case 0"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"case 1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"case 2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"case 3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">case 1</span></span><br><span class="line"><span class="comment">case 2</span></span><br><span class="line"><span class="comment">case 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面这种场景a = 0或者1，都输出”case 1”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (a)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"case 1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"case 2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"case 3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(init; condition; increment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>init，循环之前的操作</li>
<li>condition，条件表达式</li>
<li>increment，每次循环之后执行</li>
</ul>
<h4 id="for的无限循环"><a href="#for的无限循环" class="headerlink" title="for的无限循环"></a>for的无限循环</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while的无限循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure>

<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>for、while、do…while之间可以相互嵌套。</p>
<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>终止本次循环，continue之后的内容不会执行,继续执行下次循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i&lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0 2 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>终止这层循环，之后循环不会执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i&lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure>

<p>代码执行到goto，会自动跳转到label继续执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i&lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(a[i] == <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">goto</span> A; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A：</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p> 函数就是一段可以重复使用的代码 </p>
</blockquote>
<p><strong>函数定义</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line">返回值 函数名(函数参数)</span><br></pre></td></tr></table></figure>

<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><p>函数被static修饰，只能在当前源文件中使用。</p>
<h3 id="可变的参数列表"><a href="#可变的参数列表" class="headerlink" title="可变的参数列表"></a>可变的参数列表</h3><p>使用可变参数作为列表，需要提供函数<strong>参数个数</strong></p>
<p>使用步骤：</p>
<ul>
<li>va_list vaList;    定义指向参数指针</li>
<li>va_start(vaList,<strong>函数第一个参数</strong>);   初始化指针，使指针指向第一个可变参数的地址  </li>
<li>va_arg(vaList,<strong>可变参数类型</strong>)    返回可变参数的值，使指针指向下个可变参参数</li>
<li>va_end(vaList);  清空va_list可变参数列表</li>
</ul>
<p>可变参数函数要获取可变参数，必须通过一个va_list类型(有被称为<code>参数指针</code>)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;	<span class="comment">//定义一个参数指针</span></span><br><span class="line"></span><br><span class="line">    va_start(vaList,num);    <span class="comment">//获取第一个参数，第一个参数的值，确定后面参数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; va_arg(vaList,<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//这里把vaList往后跳过4个字节（sizeof(int)大小）指向下一个参数，返回的是当前参数（而非下</span></span><br><span class="line">一个参数）  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(vaList); <span class="comment">//当不再需要使用参数指针时，必须调用宏 va_end。如果想使用宏 va_start 或者宏 va_copy 来重新初始化一个之前用过的参数指针，也必须先调用宏 va_end。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func(<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="应用：printf函数实现"><a href="#应用：printf函数实现" class="headerlink" title="应用：printf函数实现"></a>应用：printf函数实现</h3><p>例如，printf就是明显地可变的参数函数，我们下面实现下printf函数的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_y</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line"></span><br><span class="line">    va_start(vaList,s);    <span class="comment">//获取第一个参数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vect_type;</span><br><span class="line">    <span class="comment">//获取字符串可变参数的类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vect_type.push_back(s[++i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; vect_type.<span class="built_in">size</span>(); ++l) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (vect_type[l])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; va_arg(vaList, <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; va_arg(vaList, <span class="keyword">char</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printf_y(<span class="string">"%d %s"</span>,<span class="number">1</span>,<span class="string">"yuandongbin"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> (*pFun)(<span class="keyword">int</span>); <span class="comment">//定义一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">glFun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFun = glFun; <span class="comment">//想要给函数指针赋值，需要函数原型和函数指针原型一直（函数参数和返回值）</span></span><br><span class="line">    <span class="keyword">int</span> i = (*pFun)(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*callback)</span><span class="params">(<span class="keyword">int</span> x)</span></span>;            <span class="comment">// 定义一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc1</span><span class="params">(<span class="keyword">int</span> x)</span>                         <span class="comment">// myFunc1 的声明要与callback一样</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is myFunc1 "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is myFunc2 "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callMyFunc</span><span class="params">(callback cb, <span class="keyword">int</span> x)</span>　　　　　 <span class="comment">// 把函数指针类型当做调用函数参数类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cb(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    callMyFunc(myFunc1, <span class="number">1</span>);</span><br><span class="line">    callMyFunc(myFunc2, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>C++允许在同一范围内声明几个功能类似的同名函数，但这些函数的形式参数（参数个数、类型和顺序）必须不同。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>(1) 定义指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p;</span><br></pre></td></tr></table></figure>

<p>(2) 使用指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*p = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>





<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p>可以看作一个被const修饰的指针，只能修改变量的指针，是一个语法糖。</p>
</blockquote>
<h2 id="转换运算符"><a href="#转换运算符" class="headerlink" title="转换运算符"></a>转换运算符</h2><p>用于明确的定义的变换，例如：把int提升到long或float不会有问题，因为后者总是能容纳一个int所包含的值。</p>
<p>如果将long或float转换成int，这里可能会丢失数据，因为一个int和long或float不是一样的“宽”的，它不能容纳同样大小的数字。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><blockquote>
<p>相当于同族之间的转换</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(i).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    f = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">    l = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(l).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(f).name() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用static_cast获取变量的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(&amp;i) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 0x7fffc33a7748</span></span><br></pre></td></tr></table></figure>



<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><blockquote>
<p>解开权限</p>
</blockquote>
<p>如果从const转换为非const或volatile转换为非volatile，可以使用const_cast。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* j = (<span class="keyword">int</span>*)&amp;i;</span><br><span class="line">	j = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;i);</span><br><span class="line">	*j = <span class="number">1</span>; <span class="comment">//通过指针可以修改内容</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(j).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><blockquote>
<p>无视种族隔离，使不同种族的转换，随意在不同类型之间使用，会导致程序的破坏。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    A(<span class="keyword">int</span> n):i(n),j(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a</span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.i &lt;&lt; <span class="string">","</span> &lt;&lt; a.j &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt; ( &amp; n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> u = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; u &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="keyword">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><blockquote>
<p>父类指针或者引用向派生类的指针或引用转换，而且能够检查转换的安全性。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived* pd;</span><br><span class="line">    pd = <span class="keyword">reinterpret_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsafe reinterpret_cast"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsafe dynamic_cast1"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;d);  <span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//此处 pd 不会为 NULL</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsafe dynamic_cast2"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h3><p>将字符串转换为int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> szInput[<span class="number">256</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a number: "</span>);</span><br><span class="line">	fgets(szInput, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	i = atoi(szInput);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The value entered is %d. The double is %d.\n"</span>, i, i * <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="atol"><a href="#atol" class="headerlink" title="atol"></a>atol</h3><p>将字符串转换为long</p>
<h3 id="atof"><a href="#atof" class="headerlink" title="atof"></a>atof</h3><p>将字符串转换为float</p>
<h3 id="itoa"><a href="#itoa" class="headerlink" title="itoa"></a>itoa</h3><p>将int转换为字符串</p>
<h3 id="ftoa"><a href="#ftoa" class="headerlink" title="ftoa"></a>ftoa</h3><p>将float转换为字符串</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>什么是对象？</strong></p>
<p>在C中，struct是数据的凝聚，它将数据捆绑在一起，使得各种数据成为一个整体，它的存在可以使得编程更加方便，没有其他作用，我们可以其他地方编写函数进行操作这些结构，然而将函数放进struct中，结构就变成新的概念（就是class），它既能描述属性，又能描述行为，这就形成了对象的概念，<strong>可以把数据比作肉体，函数就是灵魂。</strong></p>
<p>如何建立对象</p>
<ul>
<li>类的名字：名字需要体现类行为的本质</li>
<li>类的职责：这个类应该做什么</li>
<li>类的协同：它和其他类如何交互</li>
</ul>
<p>注意：class的成员默认为private，struct默认为public，其他方面都是一样的。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote>
<p>将数据连同函数捆绑在一起的能力可以用于创建新的数据类型，常常又被称为封装。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="隐藏实现"><a href="#隐藏实现" class="headerlink" title="隐藏实现"></a>隐藏实现</h4><p>public: 所有的人都可以访问</p>
<p>protect: 类的创建者和类的内部成员、派生类可以访问</p>
<p>private: 类的创建者和类的内部成员</p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><blockquote>
<p>友元打破类的权限设定。</p>
</blockquote>
<p> 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">double</span> length;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用要点</p>
<ul>
<li>要访问非static成员时，需要对象做参数； </li>
<li>要访问static成员或全局变量时，则不需要对象做参数； </li>
<li>如果做参数的对象是全局对象，则不需要对象做参数， 可以直接调用友元函数，不需要通过对象或指针 。</li>
</ul>
<h4 id="初始化与清除"><a href="#初始化与清除" class="headerlink" title="初始化与清除"></a>初始化与清除</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><blockquote>
<p>类的初始化是通过一个和类同名的函数完成的</p>
</blockquote>
<p>当一个对被创建时，首先是先执行构造函数。</p>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>当这个对象被释放会先执行析构函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	myclass()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~myclass()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyClass(<span class="keyword">int</span> a1,<span class="keyword">int</span> b1,<span class="keyword">int</span> c1):c(c1)  <span class="comment">//这里使用列表初始化和构造函数体内初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	~MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyClass <span class="title">A</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过调试发现，在调用构造函数时，会优先使用列表初始化，之后才会走进函数体内执行。</p>
<p>初始化列表速度上比赋值要快。</p>
<p>空类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空类的大小有<strong>1个字节</strong>，是用来表示这是一个对象</p>
<p><strong>非空类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的大小计算方式和struct一样，除了有虚函数时，需要多一个指针的大小。</p>
<h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 </p>
<p>(1) this指针的使用</p>
<ul>
<li>return *this,当成员函数需要返回类对象本身时。</li>
<li>当参数与成员函数变量名相同时，使用this-&gt;a = a</li>
</ul>
<p>(2) this指针被编译器解析成A * const this,即这个指针不能修改指针变量。</p>
<h5 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h5><p> <a href="https://blog.csdn.net/li1914309758/article/details/79916414" target="_blank" rel="noopener">https://blog.csdn.net/li1914309758/article/details/79916414</a> </p>
<h4 id="对象继承和组合"><a href="#对象继承和组合" class="headerlink" title="对象继承和组合"></a>对象继承和组合</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>当创建一个类时，你不需要重新编写新的数据成员和成员函数，可以通过继承一个已有的类的成员，我们成被继承的类为基类，新建的类称为派生类。</p>
<ul>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">width</span> = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>类中成员是另一个类的对象</p>
<p>可以在已有抽象的基础上实现更复杂的抽象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//Point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Point(<span class="keyword">double</span> x,<span class="keyword">double</span> y):x(x),y(y)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	Point(<span class="keyword">const</span> Point &amp;p)<span class="comment">//Copy constructor </span></span><br><span class="line">	&#123;</span><br><span class="line">		x=p.x;</span><br><span class="line">		y=p.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Line</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> length;</span><br><span class="line">	Point a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Line(Point a,Point b):a(a),b(b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> x=a.getX()-b.getX();</span><br><span class="line">		<span class="keyword">double</span> y=a.getY()-b.getY();</span><br><span class="line">		length=<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">()</span><span class="comment">//get the length of line</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point <span class="title">getA</span><span class="params">()</span><span class="comment">//get a point</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point <span class="title">getB</span><span class="params">()</span><span class="comment">//get b point</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++仿函数</title>
    <url>/2020/05/17/C-%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><p>所谓的仿函数，使用过重载()运算符模拟函数行为的类型</p>
<ol>
<li>仿函数不是函数，是一个类</li>
<li>仿函数重载()运算符，使得代码形式好像调用函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">myclass</span><span class="params">(<span class="keyword">int</span> n)</span> : <span class="title">threshold</span><span class="params">(n)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function">myclass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程</title>
    <url>/2019/12/05/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1 线程"></a>1 线程</h2><h3 id="1-1-创建线程"><a href="#1-1-创建线程" class="headerlink" title="1.1 创建线程"></a>1.1 创建线程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *(*start_routine),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *arg)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一：创建线程后返回的线程id<br>参数二：线程参数<br>参数三：线程函数<br>参数四：指向传给线程函数的参数</p>
<p>返回值：0表示成功 非0表示失败</p>
</blockquote>
<h4 id="1-1-1-创建一个不传参的线程"><a href="#1-1-1-创建一个不传参的线程" class="headerlink" title="1.1.1 创建一个不传参的线程"></a>1.1.1 创建一个不传参的线程</h4><blockquote>
<p>主线程不等待子线程执行，主线程先退出，子线程没有机会执行。</p>
<p>下面的列子，如果没有sleep，子线程根本不会有机会执行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am child thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tidp,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"pthread create failed:"</span>&lt;&lt; ret &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//如果没有行代码 main线程会先执行结束，子线程没有机会执行，程序就结束了</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"in main:thread "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">I am child thread</span><br><span class="line">in main:thread</span><br></pre></td></tr></table></figure>



<h4 id="1-1-2-创建有参数的线程"><a href="#1-1-2-创建有参数的线程" class="headerlink" title="1.1.2 创建有参数的线程"></a>1.1.2 创建有参数的线程</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">&#125;MYSTRUCT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int型参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thfunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pn = (<span class="keyword">int</span>*)(arg);</span><br><span class="line">    <span class="keyword">int</span> n = *pn;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"线程1的参数："</span>&lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str型参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">strfunc</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * str = (<span class="keyword">char</span> *)(arg);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"线程2的参数："</span>&lt;&lt;str &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">structfunc</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MYSTRUCT * pMystruct = (MYSTRUCT*)(arg);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"线程3的参数："</span>&lt;&lt; <span class="string">"age= "</span>&lt;&lt;pMystruct-&gt;age &lt;&lt;<span class="string">" name= "</span>&lt;&lt;pMystruct-&gt;name&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> * str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"ABC"</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp1;</span><br><span class="line">    <span class="keyword">pthread_t</span> tidp2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tidp,<span class="literal">NULL</span>,thfunc,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"pthread_create failed:%d\n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tidp,<span class="literal">NULL</span>); <span class="comment">//等待线程结束</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * str = <span class="string">"yuandongbin"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret1 = pthread_create(&amp;tidp1,<span class="literal">NULL</span>,strfunc,(<span class="keyword">void</span> *)str);</span><br><span class="line">    <span class="keyword">if</span>(ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"pthread_create failed:%d\n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tidp1,<span class="literal">NULL</span>); <span class="comment">//等待线程结束</span></span><br><span class="line">    MYSTRUCT mystruct;</span><br><span class="line">    mystruct.age = <span class="number">26</span>;</span><br><span class="line">    mystruct.name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(mystruct.name,<span class="string">"yuandongbin"</span>);</span><br><span class="line">    <span class="keyword">int</span> ret2 = pthread_create(&amp;tidp2,<span class="literal">NULL</span>,structfunc,(<span class="keyword">void</span> *)&amp;mystruct);</span><br><span class="line">    <span class="keyword">if</span>(ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"pthread_create failed:%d\n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tidp2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span> *str1;</span><br><span class="line">    pthread_join(tidp2,&amp;str1);<span class="comment">//获取线程函数的返回值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"线程3返回值"</span>&lt;&lt;(<span class="keyword">char</span> *)str1&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印返回值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"主线程结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线程1的参数：1</span></span><br><span class="line"><span class="comment">线程2的参数：yuandongbin</span></span><br><span class="line"><span class="comment">线程3的参数：age= 26 name= yuandongbin</span></span><br><span class="line"><span class="comment">主线程结束</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-创建一个线程，共享线程数据"><a href="#1-1-3-创建一个线程，共享线程数据" class="headerlink" title="1.1.3 创建一个线程，共享线程数据"></a>1.1.3 创建一个线程，共享线程数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> gn = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gn++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"in func:gn= "</span>&lt;&lt;gn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tip,<span class="literal">NULL</span>,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create failed: "</span>&lt;&lt; ret &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(tip,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    gn++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"in main:gn= "</span>&lt;&lt;gn&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-等待线程结束"><a href="#1-2-等待线程结束" class="headerlink" title="1.2 等待线程结束"></a>1.2 等待线程结束</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来等待一个线程的结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> thread, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一：thread: 线程标识符，以阻塞的方式等待thread指定的线程结束。<br>参数二：retval: 用户定义的指针，用来存储被等待线程的返回值。</p>
<p>返回值： 0代表成功。 失败，返回的则是错误号。</p>
<p>作用：<br>1.用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。<br>2.对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”。</p>
</blockquote>
<h3 id="1-3-初始化线程属性"><a href="#1-3-初始化线程属性" class="headerlink" title="1.3 初始化线程属性"></a>1.3 初始化线程属性</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一：指向一个线程属性结构的指针，结构中的元素分别对应着新线程的运行属性。属性对象主要包括是否绑定、是否分离、堆栈地址和大小、优先级等。默认属性为非绑定、非分离、默认1MB堆栈、与父进程有相同优先级。</p>
<p>返回值： 0代表成功。 失败，返回的则是错误号。</p>
</blockquote>
<h3 id="1-4-设置线程参数"><a href="#1-4-设置线程参数" class="headerlink" title="1.4 设置线程参数"></a>1.4 设置线程参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr,<span class="keyword">int</span> detchstate)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一：指向一个线程属性结构的指针</p>
<p>参数二：设置分离状态值，可以取值PTHREAD_CREATE_DETACHED或者PTHREAD_CREATE_JOINABLE</p>
<p>返回值： 0代表成功。 失败，返回的则是错误号。</p>
</blockquote>
<h3 id="1-5-获取线程参数"><a href="#1-5-获取线程参数" class="headerlink" title="1.5 获取线程参数"></a>1.5 获取线程参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> * attr,<span class="keyword">int</span>&amp; detchstate)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数一：指向一个线程属性结构的指针</p>
<p>参数二：</p>
</blockquote>
<h3 id="1-6-分离线程"><a href="#1-6-分离线程" class="headerlink" title="1.6  分离线程"></a>1.6  分离线程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> thread  <span class="comment">//thread to detach</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>可分离线程:</strong></p>
<p>POSIX下的线程要么是分离的，要么是非分离状态的，<code>默认创建的线程是可连接的</code>，一个可结合的线程是可以被其他线程来回收其资源，并且不会主动释放资源，必须等待其他线程收回其资源，因此我们可以使用pthread_join()函数，这个函数是一个阻塞函数，当它返回时，所等待的线程的资源也就被释放了。</p>
<p>如果父进程不退出并且你没有调用pthread_join(),所以这些可连接的线程资源一直得不到释放，子进程变成僵尸进程，僵尸进程越来越多，以后再想要创建线程就没有资源可用了。</p>
<p>如果不用pthread_join()，并且父进程先于可连接的子线程退出，那么会不会泄露资源呢？答案是不会的，如果父进程先于子进程退出，子进程就会被init进程所收养，这个时候init进程就是它的父进程，将调用wait系列函数为其回收资源。</p>
<p>一个线程不能被多个线程等待，否则第一个接受到信号的线程成功返回，其余调用pthread_join的线程将得到错误ESRCH。</p>
<h4 id="1-6-1-创建一个可分离线程"><a href="#1-6-1-创建一个可分离线程" class="headerlink" title="1.6.1 创建一个可分离线程"></a>1.6.1 创建一个可分离线程</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">func</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sub thread is running"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程属性 在pthread_create的第二个参数</span></span><br><span class="line">   	<span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line">    <span class="keyword">size_t</span> stack_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化线程属性</span></span><br><span class="line">    <span class="keyword">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line">    <span class="keyword">if</span>(res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_attr init failed:"</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置线程属性 分离状态是PTHREAD_CREATE_DETACHED</span></span><br><span class="line">    res = pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span>(res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_attr_setdetachstate failed"</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    res = pthread_create(&amp;thread_id,&amp;thread_attr,func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(res)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create failed:"</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//调用这个函数，主线程退出，但是进程不会此刻退出，下面的语句不会在执行了</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main thread will exit\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; <span class="number">50</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化线程属性</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_attr_init(&amp;thread_attr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_attr init failed:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置线程属性 分离状态是PTHREAD_CREATE_DETACHED</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_DETACHED))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_attr_setdetachstate failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,&amp;thread_attr,func,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create failed:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);<span class="comment">//调用这个函数，主线程退出，但是进程不会此刻退出，下面的语句不会在执行了</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main thread will exit\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-将可连接的线程转换为分离线程"><a href="#1-6-2-将可连接的线程转换为分离线程" class="headerlink" title="1.6.2 将可连接的线程转换为分离线程"></a>1.6.2 将可连接的线程转换为分离线程</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am yuandongbin"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;tid,&amp;thread_attr,func,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_create failed:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span>(pthread_detach(tid))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread_detach faileds"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pthread_exit(NULL);//调用这个函数，主线程退出，但是进程不会此刻退出，下面的语句不会在执行了</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main thread will exit\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-7-线程主动结束"><a href="#1-7-线程主动结束" class="headerlink" title="1.7  线程主动结束"></a>1.7  线程主动结束</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> * retval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前线程中调用</span></span><br></pre></td></tr></table></figure>



<h3 id="1-8-线程被动结束"><a href="#1-8-线程被动结束" class="headerlink" title="1.8 线程被动结束"></a>1.8 线程被动结束</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> threadid,<span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//其他线程中调用</span></span></span><br></pre></td></tr></table></figure>



<h4 id="1-8-1-判断线程是否已经结束"><a href="#1-8-1-判断线程是否已经结束" class="headerlink" title="1.8.1 判断线程是否已经结束"></a>1.8.1 判断线程是否已经结束</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> kill_rc = pthread_kill(tid,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(kill_rc == ESRCH)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the specified thread did not exists or already quit\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(kill_re == EINVAL)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"signal is invaild\n"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the specified thread is alive\n"</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1-9-线程清理函数"><a href="#1-9-线程清理函数" class="headerlink" title="1.9 线程清理函数"></a>1.9 线程清理函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *),<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数一：清理函数</span></span><br><span class="line"><span class="comment">参数二：清理函数参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数一：非0表示将清理函数弹出栈顶同时执行清理函数，0表示弹出栈顶不清理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个函数是成对出现，不能单独使用。</span></span><br></pre></td></tr></table></figure>



<h2 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2 线程同步"></a>2 线程同步</h2><h3 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1 互斥锁"></a>2.1 互斥锁</h3><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于，公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。</p>
<p>在线程里也有这么一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。</p>
<ul>
<li>定义锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock;</span><br></pre></td></tr></table></figure>



<ul>
<li>初始化锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, </span></span></span><br><span class="line"><span class="function"><span class="params">					   <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>加锁解锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁上锁，若互斥锁已经上锁，则调用者一直阻塞，</span></span><br><span class="line"><span class="comment">// 直到互斥锁解锁后再上锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该函数时，若互斥锁未加锁，则上锁，返回 0；</span></span><br><span class="line"><span class="comment">// 若互斥锁已加锁，则函数直接返回失败，即 EBUSY。(非阻塞)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当线程试图获取一个已加锁的互斥量时，pthread_mutex_timedlock 互斥量</span></span><br><span class="line"><span class="comment">// 原语允许绑定线程阻塞时间。即非阻塞加锁互斥量。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指定的互斥锁解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>





<h3 id="2-2-读写锁"><a href="#2-2-读写锁" class="headerlink" title="2.2 读写锁"></a>2.2 读写锁</h3><p>读写锁与互斥量类似，不过读写锁允许更改的并行性，<strong>也叫共享互斥锁</strong>。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：<strong>读模式下加锁状态、写模式加锁状态、不加锁状态</strong>。</p>
<p><strong>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁（允许多个线程读但只允许一个线程写）</strong>。</p>
<p>【读写锁的特点】：</p>
<ul>
<li><p>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作；</p>
</li>
<li><p>如果有其它线程写数据，则其它线程都不允许读、写操作。</p>
</li>
</ul>
<p>【读写锁的规则】：</p>
<ul>
<li><p>如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁；</p>
</li>
<li><p>如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试以非阻塞的方式来在读写锁上获取写锁，</span></span><br><span class="line"><span class="comment">// 如果有任何的读者或写者持有该锁，则立即失败返回。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>





<h3 id="2-3-条件变量"><a href="#2-3-条件变量" class="headerlink" title="2.3 条件变量"></a>2.3 条件变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,</span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,pthread_mutex *mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">const</span> timespec *abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除所有线程的阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至少唤醒一个等待该条件的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待该条件的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-信号量"><a href="#2-4-信号量" class="headerlink" title="2.4 信号量"></a>2.4 信号量</h3><p>信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。</p>
<p>编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于 0 时，则可以访问，否则将阻塞。PV 原语是对信号量的操作，一次 P 操作使信号量减１，一次 V 操作使信号量加１。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量 P 操作（减 1）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以非阻塞的方式来对信号量进行减 1 操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量 V 操作（加 1）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取信号量的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> *sval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>





<h2 id="C-11-thread线程库"><a href="#C-11-thread线程库" class="headerlink" title="C++11 thread线程库"></a>C++11 thread线程库</h2><blockquote>
<p>C++11 thread线程库就是在posix线程库基础上进行了封装</p>
</blockquote>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"无参线程函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"有参线程函数"</span></span><br><span class="line">         &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func1, <span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建线程，线程函数为类成员函数"><a href="#创建线程，线程函数为类成员函数" class="headerlink" title="创建线程，线程函数为类成员函数"></a>创建线程，线程函数为类成员函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"类的成员函数作为线程函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;A::func, &amp;a)</span></span>;	<span class="comment">//第一个参数参数线程函数的地址，第二个参数传入类的实例</span></span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取线程id"><a href="#获取线程id" class="headerlink" title="获取线程id"></a>获取线程id</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"在线程函数获取"</span></span><br><span class="line">         &lt;&lt; <span class="string">"线程id为: "</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(fun)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"在主线程中获取t1线程的id为："</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的所有权拷贝"><a href="#线程的所有权拷贝" class="headerlink" title="线程的所有权拷贝"></a>线程的所有权拷贝</h3><blockquote>
<p>有thread类的拷贝构造函数被禁用，想要拷贝thread对象，可用通过std::move</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"无参线程函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"有参线程函数"</span></span><br><span class="line">         &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span></span><br><span class="line">         &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func1, <span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    thread t1_bak = <span class="built_in">move</span>(t1); <span class="comment">//这里将t1线程的所有权移交给t1_bak,原先t1不可用了</span></span><br><span class="line">    <span class="comment">//t1.join();	//不可以用</span></span><br><span class="line">    t1_bak.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="join和detaching"><a href="#join和detaching" class="headerlink" title="join和detaching"></a>join和detaching</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"加入式线程，主线程需要等待我"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"分离式线程，主线程不需要等待我"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"分离式线程自行结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func1)</span></span>;</span><br><span class="line">    t1.join();	<span class="comment">//主线程会阻塞，等待t1线程的执行结束</span></span><br><span class="line">    t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">15</span>);  <span class="comment">//不能让进程结束，不然分离式的线程也会结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步，mutex锁使用"><a href="#线程同步，mutex锁使用" class="headerlink" title="线程同步，mutex锁使用"></a>线程同步，mutex锁使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//票的总数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> ticketNum = <span class="number">100</span>;	<span class="comment">//线程共享资源</span></span><br><span class="line">mutex mtxlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sellTicketTask</span><span class="params">(<span class="built_in">string</span> windowName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ticketNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mtxlock.lock();	<span class="comment">//每个线程访问需要加锁</span></span><br><span class="line">        <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; windowName &lt;&lt; <span class="string">"买出第"</span> &lt;&lt; ticketNum &lt;&lt; <span class="string">"票"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">            ticketNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        mtxlock.unlock();</span><br><span class="line">        this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));	<span class="comment">//标准库提供的线程睡眠函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(sellTicketTask, <span class="string">"1号窗口"</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(sellTicketTask, <span class="string">"2号窗口"</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(sellTicketTask, <span class="string">"3号窗口"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>头文件: <code>#include &lt;condition_variable&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">ready</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等待直至 main() 发送数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">//加锁</span></span><br><span class="line">    cv.wait(lk, []&#123;<span class="keyword">return</span> <span class="built_in">ready</span>;&#125;); <span class="comment">//第二个参数为false，就释放第一个参数的锁，并阻塞</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等待后，我们占有锁。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker thread is processing data\n"</span>;</span><br><span class="line">    data += <span class="string">" after processing"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送数据回 main()</span></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker thread signals data processing completed\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通知前完成手动解锁，以避免等待线程才被唤醒就阻塞（细节见 notify_one ）</span></span><br><span class="line">    lk.unlock();</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"> </span><br><span class="line">    data = <span class="string">"Example data"</span>;</span><br><span class="line">    <span class="comment">// 发送数据到 worker 线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;	<span class="comment">//等待子线程将锁释放，然后加锁</span></span><br><span class="line">        <span class="built_in">ready</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main() signals data ready for processing\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_one();	<span class="comment">//通知其他线程</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等候 worker</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;	<span class="comment">//等待子线程将锁释放，然后加锁</span></span><br><span class="line">        cv.wait(lk, []&#123;<span class="keyword">return</span> processed;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Back in main(), data = "</span> &lt;&lt; data &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    worker.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板</title>
    <url>/2020/05/17/C-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>基本语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>/<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>typename和class都是关键字，在这里二者可以互相没有区别</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T lva, <span class="keyword">const</span> T rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ret;</span><br><span class="line">    ret = lva + rva;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">1</span>)； <span class="comment">//&lt;指定类型&gt; </span></span><br><span class="line"></span><br><span class="line">add&lt;<span class="keyword">double</span>&gt;(<span class="number">2.1</span>,<span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//这样也是可以，编译器会自动分析参数</span></span><br></pre></td></tr></table></figure>

<p>模板也有默认参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2 = <span class="keyword">int</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">const</span> T lva ,<span class="keyword">const</span> T rva)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Myclass</span>&lt;T&gt;:</span>:add(<span class="keyword">const</span> T lva, <span class="keyword">const</span> T rva)</span><br><span class="line">&#123;</span><br><span class="line">    a = lva + rva;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Myclass&lt;<span class="keyword">int</span>&gt; A;</span><br></pre></td></tr></table></figure>

<p>成员模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(T thistype, T1 othertype)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;T&gt;::output(T thistype, T1 othertype)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"thistype is "</span> &lt;&lt; <span class="keyword">typeid</span>(thistype).name() &lt;&lt; <span class="string">", othertype is "</span> &lt;&lt; <span class="keyword">typeid</span>(othertype).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    arr.output&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="number">10</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    arr.output&lt;<span class="keyword">double</span>&gt;(<span class="number">20</span>, <span class="number">8.8</span>);</span><br><span class="line">    arr.output(<span class="number">30</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typename特性"><a href="#typename特性" class="headerlink" title="typename特性"></a>typename特性</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Myclass();</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> test;  <span class="comment">//定义类型别名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Myclass2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Myclass2();</span><br><span class="line">    <span class="comment">//T::test *a  // 声明一个指向T::test类型的指针。 不能这样使用</span></span><br><span class="line">    <span class="keyword">typename</span> T::test * a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里typename的作用是告诉编译器T::test 是一个类型。</p>
<h3 id="类模板全特换和偏特化"><a href="#类模板全特换和偏特化" class="headerlink" title="类模板全特换和偏特化"></a>类模板全特换和偏特化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(T1 i, T2 j) : a(i), b(j) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"模板类"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;int, char&gt; //参数的个数与模板类需要一样，意味每个参数都需要指定</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> i, <span class="keyword">char</span> j) : a(i), b(j) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"全特化"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;char, T2&gt; //部分参数需要指定，其他参数可以写死</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">char</span> i, T2 j) : a(i), b(j) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"偏特化"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//类实例化的时候，就指定哪个模板</span></span><br><span class="line">    Test&lt;double, double&gt; t1(0.1, 0.2);</span><br><span class="line"></span><br><span class="line">    Test&lt;int, char&gt; t2(1, 'A');</span><br><span class="line"></span><br><span class="line">    Test&lt;char, bool&gt; t3('A', true);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数模板全特化"><a href="#函数模板全特化" class="headerlink" title="函数模板全特化"></a>函数模板全特化</h3><blockquote>
<p>函数模板不支持偏特化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a , T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"模板函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> fun&lt;<span class="keyword">int</span> ,<span class="keyword">char</span> &gt;(<span class="keyword">int</span> a, <span class="keyword">char</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"全特化"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++设计模式</title>
    <url>/2019/12/05/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a href="https://blog.csdn.net/liang19890820/article/details/66974516" target="_blank" rel="noopener">https://blog.csdn.net/liang19890820/article/details/66974516</a></p>
<p>设计模式的作用就是从变化和稳定之间寻找一个隔离点，分离它们，从而管理变化。</p>
<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a><strong>模式定义</strong></h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替代（变化），改模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）、</p>
<p>变化是复用的天敌，面向对象设计最大的优势在于：抵御变化</p>
<p>面向对象： 隔离变化，各司其职、对象</p>
<h2 id="设计模式基本原理"><a href="#设计模式基本原理" class="headerlink" title="设计模式基本原理"></a>设计模式基本原理</h2><h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><p>类的改动是通过增加代码进行的，而不是修改源代码。</p>
<h3 id="单一责任原则（SRP）"><a href="#单一责任原则（SRP）" class="headerlink" title="单一责任原则（SRP）"></a>单一责任原则（SRP）</h3><p>类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</p>
<h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><p>依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程。</p>
<h3 id="接口隔离原则（ISP"><a href="#接口隔离原则（ISP" class="headerlink" title="接口隔离原则（ISP)"></a>接口隔离原则（ISP)</h3><p>不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</p>
<h3 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h3><p>任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</p>
<h3 id="优先使用对象组合，而不是类继承（CARP）"><a href="#优先使用对象组合，而不是类继承（CARP）" class="headerlink" title="优先使用对象组合，而不是类继承（CARP）"></a>优先使用对象组合，而不是类继承（CARP）</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。</p>
<p>如果使用对象组合，就降低了这种依赖关系。</p>
<ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>
<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li>
</ul>
<h3 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h3><p>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。</p>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良的影响，从而实现不同层次间的松耦合。</li>
</ul>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合” 的类型设计方案。</li>
</ul>
<h3 id="模式的分类"><a href="#模式的分类" class="headerlink" title="模式的分类"></a>模式的分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式（Creational Patterns）</td>
<td>用于构建对象，以便它们可以从实现系统中分离出来。</td>
</tr>
<tr>
<td>结构型模式（Structural Patterns）</td>
<td>用于在许多不同的对象之间形成大型对象结构。</td>
</tr>
<tr>
<td>行为型模式（Behavioral Patterns）</td>
<td>用于管理对象之间的算法、关系和职责。</td>
</tr>
</tbody></table>
<h3 id="组件协作模式："><a href="#组件协作模式：" class="headerlink" title="组件协作模式："></a>组件协作模式：</h3><ul>
<li>template Method</li>
<li>strategy</li>
<li>observe /Event</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
</blockquote>
<ul>
<li>创建一个类，这个类永远只能生成一个实例。</li>
</ul>
<p>第一种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> singleton* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">  singleton* m_pInstance;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//不声明默认构造函数和拷贝构造函数，编译器会自动生成，所有这里我们自己声明在私有的吗，外部就不能调用了。</span></span><br><span class="line">  singleton();</span><br><span class="line">  singleton(<span class="keyword">const</span> singleton&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单进程使用 线程不安全</span></span><br><span class="line"><span class="function">singleton* <span class="title">singleton::getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果多个线程同时进入这里，这时就会产生多个实例</span></span><br><span class="line">        m_pInstance = <span class="keyword">new</span> singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑多线程 加锁</span></span><br><span class="line"><span class="comment">//进入函数进行加锁，函数执行完锁变量释放，下个线程就能继续执行函数</span></span><br><span class="line"><span class="function">singleton* <span class="title">singleton::getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Lock lock； <span class="comment">//加锁 调用函数都需要加锁 消耗太大了</span></span><br><span class="line">    <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pInstance = <span class="keyword">new</span> singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//锁释放</span></span><br></pre></td></tr></table></figure>

<p>双检查锁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双检查锁 懒汉模式</span></span><br><span class="line"><span class="function">singleton* <span class="title">singleton::getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lock lock； <span class="comment">//加锁  最差情况下会阻塞几个线程，只有实例创建完成，之后所有调用这个函数，不会加锁了</span></span><br><span class="line">        <span class="keyword">if</span> (m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> singleton();</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="keyword">static</span> singleton* m_pInstance; <span class="comment">//将实例指针定义为static，在程序一开始运行就会执行它的初始化，它的生命周期是伴随整个程序。</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//不声明默认构造函数和拷贝构造函数，编译器会自动生成，所有这里我们自己声明在私有的吗，外部就不能调用了。</span></span><br><span class="line">  singleton();</span><br><span class="line">  singleton(<span class="keyword">const</span> singleton&amp;);</span><br><span class="line">&#125;</span><br><span class="line">singleton* singleton::m_pInstance = <span class="keyword">new</span> singleton();</span><br><span class="line"></span><br><span class="line"><span class="function">singleton* <span class="title">singleton::getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：消耗内存（长期占用内存）</span></span><br></pre></td></tr></table></figure>

<p>C++11 的单例模式</p>
<p>C++11中可以保证static变量时多线程安全的，在底层实现了加锁操作。</p>
<p>由于一个static对象，可以保证对象只生成一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:  <span class="comment">//默认构造和拷贝构造都需要是private</span></span><br><span class="line">		Singleton();</span><br><span class="line">		Singleton(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">static</span> Singleton instance;</span><br><span class="line">			<span class="keyword">return</span> &amp;instance;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//member function</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"member function"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote>
<p>定义一个静态工厂方法，专门用来创建其他的类的实例，被创建的类都有一个共同的父类。</p>
</blockquote>
<p>简单工厂模式又称为静态工厂模式，通过一个类来负责创建其他类的实例，被创建的实例一般都是继承同一个类。</p>
<p>优点：通过一个工厂类来实现具体产品的创建，隐藏的产品类的实现，不需要知道具体产品类。</p>
<p>缺点：增加产品，需要修改工厂类，扩展性并不好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//创建一个静态方法实例化其他的类</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Fruit* <span class="title">create</span><span class="params">(<span class="built_in">string</span> name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Fruit * temp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,<span class="string">"Banana"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> Banana();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,<span class="string">"Pear"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span>:</span><span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  <span class="comment">//子类重写函数可以省略 virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am Banana"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pear</span>:</span><span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  <span class="comment">//子类重写函数可以省略 virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am Pear"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit *p = Factory::create(<span class="string">"Banana"</span>);</span><br><span class="line">    p-&gt;show(); <span class="comment">//输出I am Banana</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>是一种常用的对象创建型设计模式，此模式的核心思想是封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用以及方便后期维护拓展的目的。</p>
</blockquote>
<blockquote>
<p> 一个工厂对应一个产品.</p>
</blockquote>
<p>1) 从简单工厂模式到工厂模式</p>
<p>由于简单工厂模式违背的开发封闭原则，工厂模式就是对简单工厂模式演进。</p>
<p>将核心的一个工厂类，变成一个抽象的接口，使用它的子类进行创建产品。</p>
<p>优点：系统在不需要修改具体的工厂的情况下增加的新的产品。</p>
<p>缺点：创建一个新的产品需要增加一个新的工厂,加大了额外的开发量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstractFruit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstactFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> abstractFruit*  <span class="title">create</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> :</span> <span class="keyword">public</span> abstractFruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am Banana"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BananaFactory</span> :</span> <span class="keyword">public</span> abstactFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> abstractFruit* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Banana;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品Pear</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pear</span> :</span>  <span class="keyword">public</span> abstractFruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am Pear"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂PearFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PearFactory</span> :</span> <span class="keyword">public</span> abstactFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> abstractFruit* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先创建工厂，在通过工厂创建产品</span></span><br><span class="line">    abstactFactory *pFactory = <span class="keyword">new</span> BananaFactory;</span><br><span class="line">    abstractFruit * </span><br><span class="line">        </span><br><span class="line">        = pFactory-&gt;create();</span><br><span class="line">    pFruit-&gt;show(); <span class="comment">// output::I am Banana</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    .</span></span><br><span class="line"><span class="comment">    .</span></span><br><span class="line"><span class="comment">    .</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>我们将具有相同属性的产品，放到一个工厂中生产。（产品族的工厂）</p>
<p><strong>1）工厂模式和抽象工厂模式的区别</strong></p>
<p>工厂模式是一个类只能生产一个产品</p>
<p>抽象工厂模式是一个类可以生产多个产品</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseProduct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">southapple</span>:</span><span class="keyword">public</span> BaseProduct</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">southbanana</span>:</span><span class="keyword">public</span> BaseProduct</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">southFactory</span>:</span><span class="keyword">public</span> BaseFactory</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function">BaseProduct * <span class="title">getapple</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> southapple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">BaseProduct * <span class="title">getbanana</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> southbanana();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseFactory* ptrFactory= <span class="keyword">new</span> southFactory();</span><br><span class="line">    BaseProduct* ptrProduct = ptrFactory-&gt;getapple();</span><br><span class="line">    BaseProduct* ptrProduct = ptrFactory-&gt;getbanana();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式实例"><a href="#工厂模式实例" class="headerlink" title="工厂模式实例"></a>工厂模式实例</h3><p>这是参照我们之前一个项目写的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul>
<li><p>Builder（抽象建造者）：为创建一个产品对象的各个部件指定抽象接口</p>
</li>
<li><p>ConcreateBuilder(具体建造者)：实现builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。</p>
</li>
<li><p>Director（指挥者）：构造一个使用Builder接口的对象</p>
</li>
<li><p>Product（产品）：表示被构造的复杂对象，ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包含将这些部件装配成最终产品的接口。</p>
</li>
</ul>
<p>房子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">house</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlength</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = length;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setwidth</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setheight</span><span class="params">(<span class="keyword">int</span> <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建造者抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setlength</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setwidth</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setheight</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> house *<span class="title">GetHouse</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品A建造者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderA</span> :</span> <span class="keyword">public</span> Builder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建造具体的产品</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品B建造者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderB</span> :</span> <span class="keyword">public</span> Builder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建造具体的产品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">(Builder *  )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        builder-&gt;setlength();</span><br><span class="line">        builder-&gt;setwidth();</span><br><span class="line">        builder-&gt;setheight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建的对象。</p>
<ul>
<li>Prototype(抽象原型)：定义了克隆自身多接口。</li>
<li>ConcretePrototype（具体原型）：被复制的对象，需要实现Prototype定义的接口</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Prototype(<span class="keyword">const</span> Prototype &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = other.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Prototype* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Prototype(*<span class="keyword">this</span>);<span class="comment">//这里需要注意深拷贝的情况</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ul>
<li>在不改变原始类和使用继承的情况下，动态的扩展一个对象的功能。</li>
<li>就是把需要添加的附加功能分别放在单独的类，并让这个类包含它要装饰的对象。</li>
<li>客户端可以有选择、按顺序的的装饰功能包装对象。</li>
</ul>
<p>例如：我们知道咖啡分为很多种，有摩卡咖啡、拿铁咖啡</p>
<p><strong>创建所有饮料的基类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// component.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMPONENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPONENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有饮料的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBeverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 价钱</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMPONENT_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>创建具体构建</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// concrete_component.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONCRETE_COMPONENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCRETE_COMPONENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"component.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 具体的饮料（咖啡）**********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 黑咖啡，属于混合咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> :</span> <span class="keyword">public</span> IBeverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HouseBlend"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度烘培咖啡豆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> :</span> <span class="keyword">public</span> IBeverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DarkRoast"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">28.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONCRETE_COMPONENT_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>创建装饰</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decorator.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DECORATOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECORATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"component.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调味品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> :</span> <span class="keyword">public</span> IBeverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    CondimentDecorator(IBeverage *beverage) : m_pBeverage(beverage) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    IBeverage *m_pBeverage;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DECORATOR_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>创建具体装饰</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// concrete_decorator.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONCRETE_DECORATOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCRETE_DECORATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"decorator.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 具体的饮料（调味品）**********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奶油</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cream</span> :</span> <span class="keyword">public</span> CondimentDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cream(IBeverage *beverage) : CondimentDecorator(beverage) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Name() + <span class="string">" Cream"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Cost() + <span class="number">3.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 摩卡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> :</span> <span class="keyword">public</span> CondimentDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mocha(IBeverage *beverage) : CondimentDecorator(beverage) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Name() + <span class="string">" Mocha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Cost() + <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糖浆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Syrup</span> :</span> <span class="keyword">public</span> CondimentDecorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Syrup(IBeverage *beverage) : CondimentDecorator(beverage) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Name() + <span class="string">" Syrup"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pBeverage-&gt;Cost() + <span class="number">3.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONCRETE_DECORATOR_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>客服端</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"concrete_component.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"concrete_decorator.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SAFE_DELETE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) &#123; <span class="meta-keyword">if</span>(p)&#123;delete(p); (p)=NULL;&#125; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/********** 黑咖啡 **********/</span></span><br><span class="line">    IBeverage *pHouseBlend = <span class="keyword">new</span> HouseBlend();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pHouseBlend-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pHouseBlend-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 黑咖啡 + 奶油</span></span><br><span class="line">    CondimentDecorator *pCream = <span class="keyword">new</span> Cream(pHouseBlend);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pCream-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pCream-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 黑咖啡 + 摩卡</span></span><br><span class="line">    CondimentDecorator *pMocha = <span class="keyword">new</span> Mocha(pHouseBlend);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pMocha-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pMocha-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 黑咖啡 + 糖浆</span></span><br><span class="line">    CondimentDecorator *pSyrup = <span class="keyword">new</span> Syrup(pHouseBlend);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pSyrup-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pSyrup-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 深度烘培咖啡豆 **********/</span></span><br><span class="line">    IBeverage *pDarkRoast = <span class="keyword">new</span> DarkRoast();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pDarkRoast-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pDarkRoast-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度烘培咖啡豆 + 奶油</span></span><br><span class="line">    CondimentDecorator *pCreamDR = <span class="keyword">new</span> Cream(pDarkRoast);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pCreamDR-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pCreamDR-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度烘培咖啡豆 + 奶油 + 摩卡</span></span><br><span class="line">    CondimentDecorator *pCreamMocha = <span class="keyword">new</span> Mocha(pCreamDR);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pCreamMocha-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pCreamMocha-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度烘培咖啡豆 + 奶油 + 摩卡 + 糖浆</span></span><br><span class="line">    CondimentDecorator *pCreamMochaSyrup = <span class="keyword">new</span> Syrup(pCreamMocha);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pCreamMochaSyrup-&gt;Name() &lt;&lt; <span class="string">" : "</span> &lt;&lt; pCreamMochaSyrup-&gt;Cost() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    SAFE_DELETE(pSyrup);</span><br><span class="line">    SAFE_DELETE(pMocha);</span><br><span class="line">    SAFE_DELETE(pCream);</span><br><span class="line">    SAFE_DELETE(pHouseBlend);</span><br><span class="line"></span><br><span class="line">    SAFE_DELETE(pCreamMochaSyrup);</span><br><span class="line">    SAFE_DELETE(pCreamMocha);</span><br><span class="line">    SAFE_DELETE(pCreamDR);</span><br><span class="line">    SAFE_DELETE(pDarkRoast);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<p><strong>抽象所有电器</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Electric</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">poweron</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">poweroff</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







































]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux多进程</title>
    <url>/2019/12/05/C-%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><strong>什么是进程？</strong></p>
<p>进程是一个程序的运行时，是对正在运行的程序一种抽象。</p>
<p>我们都知道整个计算机的核心是CPU，计算机运行实质就是通过CPU不断执行程序指令的过程，进程可以看作CPU执行程序指令的一个过程。</p>
<p><code>由于CPU实在是太快了，那多个任务是怎么执行的呢？</code></p>
<p>CPU其实轮流执行所有任务，具体先执行哪个后执行哪个，是有操作系统控制的（它有一个调度算法），为什么让所有程序在用户感知中是同时运行的，CPU具体执行程序的过程是这样的： 先加载进程a的上下文，然后开始执行a，保存进程a的上下文，再加载进程b的上下文，然后开始执行b，保存进程b的上下文…….就这样不停在所有程序中切换执行。</p>
<p><strong>那线程是怎么回事？</strong></p>
<p>一个程序不可能只有一条逻辑，必定会有多个分支和多个程序段，例如：当进程IO阻塞中，我们想进程在等待过程中去执行程序其他部分。那就有线程的概念，它的执行过程：程序a得到CPU，加载程序上下文，开始执行程序a的1部分，然后执行程序a的2部分。。。。</p>
<p>最后进程调度，CPU资源让出，保存程序a的上下文。</p>
<p><strong>进程有三种状态</strong></p>
<p>1、就绪状态</p>
<p>进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。 </p>
<p>2、运行状态</p>
<p>进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以 执行时(如所有进程都在阻塞状态)，通常会自动执行系统的空闲进程。 </p>
<p>3、阻塞状态</p>
<p>由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理机分配给该进程，也无法运行。 </p>
<p>举个例子，你去办理业务，你需要准备好所有的材料，然后去排对，这里的过程相当于<strong>就绪状态</strong>，当轮到你办理业务时，就是<strong>运行状态</strong>，如果办理业务过程中你有什么材料不足，你需要等待其他人给你送材料，这个时候办理人员让你先去等待，他继续为其他人办理业务。这个的过程你可以看作<strong>阻塞状态</strong>，等待别人给你送材料就是等待满足某个事件。</p>
<blockquote>
<p>状态转换</p>
</blockquote>
<p>①就绪→执行：调度</p>
<p>②执行→等待：等待某个事件发生而睡眠</p>
<p>③等待→就绪：因等待的事件发生而唤醒</p>
<p>④执行→就绪：时间片用完或出现高优先</p>
<p><strong>虚拟内存</strong></p>
<p>我们知道操作系统为每一个程序分配4G的内存（有的系统可能是8G），这里的4G内存不是真正拥有4G的RAM，而是4G的虚拟内存。 </p>
<p>内核会为每个进程维护一张页表，通过页表将虚拟地址和物理内存RAM进行映射。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200731201857653.png" alt="image-20200731201857653"></p>
<p>每当一个页块被用完，就在RAM中申请一块新的页块，并在页表中进行映射，相反当一个页块用完被释放，对应的RAM内存也会被回收，以供其他进程使用。</p>
<p><strong>使用虚拟内存有什么好处？</strong></p>
<p>多个进程之间不会越界访问其他进程的内存，使每个进程的内存空间是隔离的。</p>
<p><strong>一个程序包含什么？</strong></p>
<ul>
<li><p><strong>二进制格式标识</strong>：每个程序文件都包含用于描述可执行文件格式的元信息（metainformation）。</p>
</li>
<li><p><strong>机器语言指令</strong>：对程序算法进行编码。</p>
</li>
<li><p><strong>程序入口地址</strong>：标识程序开始执行时的起始指令位置。</p>
</li>
<li><p><strong>数据</strong>：程序文件包含的变量初始值和程序使用的字面常量值（比如字符串）。</p>
</li>
<li><p><strong>符号表及重定位表</strong>：描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包含调试和运行时的符号解析（动态链接）。</p>
</li>
<li><p><strong>共享库和动态链接信息</strong>：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</p>
</li>
<li><p><strong>其它信息</strong>：程序文件还包含许多其它信息，用以描述如何创建进程。</p>
</li>
</ul>
<p><strong>进程PCB是什么？</strong></p>
<p>为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为<a href="https://baike.baidu.com/item/进程控制块/7205297" target="_blank" rel="noopener">进程控制块</a>（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。  它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。 </p>
<h1 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h1><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>C++的fork函数用来“复制”一份主程序，即创建主进程的子进程。调用fork的同时，我的理解是，已经在内存中创建了“副本”进程，同时返回pid，所以在返回值之前，已经是主进程和子进程同时在运行了（如果fork成功的话），这样，在程序的运行过程中，一次fork返回了两次值，在父进程中，fork返回新创建子进程的进程ID，在子进程中，fork返回0，这时候就能够同时跑两个进程了。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1560693482182-1560859901624.png" alt="1560693482182-1560859901624"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1560693577868-1560859910463.png" alt="1560693577868-1560859910463"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1560693782516-1560859923758.png" alt="1560693782516-1560859923758"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建进程</span></span><br><span class="line">pid_t fork (void)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断进程是否运行</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == kill(pid,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"before fork\n"</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after fork\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"fork failed"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)   <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am child,i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"child process is "</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="comment">//sleep(10);</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am parent,i = "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"parent process is "</span> &lt;&lt;getpid()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"exit process\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">before fork</span></span><br><span class="line"><span class="comment">after fork</span></span><br><span class="line"><span class="comment">after fork</span></span><br><span class="line"><span class="comment">I am parent,i = 0</span></span><br><span class="line"><span class="comment">I am parent,i = 2</span></span><br><span class="line"><span class="comment">I am parent,i = 4</span></span><br><span class="line"><span class="comment">I am parent,i = 6</span></span><br><span class="line"><span class="comment">I am parent,i = 8</span></span><br><span class="line"><span class="comment">parent process is 2066</span></span><br><span class="line"><span class="comment">exit process</span></span><br><span class="line"><span class="comment">I am child,i = 0</span></span><br><span class="line"><span class="comment">I am child,i = 1</span></span><br><span class="line"><span class="comment">I am child,i = 2</span></span><br><span class="line"><span class="comment">I am child,i = 3</span></span><br><span class="line"><span class="comment">I am child,i = 4</span></span><br><span class="line"><span class="comment">I am child,i = 5</span></span><br><span class="line"><span class="comment">I am child,i = 6</span></span><br><span class="line"><span class="comment">I am child,i = 7</span></span><br><span class="line"><span class="comment">I am child,i = 8</span></span><br><span class="line"><span class="comment">I am child,i = 9</span></span><br><span class="line"><span class="comment">child process is 2067</span></span><br><span class="line"><span class="comment">exit process</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我们从上面的结果中看出，fork之后的代码执行了两次，子进程是从fork之后执行的，但是变量i在fork之前就定义了，在父子进程中互不影响，说明子进程复制资源和代码，并且资源是独立的。</p>
<h3 id="exec-进程替换"><a href="#exec-进程替换" class="headerlink" title="exec (进程替换)"></a>exec (进程替换)</h3><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><blockquote>
<p>system() 函数调用shell的外部命令在当前进程中开始另一个进程。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：command,例如ls -al</p>
<p>返回值:</p>
<pre><code>- 失败，返回-1，当sh不能执行时，返回127
- 成功，返回进程状态值。</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *command = <span class="string">"ls -al"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = system(command);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"返回值："</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200701223153044.png" alt="image-20200701223153044"></p>
<h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p><strong>孤儿进程</strong></p>
<p>父进程先于子进程终止</p>
<p>父进程退出，而它子进程还在运行，这时子进程将会成为孤儿进程。</p>
<p>孤儿进程将会被init进程所收养，并由init进程对它们完成状态收集。</p>
<p><strong>僵尸进程</strong></p>
<p>子进程先于父进程终止</p>
<p>一个子进程其父进程没有调用wait或waitpid的情况下退出，这个子进程就是僵尸进程</p>
<blockquote>
<p>僵尸进程将会导致资源浪费，而孤儿则不会</p>
</blockquote>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>

<p>进程一旦调用wait，就会立刻阻塞自己，由wait分析是否有当前进程的某子进程已经退出，如果让它找到一个已经变成僵尸进程的子进程，wait收集这个子进程的信息，并把它彻底销毁返回，如果没有这样的进程，wait就会一直阻塞在这里，直到有一个为止。</p>
<p>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样： </p>
<p><strong>参数</strong>：</p>
<table>
<thead>
<tr>
<th align="center">value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非NULL</td>
<td align="center">则终止进程的终止状态就存放在status所指向的单元。</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center">则表示父进程不关心子进程的终止状态</td>
</tr>
</tbody></table>
<p><strong>返回值</strong>：</p>
<table>
<thead>
<tr>
<th align="center">value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">子进程的进程号</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">返回-1</td>
<td align="center">失败</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"fork failed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"执行子进程"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"等待子进程结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"执行父进程"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"进程"</span>&lt;&lt;getpid()&lt;&lt;<span class="string">"执行结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数一：需要等待的进程ID</p>
<table>
<thead>
<tr>
<th align="center">value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pid&gt;0</td>
<td align="center">只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</td>
</tr>
<tr>
<td align="center">pid=-1</td>
<td align="center">等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。</td>
</tr>
<tr>
<td align="center">pid=0</td>
<td align="center">等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任</td>
</tr>
<tr>
<td align="center">pid&lt;-1</td>
<td align="center">等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</td>
</tr>
</tbody></table>
<p>参数二：</p>
<table>
<thead>
<tr>
<th align="center">value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非NULL</td>
<td align="center">则终止进程的终止状态就存放在status所指向的单元。</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center">则表示父进程不关心子进程的终止状态</td>
</tr>
</tbody></table>
<p>参数三：</p>
<table>
<thead>
<tr>
<th align="center">value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WNOHANG</td>
<td align="center">若由pid指定的子进程未发生状态改变(没有结束)，则waitpid()不阻塞，立即返回0</td>
</tr>
<tr>
<td align="center">WUNTRACED</td>
<td align="center">返回终止子进程信息和因信号停止的子进程信息</td>
</tr>
<tr>
<td align="center">WCONTINUED</td>
<td align="center">返回收到SIGCONT信号而恢复执行的已停止子进程状态信息</td>
</tr>
</tbody></table>
<p>返回值：</p>
<table>
<thead>
<tr>
<th align="center">value</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">返回子进程的进程号</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">返回-1</td>
<td align="center">失败</td>
</tr>
<tr>
<td align="center">没有子进程退出返回0</td>
<td align="center">WNOHANG</td>
</tr>
</tbody></table>
<h2 id="linux进程间通信"><a href="#linux进程间通信" class="headerlink" title="linux进程间通信"></a>linux进程间通信</h2><p>实现进程间通信方式有5种：</p>
<ul>
<li>管道</li>
<li>信号</li>
<li>消息队列</li>
<li>信号量</li>
<li>套接字</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入，Linux 的管道主要包括两种：无名管道和有名管道。</p>
<h4 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h4><p><code>使用限制</code>：</p>
<ul>
<li>半双工的通信，数据只能单向流动</li>
<li>只能在亲缘关系的进程间使用</li>
</ul>
<h5 id="创建与关闭"><a href="#创建与关闭" class="headerlink" title="创建与关闭"></a>创建与关闭</h5><p>无名管道是基于文件描述符的通信方式。当一个管道创建时，它会创建两个文件描述符：fd[0] 、fd[1] 。其中 <strong>fd[0]</strong> 固定用于<code>读管道</code>，而 <strong>fd[1]</strong> 固定用于<code>写管道</code>。</p>
<blockquote>
<p><strong>无名管道只能用于父子进程之间的通信</strong></p>
</blockquote>
<p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/2-1Q1021A24L06.gif" alt="img"> </p>
<p>管道关闭时只需要用 <strong>close()</strong> 函数将这两个文件描述符关闭即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>参数</p>
<table>
<thead>
<tr>
<th>value</th>
<th>discription</th>
</tr>
</thead>
<tbody><tr>
<td>fd</td>
<td>文件描述符</td>
</tr>
</tbody></table>
<p>返回值</p>
<table>
<thead>
<tr>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>失败</td>
</tr>
<tr>
<td>非-1</td>
<td>成功</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无名管道</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">char</span> * args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义文件描述符数组</span></span><br><span class="line">    <span class="keyword">int</span> fdarr[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">//create the conduit  创建一个管道 并且打开两个文件描述符</span></span><br><span class="line">    <span class="comment">//管道中，第一个文件描述符只读,第二个文件描述符只写</span></span><br><span class="line">    no = pipe(fdarr);</span><br><span class="line">    <span class="keyword">if</span> (no == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe() is failed ! message :%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建父子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> child = fork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"system is game over !\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义缓存字符串数组</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         管道和文件一样，文件read函数以O_RDONLY方式打开也会阻塞，但是文件数据在本地，读取非常快，感觉不到阻塞，但是管道以O_RDONLY方式打开，会阻塞进程,read()函数会等待管道另一端写入数据，直到另一端关闭文件描述符		</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//关闭子进程中的写文件描述符--对于父子进程共享文件描述符，只在单个进程中关闭，只能将文件描述符引用减一，</span></span><br><span class="line">        <span class="comment">//因为父子进程中，文件描述符被引用了两次，所以需要在父子进程中分别关闭，才能使文件描述符引用次数减一</span></span><br><span class="line">        <span class="built_in">close</span>(fdarr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(fdarr[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">            <span class="comment">//清空缓存区</span></span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭子进程中读文件描述符</span></span><br><span class="line">        <span class="built_in">close</span>(fdarr[<span class="number">0</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//关闭父进程中的读描述符</span></span><br><span class="line">        <span class="built_in">close</span>(fdarr[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//将键盘输入数据写入到管道中</span></span><br><span class="line">        <span class="built_in">strcpy</span>(buf,<span class="string">"fly on air!\n"</span>);</span><br><span class="line">        <span class="built_in">write</span>(fdarr[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="comment">//关闭管道写文件描述符</span></span><br><span class="line">        <span class="built_in">close</span>(fdarr[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//等待子进程结束</span></span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process is close ! message :%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有名管道（命令管道）"><a href="#有名管道（命令管道）" class="headerlink" title="有名管道（命令管道）"></a>有名管道（命令管道）</h4><blockquote>
<p><strong>用于运行于同一系统中的任意两个进程间的通信</strong>。 </p>
</blockquote>
<p>创建FIFO</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>

<p>或者可以使用shell创建命令管道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfifo &#x2F;ipc&#x2F;namefifo</span><br></pre></td></tr></table></figure>

<p>参数一</p>
<table>
<thead>
<tr>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>有名管道文件名</td>
</tr>
</tbody></table>
<p>参数二: 与打开普通文件open()函数中的mode参数相同 </p>
<p>返回值：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>成功</td>
</tr>
<tr>
<td>-1</td>
<td>失败，errno被设置</td>
</tr>
</tbody></table>
<p>打开FIFO文件通常有四种方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY);<span class="comment">//1  </span></span><br><span class="line"><span class="built_in">open</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_RDONLY | O_NONBLOCK);<span class="comment">//2  </span></span><br><span class="line"><span class="built_in">open</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY);<span class="comment">//3  </span></span><br><span class="line"><span class="built_in">open</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path, O_WRONLY | O_NONBLOCK);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fifo_path = <span class="string">"./test_fifo"</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2014</span>];</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(fifo_path, <span class="number">0666</span>) &lt; <span class="number">0</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = <span class="built_in">open</span>(fifo_path, O_RDONLY);</span><br><span class="line">        <span class="built_in">read</span>(fd, buf, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the buf is "</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    fd = <span class="built_in">open</span>(fifo_path, O_WRONLY);</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的，信号是异步的，一个进程不必通过任何操作来等待信号的到达，进程也不知道信号到底什么时候到达。</p>
<p>信号是进程间通信机制中唯一的异步通信机制，信号机制进过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</p>
<p>信号的分类：</p>
<p>（1）硬件异常产生的信号</p>
<p>（2）软件条件出发的信号</p>
<p>（3）用户按某些终端键时产生的信号，比如用户按CTRL+C键将会产生SIGINT信号</p>
<p>（4）用户使用kill命令将信号发送给进程。kill命令的语法是这样的。</p>
<p>（5）进程使用系统调用函数kill将信号发送一个进车或一组进程。</p>
<p>Linux使用信号主要有两个目的：一是让进程意识到发生一个特定的事件，二是迫使进程执行包含在其自身代码中的信号处理信号。</p>
<p>（1）忽略信号，进程将忽略这个信号的出现，但有两个信号不能被忽略：SIGKILL和SIGSTOP</p>
<p>（2）执行与这个信号相关的默认操作</p>
<p>（3）调用相应的信号处理函数来捕获信号，进程可以事先登记特殊的信号处理函数，当进程收到信号，信号处理函数被调用，当从信号处理函数返回后，被中断的进程将从其断点处重新开始执行。</p>
<p><strong>使用kill发送信号</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>pid：进程号</li>
<li>sig：信号编号</li>
</ul>
<p><strong>在进程中自举一个信号</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li>sig：信号编号</li>
</ul>
<p>查看linux系统中定义了的信号<code>kill -l</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200701234639927.png" alt="image-20200701234639927"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//创建进程</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//子进程</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"In child process"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//父进程</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == (waitpid(pid,&amp;status,WNOHANG))) <span class="comment">//判断子进程是否已经退出</span></span><br><span class="line">                &#123;</span><br><span class="line">                        retval = kill(pid,SIGKILL); <span class="comment">//向pid进程发送信号</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(retval)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">"kill failed.\n"</span>;</span><br><span class="line">                                perror(<span class="string">"kill"</span>);</span><br><span class="line">                                waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;pid&lt;&lt;<span class="string">" killed\n"</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">120199 killed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用sigaction查询或设置信号处理方式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act,struct sigaction *oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (* sa_handler)(<span class="keyword">int</span>);	<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="keyword">void</span> (* sa_sigaction)(<span class="keyword">int</span> ,<span class="keyword">siginfo_t</span> *,<span class="keyword">void</span> *); <span class="comment">//另一个信号处理函数</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask; <span class="comment">//用来指定在信号处理函数执行期间需要被屏蔽的信号</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">    <span class="keyword">void</span> (* sa_restorer)(<span class="keyword">void</span>); <span class="comment">//已经废弃的数据域，不要使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sa_flags</p>
<table>
<thead>
<tr>
<th>value</th>
<th>ddescription</th>
</tr>
</thead>
<tbody><tr>
<td>SA_RESTART</td>
<td>使被信号打断的系统调用自动重新发起</td>
</tr>
<tr>
<td>SA_NOCLDSTOP</td>
<td>使父进程在它的子进程暂停或继续运行时不会收到SIGCHLD信号</td>
</tr>
<tr>
<td>SA_NOCLDWAIT</td>
<td>使父进程在它的子进程退出时不会收到SIGCHLD信号，这是子进程如果退出，也不会成为僵尸进程。</td>
</tr>
<tr>
<td>SA_NODEFER</td>
<td>使对信号的屏蔽无效，即在信号处理函数执行期间，仍能发出这个信号。</td>
</tr>
<tr>
<td>SA_RESETHAND</td>
<td>信号处理之后重新设置为默认的处理方式。</td>
</tr>
<tr>
<td>SA_SIGINFO</td>
<td>使用sa_sigaction成员而不是sa_handler作为信号处理函数</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_usr</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(signum == SIGUSR1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"SIGUSR1 received\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signum == SIGUSR2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"SIGUSR2 received\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"signal "</span>&lt;&lt;signum&lt;&lt;<span class="string">" received\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa_usr</span>;</span></span><br><span class="line">    sa_usr.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa_usr.sa_handler = sig_usr; <span class="comment">//信号处理函数</span></span><br><span class="line">    </span><br><span class="line">    sigaction(SIGUSR1,&amp;sa_usr,<span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGUSR2,&amp;sa_usr,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"My PID is "</span>&lt;&lt;getpid()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n = <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="number">511</span>) == <span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"read is interrupted by signal\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">"bytes read: "</span>&lt;&lt;buf&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">结果：</span><br><span class="line">My PID is xxxxx</span><br><span class="line"></span><br><span class="line">kill -USR1 xxxxx</span><br><span class="line"></span><br><span class="line">SIGUSR1 received</span><br><span class="line"><span class="built_in">read</span> is interrupted by signal</span><br></pre></td></tr></table></figure>

<p><strong>系统调用sigprocmask的使用</strong></p>
<p>。。。。。。。。。。。。。。。。。</p>
<p><strong>使用sigpending检查是否挂起的信号</strong></p>
<p>。。。。。。。。。。。。。。。。。</p>
<p><strong>使用signal设置信号处理程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(* <span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数signum</p>
<table>
<thead>
<tr>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>SIG_ING</td>
<td>忽略信号</td>
</tr>
<tr>
<td>SIG_DFL</td>
<td>表示恢复对信号的系统默认处理方式。</td>
</tr>
</tbody></table>
<p>参数handler表示自定义的信号处理函数</p>
<p>忽略SIGINT信号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGINT,SIG_IGN);	<span class="comment">//忽略SIGINT信号</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多次按下ctrl + C键，并没有使得程序退出。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>自定义信号SIGINT的处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*signal_handler)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_hander_fun</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"catch signal %d\n"</span>,signum); <span class="comment">//在键盘按CTRL+C键，就会打印这个。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGINT,signal_hander_fun);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列类似有名管道，但是没有与打开和关闭管道的复杂关联。然而，使用消息队列并没有解决有名管道所遇到的问题，例如管道的阻塞。</p>
<p>消息队列提供了一种在两个不相关的进程之间传递数据的而简单高效的方法，与有名管道比较起来，消息队列的优点在独立于发送与接收进程，这减少了打开与关闭有名管道之间同步的困难。</p>
<p>消息队列提供一种由一个进程向另一个进程发送块数据的方式。另外，每一个数据块被看作有一个类型，而接收进程可以独立接收具有不同类型的数据块。消息队列的好处在于我们几乎可以完全避免同步问题，并且可以通过发送消息屏蔽有名管道的问题。更好的是，我们可以使用某些紧急方式发送消息。坏处在于，与管道类似，在每一个数据块上有一个最大尺寸限制，同时在系统中所有消息队列的块尺寸上也有一个最大尺寸限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个键值</span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">char</span> * fname,<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建和打开消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取和设置消息队列的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">int</span> cmd,struct msqid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息送入消息队列的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">const</span> <span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz,<span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从消息队列中读取一条新消息的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span> *msg_ptr,<span class="keyword">size_t</span> msg_sz,<span class="keyword">long</span> <span class="keyword">int</span> msgtype,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要用于两个不相关的进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">if</span> ((id = msgget(<span class="keyword">key_t</span>(<span class="number">1234</span>), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">    msg msgdata;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"input data:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        fgets(<span class="built_in">buffer</span>, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        msgdata.type = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(msgdata.str, <span class="built_in">buffer</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(id, (<span class="keyword">void</span> *)&amp;msgdata, <span class="number">512</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(msgdata.str, <span class="string">"QUIT"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要用于两个不相关的进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">if</span> ((id = msgget(<span class="keyword">key_t</span>(<span class="number">1234</span>), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg msgdata;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msgrcv(id, (<span class="keyword">void</span> *)&amp;msgdata, <span class="number">512</span>, <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"msgrcv"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"type: "</span> &lt;&lt; msgdata.type &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"msg: "</span> &lt;&lt; msgdata.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(msgdata.str, <span class="string">"QUIT"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgctl(id, IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"del msg error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><blockquote>
<p>共享内存实际就是两个进程的页表指向同一块物理内存，使得多个进程可以使用同一块内存区域。</p>
</blockquote>
<p> 共享内存就是允许两个或多个进程共享一定的存储区。就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为数据不需要在客户机和服务器端之间复制，数据直接写到内存，不用若干次数据拷贝，所以这是最快的一种IPC。 </p>
<p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1169746-20181006220403794-1279738779.png" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>shmdata.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SHMDATA_H_HEADER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SHMDATA_H_HEADER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXT_SZ 2048</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> written;<span class="comment">//作为一个标志，非0：表示可读，0表示可写 </span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">text</span>[TEXT_SZ];<span class="comment">//记录写入和读取的文本</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> shmread.c </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shmdata.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">running</span> = <span class="number">1</span>;<span class="comment">//程序是否继续运行的标志  </span></span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;<span class="comment">//分配的共享内存的原始首地址   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared</span>;</span><span class="comment">//指向shm   </span></span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="comment">//共享内存标识符 //创建共享内存   </span></span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct shared_use_st), <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmget failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line">    shm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shm == (<span class="keyword">void</span>*)<span class="number">-1</span>)   </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span>); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nMemory attached at %X\n"</span>, (<span class="keyword">int</span>)shm);  <span class="comment">//设置共享内存   </span></span><br><span class="line">    shared = (struct shared_use_st*)shm;   </span><br><span class="line">    shared-&gt;written = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">running</span>)<span class="comment">//读取共享内存中的数据 </span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="comment">//没有进程向共享内存定数据有数据可读取       </span></span><br><span class="line">        <span class="keyword">if</span>(shared-&gt;written != <span class="number">0</span>)</span><br><span class="line">        &#123;      </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"You wrote: %s"</span>, shared-&gt;<span class="built_in">text</span>);      </span><br><span class="line">            sleep(rand() % <span class="number">3</span>);          <span class="comment">//读取完数据，设置written使共享内存段可写</span></span><br><span class="line">            shared-&gt;written = <span class="number">0</span>;         <span class="comment">//输入了end，退出循环（程序）  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(shared-&gt;<span class="built_in">text</span>, <span class="string">"end"</span>, <span class="number">3</span>) == <span class="number">0</span>)    </span><br><span class="line">                <span class="built_in">running</span> = <span class="number">0</span>;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//有其他进程在写数据，不能读取数据     </span></span><br><span class="line">            sleep(<span class="number">1</span>);  </span><br><span class="line">    &#125;   <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span>);     </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;   <span class="comment">//删除共享内存   </span></span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmctl(IPC_RMID) failed\n"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> shmwrite.c </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shmdata.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">running</span> = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">void</span> *shm = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_use_st</span> *<span class="title">shared</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[BUFSIZ + <span class="number">1</span>];<span class="comment">//用于保存输入的文本</span></span><br><span class="line">    <span class="keyword">int</span> shmid;  </span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="keyword">sizeof</span>(struct shared_use_st), <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmget failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line">    shm = shmat(shmid, (<span class="keyword">void</span>*)<span class="number">0</span>, <span class="number">0</span>);   </span><br><span class="line">    <span class="keyword">if</span>(shm == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span>);     </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Memory attached at %X\n"</span>, (<span class="keyword">int</span>)shm);    <span class="comment">//设置共享内存   </span></span><br><span class="line">    shared = (struct shared_use_st*)shm;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">running</span>)<span class="comment">//向共享内存中写数据  </span></span><br><span class="line">    &#123;   <span class="comment">//数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本       </span></span><br><span class="line">        <span class="keyword">while</span>(shared-&gt;written == <span class="number">1</span>)     </span><br><span class="line">        &#123;          </span><br><span class="line">            sleep(<span class="number">1</span>);      </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Waiting...\n"</span>);</span><br><span class="line">        &#125;       <span class="comment">//向共享内存中写入数据       </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter some text: "</span>);       </span><br><span class="line">        fgets(<span class="built_in">buffer</span>, BUFSIZ, <span class="built_in">stdin</span>);      </span><br><span class="line">        <span class="built_in">strncpy</span>(shared-&gt;<span class="built_in">text</span>, <span class="built_in">buffer</span>, TEXT_SZ);      <span class="comment">//写完数据，设置written使共享内存段可读       </span></span><br><span class="line">        shared-&gt;written = <span class="number">1</span>;     <span class="comment">//输入了end，退出循环（程序）  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(<span class="built_in">buffer</span>, <span class="string">"end"</span>, <span class="number">3</span>) == <span class="number">0</span>)         </span><br><span class="line">            <span class="built_in">running</span> = <span class="number">0</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm) == <span class="number">-1</span>)   </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span>);     </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;  </span><br><span class="line">    sleep(<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量本质上是一个计数器（不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作）,用于多进程对共享数据对象的读取，它和管道有所不同，==它不以传送数据为主要目的==，==它主要是用来保护共享资源（信号量也属于临界资源）==，使得资源在一个时刻只有一个进程独享。</p>
<p>工作原理：</p>
<p>由于信号量只能进行两种操作==等待和发送信号==，即P(sv)和V(sv),他们的行为是这样的：</p>
<p>（1）P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</p>
<p>（2）V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p>
<p>在信号量进行PV操作时都为原子操作（因为它需要保护临界资源）</p>
<p>注：原子操作：单指令的操作称为原子的，单条指令的执行是不会被打断的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;　</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> nsems,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于信号量的初始化和删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nops)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> sem_id;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_semvalue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun sem_union;    </span><br><span class="line">    sem_union.val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id,<span class="number">0</span>,SETVAL,sem_union)==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semaphore_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id,&amp;sem_b,<span class="number">1</span>)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"semaphore_p failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semaphore_v</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id,&amp;sem_b,<span class="number">1</span>)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"semaphore_v failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_semvalue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除信号量</span></span><br><span class="line">    <span class="keyword">union</span> semun sem_union;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id,<span class="number">0</span>,IPC_RMID,sem_union)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Failed to delete semaphore\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message = <span class="string">'x'</span>;</span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">     sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>,<span class="number">1</span>,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化信号量</span></span><br><span class="line">        <span class="keyword">if</span>(!set_semvalue())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"init failed\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//参数的第一个字符赋给message</span></span><br><span class="line">        message = argv[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待信号量</span></span><br><span class="line">        <span class="keyword">if</span>(!semaphore_p())</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,message);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//发送信号量</span></span><br><span class="line">        <span class="keyword">if</span>(!semaphore_v())</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d-finished\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//退出前删除信号量</span></span><br><span class="line">        del_semvalue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>见网络内容</p>
<p>参考：<a href="https://www.cnblogs.com/tshua/p/5756465.html" target="_blank" rel="noopener">https://www.cnblogs.com/tshua/p/5756465.html</a></p>
<p>这几种进程间通信的方式的优缺点和应用场景</p>
<p><strong>管道</strong></p>
<ol>
<li><p>匿名管道</p>
<p>只存在于内存，没有存在于文件系统中，通信的数据是无格式的流并且大小受限。</p>
<p>匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
</li>
<li><p>命令管道</p>
<p>文件系统中创建一个类型为p的设备文件，两个没有关系的进程可以通过这个设备文件进行通信。</p>
</li>
</ol>
<p>应用场景：</p>
<p>管道这种通信方式效率低，不适合进程间频繁地交换数据 。</p>
<p><strong>消息队列</strong></p>
<p>消息队列是保存在内核中的<em>消息链表</em>。</p>
<p>消息队列不合适比较大数据的传输。</p>
<p>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。</p>
<p><strong>共享内存</strong></p>
<p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。</p>
<p><strong>信号量</strong></p>
<p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p>
<p><strong>socket</strong></p>
<p>要与不同主机的进程间通信，那么就需要 Socket通信。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP游记</title>
    <url>/2019/11/25/CPP%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++问题收集</title>
    <url>/2019/11/25/CC++%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="类class和结构体struct区别"><a href="#类class和结构体struct区别" class="headerlink" title="类class和结构体struct区别"></a>类class和结构体struct区别</h2><blockquote>
<p>class和struct唯一的不同就是，class默认的访问方式是private，struct默认访问方式为public</p>
</blockquote>
<h2 id="指针作为形式参数，什么时候用一级指针？-什么时候用二级指针"><a href="#指针作为形式参数，什么时候用一级指针？-什么时候用二级指针" class="headerlink" title="指针作为形式参数，什么时候用一级指针？ 什么时候用二级指针?"></a>指针作为形式参数，什么时候用一级指针？ 什么时候用二级指针?</h2><p>形参是实参的拷贝，所以在函数中修改不会修改实参的值，但是通过指针修改指针指向的内存是可以的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//传入一级指针 修改指针指向的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//传入一级指针 修改指针的值</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在函数中p是一个局部变量，修改的局部变量p，对原来的那个p没有影响</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"尝试修改p的值"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="number">0x123345566</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//传入二级指针，就可以修改一级指针了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">""</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    *p = (<span class="keyword">int</span> *)<span class="number">0x111313131</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    func(p);</span><br><span class="line">    func1(p);</span><br><span class="line">    func2(&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a>数组的地址</h2><p><strong>一维数组</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//一维数组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我经常对数组地址和元素地址混淆，虽然 a = &amp;a 在值上是一样的，它们在层级上是不同的，&amp;a就是整个数组的地址，a就是数组首元素的地址，a+1就是第二给元素的地址，第三、第四元素，依次加1。</p>
</blockquote>
<ul>
<li>a就是a[0]的地址，a+1就是a[1]的地址</li>
<li>&amp;a是整个a[]的首地址，</li>
</ul>
<p>一维数组元素的值和地址转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] == *(a+<span class="number">0</span>) == *a</span><br><span class="line">a[<span class="number">1</span>] == *(a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>二维数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>&amp;a是整个二维数组的地址</p>
<p>a就是数组首元素的地址，a+1就是第二给元素的地址，第三、第四元素，依次加1。</p>
<p>与一维数组比较，可以将二维数组看作3个一维数组,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;      </span><br><span class="line">a2[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;      </span><br><span class="line">a3[] = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123;&amp;a1,&amp;a2,&amp;a3&#125;  <span class="comment">//这里放的是整个数组的地址</span></span><br><span class="line">------------</span><br><span class="line">a = &amp;a1</span><br><span class="line">a + <span class="number">1</span> = &amp;a2</span><br><span class="line">a + <span class="number">2</span> = &amp;a3</span><br><span class="line">a[<span class="number">0</span>] = a1 <span class="comment">//首元素的地址</span></span><br><span class="line">a[<span class="number">1</span>] = a2</span><br><span class="line">a[<span class="number">2</span>] = a3</span><br><span class="line">和一维数组一样，a是首元素的地址，移动指针可以指向后面元素</span><br><span class="line">-----------</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = *(*(a + <span class="number">0</span>) + <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>二维数组元素的值和地址转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_point</span>(<span class="title">T</span> *<span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(p) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    print_point(a);</span><br><span class="line">    print_point(a+<span class="number">1</span>);</span><br><span class="line">    print_point(&amp;a);</span><br><span class="line">    print_point(&amp;a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">0x7fffffb6bdf0</span></span><br><span class="line"><span class="comment">0x7fffffb6bdf4</span></span><br><span class="line"><span class="comment">0x7fffffb6bdf0</span></span><br><span class="line"><span class="comment">0x7fffffb6be04</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_point</span>(<span class="title">T</span> *<span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(p) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_value</span>(<span class="title">T</span> <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; value &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    int a[] = &#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">//    print_point(a);</span></span><br><span class="line"><span class="comment">//    print_point(a+1);</span></span><br><span class="line"><span class="comment">//    print_point(&amp;a);</span></span><br><span class="line"><span class="comment">//    print_point(&amp;a+1);</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    print_point(a);</span><br><span class="line">    print_point(a[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">    print_point(a+<span class="number">1</span>);</span><br><span class="line">    print_point(*(a+<span class="number">1</span>));</span><br><span class="line">    print_point(a[<span class="number">1</span>]);</span><br><span class="line">    print_point(a[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">    print_value(*(a[<span class="number">1</span>]+<span class="number">1</span>));</span><br><span class="line">    print_value(*(*(a+<span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">    print_point(a+<span class="number">2</span>);</span><br><span class="line">    print_point(a[<span class="number">2</span>]);</span><br><span class="line"> </span><br><span class="line">    print_point(&amp;a);</span><br><span class="line">    print_point(&amp;a+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    print_value(*(a[<span class="number">0</span>]));</span><br><span class="line">    print_value(*(a[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">0x7fffcb97faf0</span></span><br><span class="line"><span class="comment">0x7fffcb97faf0</span></span><br><span class="line"><span class="comment">0x7fffcb97fafc</span></span><br><span class="line"><span class="comment">0x7fffcb97fafc</span></span><br><span class="line"><span class="comment">0x7fffcb97fafc</span></span><br><span class="line"><span class="comment">0x7fffcb97fb00</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0x7fffcb97fb08</span></span><br><span class="line"><span class="comment">0x7fffcb97fb08</span></span><br><span class="line"><span class="comment">0x7fffcb97faf0</span></span><br><span class="line"><span class="comment">0x7fffcb97fb14</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="typename-和-class"><a href="#typename-和-class" class="headerlink" title="typename 和 class"></a>typename 和 class</h2><p><code>typename</code>和<code>class</code>是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。因为历史原因，两个是可以通用的。对有些程序员来说，在定义类模板的时候，常常使用 class 作为关键字，增加代码可读性。其它则用 typename，上面的代码大都遵循这样的标准，但是并无强制规定。但是如果二者没有差别，为什么还要加入typename呢？<strong>c++标准委员会不会增加无用的特性</strong>，让我们来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Myclass();</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">int</span> test;  <span class="comment">//定义类型别名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Myclass2</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Myclass2();</span><br><span class="line">        T::test *a  <span class="comment">// 声明一个指向T::test类型的指针。</span></span><br><span class="line">        <span class="comment">//   typename T::test * a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的代码没有全部写完，大家觉得编译器能够过吗？答案是不能,因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。当然如果这里没有二义性，比如<code>Myclass ::test * a</code> ,加上 typename 是会报错的。此外，在 class 的 STL 底层还有一个特性，用于保留模板参数，但是在 c++17 中已经舍弃，所以我们没有讲。</p>
<h2 id="如何判断大小端（字节序）"><a href="#如何判断大小端（字节序）" class="headerlink" title="如何判断大小端（字节序）"></a>如何判断大小端（字节序）</h2><table>
<thead>
<tr>
<th>内存地址</th>
<th>0x4000 8000（低地址）</th>
<th>0x4000 8001</th>
<th>0x4000 8002</th>
<th>0x4000 8003（高地址）</th>
</tr>
</thead>
<tbody><tr>
<td>大端模式</td>
<td><code>0x12（高字节）</code></td>
<td><code>0x34</code></td>
<td><code>0x56</code></td>
<td><code>0x78（低字节）</code></td>
</tr>
<tr>
<td>小端模式</td>
<td><code>0x78（低字节）</code></td>
<td><code>0x56</code></td>
<td><code>0x34</code></td>
<td><code>0x12（高字节）</code></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;a;    <span class="comment">//int强制类型转换为char，从低地址开始截取</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, *p);</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">0x12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is a big endian"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This ia a small endian"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言中关于float、double、long-double精度及数值范围"><a href="#C语言中关于float、double、long-double精度及数值范围" class="headerlink" title="C语言中关于float、double、long double精度及数值范围"></a>C语言中关于float、double、long double精度及数值范围</h2><p>float double取值范围如下：</p>
<p>对于单精度浮点数（float）来说，有一位符号位，指数位共8位，尾数共23位。指数能够表示的指数范围为-128~127。尾数为23位。当尾数全1时再加上小数点前面的1，指数取到最大正数127（8位，正数最大127，负数最小-128）,浮点数取得正数的最大值。</p>
<p>+1.111111111111111111111*2^127（1.后面23个1，由于尾数的范围1～2，其最高位总为1，故只需存取小数部分，所以小数为是23位1），约等于2*2^127=3.4*10^38。为3.4*10^38负数亦然。</p>
<p>Double的计算与此类似，double的符号位为63位，指数为62～52位，共11位。表示的范围为-1024～1023。尾数为51～0。表示的范围为+1.111111111111111111111 * 2^1023（1.后面52个1）为1.7*10^308。负数亦然。</p>
<h2 id="如何在namespace中写代码"><a href="#如何在namespace中写代码" class="headerlink" title="如何在namespace中写代码"></a>如何在namespace中写代码</h2><p>func.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by amdeo on 2019-07-02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINUX_C_FUNC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINUX_C_FUNC_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//声明一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> ydb</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process_test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LINUX_C_FUNC_H</span></span></span><br></pre></td></tr></table></figure>

<p>func.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by amdeo on 2019-07-02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//在cpp文件中 直接使用 (::)实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ydb::process_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"before fork\n"</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after fork\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"fork failed"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)   <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am child,i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"child process is "</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="comment">//sleep(10);</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"I am parent,i = "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"parent process is "</span> &lt;&lt;getpid()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"exit process\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//在main函数中直接使用（ydb::）调用</span></span><br><span class="line">    ydb::process_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extern和头文件"><a href="#extern和头文件" class="headerlink" title="extern和头文件"></a>extern和头文件</h2><p><strong>我们引用外部的定义的变量或者函数可以使用头文件，为什么还需要extern呢？</strong></p>
<p>最先开始的C语言没有头文件，使用外部变量或者函数都是用先extern声明外部的变量和函数，之后在源文件中就可以在使用声明的变量和函数。</p>
<p>后来为了方便阅读和其他原因，增加头文件用来专门写声明。</p>
<p>如果想要引用其他源文件的全局变量或者函数。</p>
<p>a.c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;    <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span>    <span class="comment">//全局函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;<span class="comment">//声明下a</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取变量的类型"><a href="#获取变量的类型" class="headerlink" title="获取变量的类型"></a>获取变量的类型</h2><p> 头文件： <code>include &lt;typeinfo&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="keyword">typeid</span>(i).name());</span><br><span class="line">    <span class="comment">//输出结果为float</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言中scanf"><a href="#C语言中scanf" class="headerlink" title="C语言中scanf"></a>C语言中scanf</h2><blockquote>
<p>从键盘获取用户的输入</p>
</blockquote>
<p>如何使用scanf获取键盘输入？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入一个数字："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的数字为结果：%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入的字符串为: %s\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试发现scanf，输入字符串时，遇到<strong>空格</strong>，就认为字符串输入结束。</p>
<p>查了资料发现：</p>
<p>① 遇空格、“回车”、“跳格”键。</p>
<p>② 遇宽度结束。<br>③ 遇非法输入。 </p>
<p>怎么解决输入空字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanfV2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">80</span>]; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,str); <span class="comment">//读到'\n'结束读取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言中计算代码执行时间"><a href="#C语言中计算代码执行时间" class="headerlink" title="C语言中计算代码执行时间"></a>C语言中计算代码执行时间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, <span class="built_in">end</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="keyword">double</span> finish = (<span class="keyword">double</span>)(<span class="built_in">end</span> - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; finish &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果代码执行的时间太小，例如输出的结果为0，此时可以对测试的代码做循环n，最后使用总时间/n，求平均值也行。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>css 2D转换</title>
    <url>/2020/11/24/Css-2D%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="Css-2D转换"><a href="#Css-2D转换" class="headerlink" title="Css 2D转换"></a>Css 2D转换</h2><p>transform</p>
<p>变换方法：</p>
<ul>
<li>translate()   移动</li>
<li>rotate()        旋转</li>
<li>scale()         缩放</li>
<li>skew()         倾斜</li>
<li>matrix()        matrix()方法和2D变换方法合并成一个。包含旋转，缩放，移动（平移）和倾斜功能。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 2D 转换，使用六个值的矩阵。</td>
</tr>
<tr>
<td>translate(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td>
</tr>
<tr>
<td>translateX(<em>n</em>)</td>
<td>定义 2D 转换，沿着 X 轴移动元素。</td>
</tr>
<tr>
<td>translateY(<em>n</em>)</td>
<td>定义 2D 转换，沿着 Y 轴移动元素。</td>
</tr>
<tr>
<td>scale(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度和高度。</td>
</tr>
<tr>
<td>scaleX(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度。</td>
</tr>
<tr>
<td>scaleY(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的高度。</td>
</tr>
<tr>
<td>rotate(<em>angle</em>)</td>
<td>定义 2D 旋转，在参数中规定角度。</td>
</tr>
<tr>
<td>skew(<em>x-angle</em>,<em>y-angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td>
</tr>
<tr>
<td>skewX(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 轴。</td>
</tr>
<tr>
<td>skewY(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 Y 轴。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
</tr>
<tr>
<td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>3d转化</td>
</tr>
<tr>
<td>translateX(<em>x</em>)</td>
<td>用于x轴的转化</td>
</tr>
<tr>
<td>translateY(<em>y</em>)</td>
<td>用于Y轴的转化</td>
</tr>
<tr>
<td>translateZ(<em>z</em>)</td>
<td>用于z轴的转化</td>
</tr>
<tr>
<td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>3D缩放转换</td>
</tr>
<tr>
<td>scaleX(<em>x</em>)</td>
<td>通过x轴进行缩放</td>
</tr>
<tr>
<td>scaleY(<em>y</em>)</td>
<td>通过y轴进行缩放</td>
</tr>
<tr>
<td>scaleZ(<em>z</em>)</td>
<td>通过z轴进行缩放</td>
</tr>
<tr>
<td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td>3D旋转</td>
</tr>
<tr>
<td>rotateX(<em>angle</em>)</td>
<td>沿着x轴的3D旋转</td>
</tr>
<tr>
<td>rotateY(<em>angle</em>)</td>
<td>沿着y轴的3D旋转</td>
</tr>
<tr>
<td>rotateZ(<em>angle</em>)</td>
<td>沿着z轴的3D旋转</td>
</tr>
<tr>
<td>perspective(<em>n</em>)</td>
<td>3D转换元素的透视视图</td>
</tr>
</tbody></table>
<h2 id="角度单位"><a href="#角度单位" class="headerlink" title="角度单位"></a>角度单位</h2><h3 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h3><p>度(degress),一个圆共360度</p>
<p>90deg = 100grad = 0.25turn ≈ 1.570796326794897rad</p>
<h3 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h3><p>梯度(Gradians), 一个圆共400梯度</p>
<h3 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h3><p>弧度(Radians),一个圆共2π弧度</p>
<h3 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h3><p>转、圈(Turns)，一个圆共1圈</p>
]]></content>
  </entry>
  <entry>
    <title>C语言实例</title>
    <url>/2016/02/20/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="求某一年的某一月的多少天？"><a href="#求某一年的某一月的多少天？" class="headerlink" title="求某一年的某一月的多少天？"></a>求某一年的某一月的多少天？</h2><p>我们需要先清楚一年中每月有多少天，哪些月份是固定的天数，哪些月份是天数不确定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一月 &#x3D; 31</span><br><span class="line"></span><br><span class="line">二月 &#x3D; 28 或者29</span><br><span class="line"></span><br><span class="line">三月 &#x3D; 31</span><br><span class="line"></span><br><span class="line">四月 &#x3D; 30</span><br><span class="line"></span><br><span class="line">五月 &#x3D; 31</span><br><span class="line"></span><br><span class="line">六月 &#x3D; 30</span><br><span class="line"></span><br><span class="line">七月 &#x3D; 31</span><br><span class="line"></span><br><span class="line">八月 &#x3D; 31</span><br><span class="line"></span><br><span class="line">九月 &#x3D; 30</span><br><span class="line"></span><br><span class="line">十月 &#x3D; 31</span><br><span class="line"></span><br><span class="line">十一月 &#x3D; 30</span><br><span class="line"></span><br><span class="line">十二月 &#x3D; 31</span><br></pre></td></tr></table></figure>

<p>这里只有二月份的变数，那怎么确认某一年的二月份是28或29。</p>
<p>二月份的天数与闰年有关。闰年的判断依据是：</p>
<p>若某年能被4整除，但不能被100整除，则一年是闰年；若某年能被400年整除，则这一年也是闰年。（闰年为29天）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year,month,day;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入年份："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;year);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入月份："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;month);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (month)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        day = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        day = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span>(year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">100</span> || year%<span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            day = <span class="number">29</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            day = <span class="number">28</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"月份输入错误！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"天数：%d\n"</span>, day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输入一个字符串、统计英文字母、空格、数字和其他字符的个数"><a href="#输入一个字符串、统计英文字母、空格、数字和其他字符的个数" class="headerlink" title="输入一个字符串、统计英文字母、空格、数字和其他字符的个数"></a>输入一个字符串、统计英文字母、空格、数字和其他字符的个数</h2><p>分析：</p>
<p>那我们需要确定英文字母、空格、数字的在ASCII码表中对应的十进制。</p>
<p>英文字母 = 65<del>90 (大写字母)  97</del>122（小写字母）</p>
<p>空格 = 0</p>
<p>数字 = 48 ~ 57</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> alphabetNum = <span class="number">0</span>; <span class="comment">//字母个数</span></span><br><span class="line">    <span class="keyword">int</span> spaceNum = <span class="number">0</span>; <span class="comment">//空格个数</span></span><br><span class="line">    <span class="keyword">int</span> digitNum = <span class="number">0</span>; <span class="comment">//数字个数</span></span><br><span class="line">    <span class="keyword">int</span> otherNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入一些字符："</span>);</span><br><span class="line">    <span class="keyword">while</span> ((a = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf("%c",a[0]);</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;= <span class="string">'A'</span> &amp;&amp; a &lt;= <span class="string">'Z'</span>) || (a &gt;= <span class="string">'a'</span> &amp;&amp; a &lt;= <span class="string">'z'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            alphabetNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            spaceNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="string">'0'</span> &amp;&amp; a &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digitNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            otherNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字母个数:%d\n"</span>, alphabetNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"空格个数:%d\n"</span>, spaceNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数字个数:%d\n"</span>, digitNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他个数:%d\n"</span>, otherNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算用1分钱、2分钱、5分钱组成1元钱的方式"><a href="#计算用1分钱、2分钱、5分钱组成1元钱的方式" class="headerlink" title="计算用1分钱、2分钱、5分钱组成1元钱的方式"></a>计算用1分钱、2分钱、5分钱组成1元钱的方式</h2><p>分析</p>
<p>以其中两种纸币为变量，确定剩下来的那种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt;= <span class="number">100</span> / <span class="number">5</span>; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt;= (<span class="number">100</span> - <span class="number">5</span> * m) / <span class="number">2</span>; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1分%d个，2分%d个，5分%d个\n"</span>, <span class="number">100</span> - <span class="number">5</span> * m - <span class="number">2</span> * n, n, m);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"共有%d种组合方式\n"</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C语言输出九九乘法表"><a href="#C语言输出九九乘法表" class="headerlink" title="C语言输出九九乘法表"></a>C语言输出九九乘法表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d x %d = %-4d"</span>, i, j, (i * j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言输出菱形"><a href="#C语言输出菱形" class="headerlink" title="C语言输出菱形"></a>C语言输出菱形</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">line</span>;  <span class="comment">// 菱形总行数</span></span><br><span class="line">    <span class="keyword">int</span> column;  <span class="comment">// 菱形总列数</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">// 当前行</span></span><br><span class="line">    <span class="keyword">int</span> j;  <span class="comment">// 当前列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入菱形的行数(奇数)："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;<span class="built_in">line</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">line</span> % <span class="number">2</span> == <span class="number">0</span>) &#123;  <span class="comment">// 判断是否是奇数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"必须输入奇数！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    column = <span class="built_in">line</span>;  <span class="comment">// 总行数和总列数相同</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="built_in">line</span>; i++) &#123;  <span class="comment">// 遍历所有行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; (<span class="built_in">line</span> + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) &#123;  <span class="comment">// 上半部分（包括中间一行）</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= column; j++) &#123;  <span class="comment">// 遍历上半部分的所有列</span></span><br><span class="line">                <span class="keyword">if</span> ((column + <span class="number">1</span>) / <span class="number">2</span> - (i - <span class="number">1</span>) &lt;= j &amp;&amp; j &lt;= (column + <span class="number">1</span>) / <span class="number">2</span> + (i - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 下半部分</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= column; j++) &#123;  <span class="comment">// 遍历下半部分的所有列</span></span><br><span class="line">                <span class="keyword">if</span> ((column + <span class="number">1</span>) / <span class="number">2</span> - (<span class="built_in">line</span> - i) &lt;= j &amp;&amp; j &lt;= (column + <span class="number">1</span>) / <span class="number">2</span> + (<span class="built_in">line</span> - i)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="C语言百钱买百鸡问题（经典题目）"><a href="#C语言百钱买百鸡问题（经典题目）" class="headerlink" title="C语言百钱买百鸡问题（经典题目）"></a>C语言百钱买百鸡问题（经典题目）</h2><h2 id="C语言求π的值-3种方法"><a href="#C语言求π的值-3种方法" class="headerlink" title="C语言求π的值(3种方法)"></a>C语言求π的值(3种方法)</h2>]]></content>
  </entry>
  <entry>
    <title>C和C++中include搜索路径</title>
    <url>/2020/03/29/C%E5%92%8CC-%E4%B8%ADinclude%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>在C和C++中使用<code>#include</code>来引用头文件，一般有两种方式：</p>
<p>使用&lt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>

<p>使用” “</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;myheadfile.h&gt;</span><br></pre></td></tr></table></figure>

<p>寻找头文件的顺序</p>
<ol>
<li><p>编译器通过参数<code>-I</code> 指定头文件的搜索路径(如果有多个，可以使用多个<code>-I</code>)</p>
</li>
<li><p>使用#include 双引号方式引用头文件，会优先在当前文件下寻找头文件</p>
</li>
<li><p>通过查找gcc的环境变量 C_INCLUDE_PATH、CPLUS_INCLUDE_PATH、OBJC_INCLUDE_PATH来搜索头文件位置。 </p>
</li>
<li><p>通过标准系统目录搜索</p>
<p>/usr/include </p>
<p>/usr/local/include </p>
<p>/usr/lib/gcc-lib/i386-linux/2.95.2/include   (<code>这个是gcc程序的库文件地址，各个用户的系统上可能不一样</code>)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
  </entry>
  <entry>
    <title>C陷阱</title>
    <url>/2016/03/15/C%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<h2 id="数组作为函数参数，不能使用sizeof获取数组个数"><a href="#数组作为函数参数，不能使用sizeof获取数组个数" class="headerlink" title="数组作为函数参数，不能使用sizeof获取数组个数"></a>数组作为函数参数，不能使用sizeof获取数组个数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span> <span class="params">(<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    test(a);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>因为数组作为函数参数，只是将指向数组指针拷贝给函数，所以在函数中使用sizeof，只能获取指针的内存大小。</p>
]]></content>
  </entry>
  <entry>
    <title>Electron</title>
    <url>/2019/12/26/Electron/</url>
    <content><![CDATA[<p><a href="http://www.electronjs.org/docs" target="_blank" rel="noopener">electron 官方文档</a></p>
<h3 id="安装electron卡在node-install-js"><a href="#安装electron卡在node-install-js" class="headerlink" title="安装electron卡在node install.js"></a>安装electron卡在node install.js</h3><p>在网上搜索找了很多方法：</p>
<p>例如：修改环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">淘宝镜像</span></span><br><span class="line">ELECTRON_MIRROR="https://cdn.npm.taobao.org/dist/electron/"</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line"><span class="meta">#</span><span class="bash">华为镜像</span></span><br><span class="line">ELECTRON_MIRROR="https://mirrors.huaweicloud.com/electron/"</span><br><span class="line"></span><br><span class="line">ELECTRON_CUSTOM_DIR=7.1.7  #版本目录，默认的版本目录带v7.1.7，第三方镜像都是不带v的，所以需要重新指定下</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>electron</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Clion</title>
    <url>/2017/12/08/Clion/</url>
    <content><![CDATA[<h1 id="windows上配置clion"><a href="#windows上配置clion" class="headerlink" title="windows上配置clion"></a>windows上配置clion</h1><p>下载<strong>MinGW</strong></p>
<p><a href="[https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/]">MinGw</a>点击下载</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1565015562631.png" alt="img"></p>
<p>将下载的文件进行解压</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1565016090640.png" alt="img"></p>
<p>打开clion的setting</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1565016173259.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1565016235330.png" alt="img"></p>
<h1 id="在clion中使用openGL"><a href="#在clion中使用openGL" class="headerlink" title="在clion中使用openGL"></a>在clion中使用openGL</h1><p>1、首先下载freeglut <a href="https://www.transmissionzero.co.uk/software/freeglut-devel/" target="_blank" rel="noopener">https://www.transmissionzero.co.uk/software/freeglut-devel/</a></p>
<p>选择for mingw版本的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1565016355294.png" alt="img"></p>
<p>2、打开压缩包，里面有bin，include，lib三个文件夹</p>
<p>a、将压缩包/include/GL中的文件拷贝到mingw/include/GL文件夹下</p>
<p>b、64位机的话将压缩包/lib/x64中的.a文件拷贝到mingw/lib文件夹下，32位机的话应该拷的是压缩包/lib中的两个.a文件</p>
<p>c、64位机把压缩包/bin/x64里的文件拷贝到C://Windows//SysWOW64下，32位机压缩包/bin下文件到C://Windows//System32下</p>
<p>3、新建CLion工程，修改CMake文件</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Flv</title>
    <url>/2019/12/26/Flv/</url>
    <content><![CDATA[<p><a href="https://www.kryii.com/7.html" target="_blank" rel="noopener">FFmpeg 命令行 – Steins;Gate (kryii.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_42462202/article/details/88661883" target="_blank" rel="noopener">(17条消息) FLV格式详解_JT同学的博客-CSDN博客_flv格式</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;input.mp4&quot; -ss 00:00:00 -t 5 -c copy &quot;output.mp4&quot;</span><br></pre></td></tr></table></figure>

<p>xx</p>
]]></content>
      <categories>
        <category>electron</category>
      </categories>
  </entry>
  <entry>
    <title>Manjaro</title>
    <url>/2019/12/05/Manjaro/</url>
    <content><![CDATA[<p>marjaro是基于Arch linux的衍生的，相比较Arch linux大大改善了用户体验，不需要用户从头进行配置整个系统，开箱即用，对小白来说是一种福音，并且有很多桌面版本可供选择。</p>
<p>manjaro安装后配置</p>
<h2 id="更新镜像排名"><a href="#更新镜像排名" class="headerlink" title="更新镜像排名"></a>更新镜像排名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure>


<h2 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>


<h2 id="安装archlinuxcn-keyring"><a href="#安装archlinuxcn-keyring" class="headerlink" title="安装archlinuxcn-keyring"></a>安装archlinuxcn-keyring</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br><span class="line">sudo pacman -Syy&#x2F;&#x2F;更新数据源</span><br></pre></td></tr></table></figure>


<h2 id="添加-archlinuxCN源"><a href="#添加-archlinuxCN源" class="headerlink" title="添加 archlinuxCN源"></a>添加 archlinuxCN源</h2><p>用 vim 编辑 /etc/pacman.conf –&gt; 命令为：sudo vim /etc/pacman.conf</p>
<p>在文件底部添加以下几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel &#x3D; Optional TrustedOnly</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure>


<h2 id="安装输入法（安装基于-fcitx-的搜狗输入法）"><a href="#安装输入法（安装基于-fcitx-的搜狗输入法）" class="headerlink" title="安装输入法（安装基于 fcitx 的搜狗输入法）"></a>安装输入法（安装基于 fcitx 的搜狗输入法）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br></pre></td></tr></table></figure>


<p>添加输入法配置文件 (sudo vim ~/.xprofile)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br></pre></td></tr></table></figure>


<h2 id="安装yaourt、yay"><a href="#安装yaourt、yay" class="headerlink" title="安装yaourt、yay"></a>安装yaourt、yay</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S yaourt</span><br><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure>


<h2 id="安装WPS"><a href="#安装WPS" class="headerlink" title="安装WPS"></a>安装WPS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wps-office</span><br><span class="line">sudo pacman -S ttf-wps-fonts</span><br></pre></td></tr></table></figure>


<p>解决无法输入中文问题：</p>
<p><code>sudo vim /usr/bin/wps</code>，在第一行（<code>#!/bin/bash</code>）下面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br></pre></td></tr></table></figure>


<h2 id="安装google-chrome浏览器"><a href="#安装google-chrome浏览器" class="headerlink" title="安装google-chrome浏览器"></a>安装google-chrome浏览器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure>


<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure>

<h2 id="markdown编辑器-typora"><a href="#markdown编辑器-typora" class="headerlink" title="markdown编辑器 typora"></a>markdown编辑器 typora</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaourt typora</span><br></pre></td></tr></table></figure>


<h2 id="git客户端-gitkraken"><a href="#git客户端-gitkraken" class="headerlink" title="git客户端 gitkraken"></a>git客户端 gitkraken</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaourt GitKraken</span><br></pre></td></tr></table></figure>


<h2 id="图像编辑器-gimp"><a href="#图像编辑器-gimp" class="headerlink" title="图像编辑器 gimp"></a>图像编辑器 gimp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gimp</span><br></pre></td></tr></table></figure>


<h2 id="PDF阅读器Foxit"><a href="#PDF阅读器Foxit" class="headerlink" title="PDF阅读器Foxit"></a>PDF阅读器Foxit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaourt foxit</span><br></pre></td></tr></table></figure>


<h2 id="截图工具深度截图"><a href="#截图工具深度截图" class="headerlink" title="截图工具深度截图"></a>截图工具深度截图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S deepin-screenshot</span><br></pre></td></tr></table></figure>

<p>配置系统快捷键</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/9e92caf9-c786-46e9-94be-17ef8ccbec46.jpg" alt="9e92caf9-c786-46e9-94be-17ef8ccbec46"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/dac9ea2f-527f-46d9-8fc5-bf8d9fd70273.png" alt="dac9ea2f-527f-46d9-8fc5-bf8d9fd70273"></p>
<h2 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaourt anaconda</span><br><span class="line">source &#x2F;opt&#x2F;anaconda&#x2F;bin&#x2F;active root</span><br></pre></td></tr></table></figure>

<p>添加环境变量<br>    在〜/ .bashrc中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;opt&#x2F;anaconda&#x2F;bin&#x2F;:$PATH</span><br></pre></td></tr></table></figure>


<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="majora-Pacman正在使用"><a href="#majora-Pacman正在使用" class="headerlink" title="majora Pacman正在使用"></a>majora Pacman正在使用</h2><p>解决方法：/var/lib/pacman/db.lck</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf db.lck</span><br></pre></td></tr></table></figure>


<h2 id="搜狗输入法异常！请删除-config-SogouPY-并重启"><a href="#搜狗输入法异常！请删除-config-SogouPY-并重启" class="headerlink" title="搜狗输入法异常！请删除.config/SogouPY 并重启"></a>搜狗输入法异常！请删除.config/SogouPY 并重启</h2><p>sogou-qimpanel</p>
<p>提示找不到libfcitx-qt.so，于是找到原因，安装fcitx-qt4就可以成功解决上述问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaourt -S fcitx-qt4</span><br></pre></td></tr></table></figure>


<h2 id="Manjaro更新后，中文显示为方框"><a href="#Manjaro更新后，中文显示为方框" class="headerlink" title="Manjaro更新后，中文显示为方框"></a>Manjaro更新后，中文显示为方框</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>Playwright</title>
    <url>/2021/03/05/Playwright/</url>
    <content><![CDATA[<h1 id="Playwright"><a href="#Playwright" class="headerlink" title="Playwright"></a>Playwright</h1><p>Playwright是一个强大的Python库，仅用一个API即可自动执行 Chromium 、 Firefox 、 WebKit 等主流浏览器自动化操作，并同时支持以 无头模式 、 有头模式 运行。</p>
<p>Playwright提供的自动化技术是绿色的、功能强大、可靠且快速，支持 Linux 、 Mac 以及 Windows 操作系统。</p>
<p><a href="https://github.com/microsoft/playwright-python" target="_blank" rel="noopener">项目地址</a></p>
<p><a href="https://playwright.dev/python/" target="_blank" rel="noopener">文档地址</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装playwright-python依赖库（需要Python3.7以上）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install playwright</span><br></pre></td></tr></table></figure>

<p>安装主流的浏览器驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m playwright install</span><br></pre></td></tr></table></figure>

<h2 id="录制功能"><a href="#录制功能" class="headerlink" title="录制功能"></a>录制功能</h2><p>这个工具与常用selenium等其他工具的区别，就是其录制功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m playwright codegen --help</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210312092809080.png" alt="image-20210312092809080"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m playwright codegen --target&#x3D;python -o test.py -b chromium https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210312093149634.png" alt="image-20210312093149634"></p>
<p>最终在本地生成test.py文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210312093246755.png" alt="image-20210312093246755"></p>
<p>参考文档：<a href="https://www.bookstack.cn/read/playwright-1.12/e41f24080616ff9c.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/playwright-1.12/e41f24080616ff9c.md</a></p>
<p>Centos依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update nss -y</span><br></pre></td></tr></table></figure>

<p>Ubuntu</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get gconf-service</span><br><span class="line">libasound2</span><br><span class="line">libatk1.0-0</span><br><span class="line">libatk-bridge2.0-0</span><br><span class="line">libc6</span><br><span class="line">libcairo2</span><br><span class="line">libcups2</span><br><span class="line">libdbus-1-3</span><br><span class="line">libexpat1</span><br><span class="line">libfontconfig1</span><br><span class="line">libgcc1</span><br><span class="line">libgconf-2-4</span><br><span class="line">libgdk-pixbuf2.0-0</span><br><span class="line">libglib2.0-0</span><br><span class="line">libgtk-3-0</span><br><span class="line">libnspr4</span><br><span class="line">libpango-1.0-0</span><br><span class="line">libpangocairo-1.0-0</span><br><span class="line">libstdc++6</span><br><span class="line">libx11-6</span><br><span class="line">libx11-xcb1</span><br><span class="line">libxcb1</span><br><span class="line">libxcomposite1</span><br><span class="line">libxcursor1</span><br><span class="line">libxdamage1</span><br><span class="line">libxext6</span><br><span class="line">libxfixes3</span><br><span class="line">libxi6</span><br><span class="line">libxrandr2</span><br><span class="line">libxrender1</span><br><span class="line">libxss1</span><br><span class="line">libxtst6</span><br><span class="line">ca-certificates</span><br><span class="line">fonts-liberation</span><br><span class="line">libappindicator1</span><br><span class="line">libnss3</span><br><span class="line">lsb-release</span><br><span class="line">xdg-utils</span><br><span class="line">wget</span><br><span class="line">libgbm1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2019/11/25/HTML/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>​        HTML 不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。用于按不同标签声明网页中的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/a11y-html-3.png" alt="img"></p>
<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul>
<li>使用小写字线命名文件，不要出现中文字符</li>
<li>扩展名标准是.html，当然也可以使用.htm</li>
<li>多个单词可以使用<code>-</code> 或 <code>_</code> 连接，建议使用<code>-</code> 字符如<code>user-create.html</code></li>
</ul>
<h3 id="语言标签"><a href="#语言标签" class="headerlink" title="语言标签"></a>语言标签</h3><p>​        HTML标签都有具体语义，技术上可以使用div表示大部分内容，单选择清晰的语义标签更容易让人看明白，比如<code>h1</code>表示标题、<code>p</code>表示内容等。</p>
<p><a href="https://www.runoob.com/tags/html-reference.html" target="_blank" rel="noopener">标签大全</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/a11y-html-1-20210121155501763.png" alt></p>
<h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><h4 id="图像格式"><a href="#图像格式" class="headerlink" title="图像格式"></a>图像格式</h4><ul>
<li>网络带宽成本很高，图片处理在保证用户体验好的前提下，文件尺寸也要尽可能小</li>
<li>图片属性静态文件，不要放在WEB服务器上，而放在云储存服务器上并使用CDN加速</li>
<li>以JPEG类型优先使用，文件尺寸更小</li>
<li>小图片使用PNG，清晰度更高，因为文件尺寸小，文件也不会太大</li>
<li>网页图标建议使用css字体构建如 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>或 <a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">fontawesome</a></li>
</ul>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>透明</th>
</tr>
</thead>
<tbody><tr>
<td>PNG</td>
<td>无损压缩格式，适合图标、验证码等。有些小图标建议使用css字体构建</td>
<td>支持</td>
</tr>
<tr>
<td>GIF</td>
<td>256色，可以产生动画效果（即GIF动画）</td>
<td>支持</td>
</tr>
<tr>
<td>JPEG</td>
<td>有损压缩的类型，如商品、文章的图片展示</td>
<td></td>
</tr>
</tbody></table>
<p>使用<code>Photoshop</code> 可以快速生成透明的png的图片效果</p>
<h3 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h3><p>锚点可以设置跳转到页面中的某个部分。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#comment-1"</span>&gt;</span>跳转到评论区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 1000px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"comment-1"</span> <span class="attr">style</span>=<span class="string">"background: green;"</span>&gt;</span></span><br><span class="line">	这是后盾人评论内容区</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过将href和id进行绑定实现</p>
</blockquote>
<p>跳转到不同页面的锚点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;article.html#comment-1&quot;&gt;跳转到评论区&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"文件链接"</span> <span class="attr">download</span>=<span class="string">'下载文件名'</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p><strong>form</strong></p>
<p>一般情况下表单项要放在 FORM 内提交。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:5000/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"pass"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"Button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">name</span>=<span class="string">"Reset"</span> <span class="attr">value</span>=<span class="string">"重填"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>input</strong></p>
<p>文本框用于输入单行文本使用，下面是常用属性与示例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210121151206353.png" alt="image-20210121151206353"></p>
<p>通过设置表单的<code>type</code>字段可以指定不同的输入内容。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>email</td>
<td>输入内容为邮箱</td>
</tr>
<tr>
<td>url</td>
<td>输入内容为URL地址</td>
</tr>
<tr>
<td>password</td>
<td>输入内容为密码项</td>
</tr>
<tr>
<td>tel</td>
<td>电话号，移动端会调出数字键盘</td>
</tr>
<tr>
<td>search</td>
<td>搜索框</td>
</tr>
<tr>
<td>hidden</td>
<td>隐藏表单</td>
</tr>
<tr>
<td>submit</td>
<td>提交表单</td>
</tr>
</tbody></table>
<p><strong>hidden</strong></p>
<p>数据在前台页面不显示，但是数据可以提交到后端。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>禁用表单</strong></p>
<p>通过表单的<code>disable</code>和<code>readonly</code>都可以禁止修改表单，但<code>readonly</code>表单的数据可以提交到后台。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;web&quot; value&#x3D;&quot;houdunren.com&quot; readonly&gt;</span><br></pre></td></tr></table></figure>

<p><strong>pattern</strong></p>
<p>表单可以通过设置<code>pattern</code>属性指定正则验证，也可以使用各种前端验证库和 <a href="http://www.formvalidator.net/#default-validators_custom" target="_blank" rel="noopener">formvalidator</a>或 <a href="https://github.com/validatorjs/validator.js" target="_blank" rel="noopener">validator.js</a>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">pattern</span>=<span class="string">"[A-z]&#123;5,20&#125;"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">oninvalid</span>=<span class="string">"validate('请输入5~20位字母的用户名')"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">(message)</span> </span>&#123;</span></span><br><span class="line">		alert(message);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>textarea</strong></p>
<p>文本域指可以输入多行文本的表单，当然更复杂的情况可以使用编辑器如<code>ueditor、ckeditor</code>等。</p>
<p><strong>select</strong></p>
<p>下拉列表项可用于多个值中的选择。</p>
<p><strong>radio</strong></p>
<p>单选框指只能选择一个选项的表单，如性别的选择<code>男、女、保密</code> 只能选择一个。</p>
<p><strong>checkbox</strong></p>
<p>复选框指允许选择多个值的表单。</p>
<p><strong>文件上传</strong></p>
<p>文件上传有多种方式，可以使用插件或JS拖放上传处理。HTML本身也提供了默认上传的功能，只是上传效果并不是很美观。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"icon"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span> <span class="attr">accept</span>=<span class="string">"image/png,image/gif"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>日期和时间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;date&quot; step&#x3D;&quot;5&quot; min&#x3D;&quot;2020-09-22&quot; max&#x3D;&quot;2025-01-15&quot; name&#x3D;&quot;datetime&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>DATALIST</strong></p>
<p>input表单的输入值选项列表</p>
<p><strong>autocomplete</strong></p>
<p>浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> <span class="attr">name</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h3><h3 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h3><h4 id="什么是搜索引擎？"><a href="#什么是搜索引擎？" class="headerlink" title="什么是搜索引擎？"></a>什么是搜索引擎？</h4><p>​        搜索引擎，通常指搜集了万维网上几千万到几十亿网页并对网页中的每一个词(即关键词)进行索引，建立索引数据库的全文搜索引擎。当用户查找某个关键词的时候，所有在页面内容中板含量该关键词的网页都将被搜出来。在经过复杂的算法进行排序，这些结果将按照与搜索关键词的相关度高低，依次排序。</p>
<p>​        搜索引擎一般包括：搜索器、索引器、检索器、用户接口等四个功能模块。</p>
<ul>
<li>搜索器，也叫网络爬虫，是搜索引擎用来抓取网页的一个自动程序，在系统后台不停歇地在互联网各个节点爬行，在爬行过程中尽可能快的发现和抓取网页。</li>
<li>索引器。它的主要功能是理解搜索器所采集的网页信息，并从中抽取索引项。</li>
<li>检索器。其功能是快速查找文档，进行文档与查询的相关度评价，对要输出的结果进行排序。</li>
<li>用户接口。它为用户提供可视化的查询输入和结果输出的界面。</li>
</ul>
<h4 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h4><p>​        搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果的技术。搜索引擎采用易于被搜索引用的手段，对网站进行有针对性的优化，提高网站在搜索引擎中的自然排名，吸引更多的用户访问网站，提高网站的访问量，提高网站的销售能力和宣传能力，从而提升网站的品牌效应。</p>
<p>优化方法分为<code>黑帽</code>和白帽两大类。</p>
<p><strong>黑帽</strong></p>
<p>​        通常通过作弊手法欺骗搜索引擎和访问者，最终将遭到搜索引擎惩罚的手段被称为黑帽，比如隐藏关键字、制造大量的meta字、alt标签等。</p>
<p>黑帽方法通过欺骗技术和滥用搜索算法来推销毫不相关、主要以商业为着眼的网页。黑帽SEO的主要目的是让网站得到他们所希望的排名进而获得更多的曝光率，这可能导致令普通用户不满的搜索结果。因此搜索引擎一旦发现使用“黑帽”技术的网站，轻则降低其排名，重则从搜索结果中永远剔除该网站。选择黑帽SEO服务的商家，一部分是因为不懂技术，在没有明白SEO价值所在的情况下被服务商欺骗；另一部分则只注重短期利益，存在赚一笔就走人的心态。</p>
<p><strong>白帽</strong></p>
<p>​        通过正规技术和方式，且被搜索引擎所接受的SEO技术。</p>
<p>搜索引擎优化的白帽法遵循搜索引擎的接受原则。他们的建议一般是为用户创造内容、让这些内容易于被搜索引擎机器人索引、并且不会对搜寻引擎系统耍花招。一些网站的员工在设计或构建他们的网站时出现失误以致该网站排名靠后时，白帽法可以发现并纠正错误，譬如机器无法读取的选单、无效链接、临时改变导向、效率低下的索引结构等。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim</title>
    <url>/2019/12/19/Vim/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/vi-vim-cheat-sheet-sch.gif" alt="img"></p>
<p>我的一些配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">syntax on</span><br><span class="line">set number</span><br><span class="line">set norelativenumber</span><br><span class="line">set cursorline</span><br><span class="line">set wrap</span><br><span class="line">set showcmd</span><br><span class="line">set wildmenu</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/12/05/Vue%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-独立版本"><a href="#1-独立版本" class="headerlink" title="1. 独立版本"></a>1. 独立版本</h2><p>在官网下载vue.js，并在<code>&lt;script&gt;</code>标签中应用，开发环境不要使用最小压缩版，不然会没有错误提示和警告。</p>
<h2 id="2-使用CDN"><a href="#2-使用CDN" class="headerlink" title="2. 使用CDN"></a>2. 使用CDN</h2><p>相当于加载网络上独立版本，不需要下载到本地。</p>
<p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p>
<ul>
<li><strong>Staticfile CDN（国内）</strong> : <a href="https://cdn.staticfile.org/vue/2.2.2/vue.min.js" target="_blank" rel="noopener">https://cdn.staticfile.org/vue/2.2.2/vue.min.js</a></li>
<li><strong>unpkg</strong>：<a href="https://unpkg.com/vue/dist/vue.js" target="_blank" rel="noopener">https://unpkg.com/vue/dist/vue.js</a>, 会保持和 npm 发布的最新的版本一致。</li>
<li><strong>cdnjs</strong> : <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</a></li>
</ul>
<h2 id="3-NPM方法"><a href="#3-NPM方法" class="headerlink" title="3. NPM方法"></a>3. NPM方法</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js官网</a>下载并安装node，安装过程很简单，一直点下一步就ok了，安装完之后，我们通过打开命令行工具（win+R）,输入node -v 命令，查看node的版本，若出现相应的版本号，则说明你安装成功了。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/716ae44b-8a77-4cbf-bf86-7ca96efd2b9f.png" alt="img"></p>
<p>npm包管理器，是集成在node中的，所以安装了node也就有了npm,直接输入 npm -v 命令，显示npm的版本信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/d1179368-35b0-4fda-91b7-8a709020e868.png" alt="img"></p>
<p>到目前为止，node的环境已经安装完成，npm 包管理器也有了，由于有些npm资源被屏蔽或者是国外资源的原因，经常会导致npm安装依赖包的时候失败，所以我们还需要npm的国内镜像—-cnpm.</p>
<h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="(1) 方法一"></a><strong>(1) 方法一</strong></h3><p>在用Vue.js构建大型应用的时候推荐使用NPM安装方法，NPM能很好的和诸如<a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a>或者<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify </a>模块打包器配合使用。Vue.js 也提供配套工具来开发单文件组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ npm install vue</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1fc42e00-6663-4141-a0cd-2f0eb466e253.jpg" alt="img"></p>
<h3 id="2-方法二"><a href="#2-方法二" class="headerlink" title="(2) 方法二"></a><strong>(2) 方法二</strong></h3><p>  首先，先列出我们接下来需要的东西：</p>
<ul>
<li>node.js环境（npm包管理器）</li>
<li>vue-cli 脚手架构建工具</li>
<li>cnpm npm的淘宝镜像  </li>
</ul>
<h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p>在命令行中输入npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org然后等待，安装完成如下图。" target="_blank" rel="noopener">http://registry.npm.taobao.org然后等待，安装完成如下图。</a></p>
<p>将npm的仓库地址改为淘宝镜像</p>
<p>也可以使用<a href="https://mirrors.huaweicloud.com/" target="_blank" rel="noopener">华为镜像</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org --global</span><br><span class="line"> </span><br><span class="line">npm config set sass_binary_site https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass&#x2F;  --global</span><br><span class="line"> </span><br><span class="line">npm config set disturl https:&#x2F;&#x2F;npm.taobao.org&#x2F;dist --global</span><br></pre></td></tr></table></figure>

<h3 id="安装vue-cli脚手架构建工具"><a href="#安装vue-cli脚手架构建工具" class="headerlink" title="安装vue-cli脚手架构建工具"></a>安装vue-cli脚手架构建工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装vue-cli 3.xx之前的版本</span><br><span class="line">npm install -g vue-cli</span><br><span class="line"> </span><br><span class="line">卸载vue-cli</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</span><br><span class="line">npm uninstall vue-cli -g</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">npm uninstall vue-cli -g</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#安装最新版本的vue-cli</span><br><span class="line">npm install -g @vue&#x2F;cli</span><br><span class="line"> </span><br><span class="line">#卸载vue-cli</span><br><span class="line">npm uninstall -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>

<p>在桌面目录下，在命令行中运行命令vue init webpack firstVue。解释一下这个命令，这个命令的意思是初始化一个项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中（我的实例中，会在桌面生成该文件夹），如下图。<br><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/a06711f2-b6be-4f66-bd2c-8d6d50764020.jpg" alt="img"></p>
<p>vue项目初始化命令如下，若没有安装webpack，则先安装webpack</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g webpack</span><br><span class="line"> </span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<p>注：安装过程 中有个选项（Use ESLint to line your code ?选择 No ）</p>
<p>进入到myVue目录下，使用npm install 安装package.json包中的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd myVue</span><br><span class="line"> </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>运行项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>Vue样式绑定</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装</title>
    <url>/2016/12/05/centos%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="各种Linux安装步骤"><a href="#各种Linux安装步骤" class="headerlink" title="各种Linux安装步骤"></a>各种Linux安装步骤</h1><h2 id="一、centos最小系统安装后基本配置"><a href="#一、centos最小系统安装后基本配置" class="headerlink" title="一、centos最小系统安装后基本配置"></a>一、centos最小系统安装后基本配置</h2><p>在弹出的“虚拟网络编辑器”窗口中选择NAT模式的，编辑为其分配地址池：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/784924-20170708202419878-583878644.png" alt="img"></p>
<p>由于安装是最小系统，安装后的不能使用网络的需要配置下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure>


<p>修改网卡信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p>将ONBOOT改为yes：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1567432884062.png" alt="img"></p>
<p>重启网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>

<p>ping下百度</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1567432985759.png" alt="img"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda</title>
    <url>/2017/12/05/conda/</url>
    <content><![CDATA[<p>创建环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n &lt;环境名&gt; --no-default-package python=3.7 # 创建一个干净的环境</span><br></pre></td></tr></table></figure>

<p>配置国内镜像：</p>
<p><a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华开源镜像</a></p>
<p>修改用户目录下.condarc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">custom_channels:</span><br><span class="line">  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly主题</title>
    <url>/2019/12/08/butterfly%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p><code>hexo-theme-butterfly</code>是基于<a href="https://github.com/Molunerfinn" target="_blank" rel="noopener">Molunerfinn</a>的<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>的基础上进行开发的。<br>文档也是在<a href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">hexo-theme-melody</a>的文档基础上修改。因为一些配置变更导致与原主题配置上有部分区别。故如果安装<code>hexo-theme-butterfly</code>主题，请参考这篇文档。</p>
<h2 id="主题安装和升级"><a href="#主题安装和升级" class="headerlink" title="主题安装和升级"></a>主题安装和升级</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在你的博客根目录里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly</span><br></pre></td></tr></table></figure>

<p>如果想要安装比较新的dev分支，可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b div https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly</span><br></pre></td></tr></table></figure>

<h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改站点配置文件<code>_config.yml</code>，把主题改为<code>Butterfly</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你没有 pug 以及 stylus 的渲染器，请下载安装： <code>npm install hexo-renderer-jade hexo-renderer-stylus --save</code> or <code>yarn add hexo-renderer-jade hexo-renderer-stylus</code></p>
</blockquote>
<h3 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h3><p>为了主题的平滑升级, <code>Butterfly</code> 使用了 <a href="https://hexo.io/docs/data-files.html" target="_blank" rel="noopener">data files</a>特性。</p>
<p>推荐把主题默认的配置文件<code>_config.yml</code>复制到 Hexo 工作目录下的<code>source/_data/butterfly.yml</code>，如果<code>source/_data</code>的目录不存在那就创建一个。</p>
<blockquote>
<p>注意，如果你创建了<code>butterfly.yml</code>, 它将会替换主题默认配置文件<code>_config.yml</code>里的配置项 (<strong>不是合并而是替换</strong>), 之后你就只需要通过<code>git pull</code>的方式就可以平滑地升级 <code>theme-melody</code>了。</p>
</blockquote>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><ul>
<li>站点配置文件<code>_config.yml</code>是 hexo 工作目录下的主配置文件</li>
<li><code>butterfly.yml</code> 是 <code>Butterfly</code> 的配置文件。它需要你手动将主题目录下的<code>_config.yml</code>文件复制到 hexo 工作目录的<code>source/_data/butterfly.yml</code>中。如果文件或者文件夹不存在，需要手动创建。</li>
</ul>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>修改站点配置文件 <code>_config.yml</code></p>
<p>默认语言是 en</p>
<p>主题支持三种语言</p>
<ul>
<li>default(en)</li>
<li>zh-CN (简体中文)</li>
<li>zh-TW (繁体中文)</li>
</ul>
<h2 id="自定义主题色"><a href="#自定义主题色" class="headerlink" title="自定义主题色"></a>自定义主题色</h2><p>可以修改大部分UI颜色</p>
<p>配置<code>butterfly.yml</code>，比如：</p>
<blockquote>
<p>颜色值必须被双引号包裹，就像<code>&quot;#000&quot;</code>而不是<code>#000</code>。否则将会在构建的时候报错！</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">main:</span> <span class="string">"#9370DB"</span></span><br><span class="line">  <span class="attr">paginator:</span> <span class="string">"#7A7FF1"</span></span><br><span class="line">  <span class="attr">button_hover:</span> <span class="string">"#FF7242"</span></span><br><span class="line">  <span class="attr">text_selection:</span> <span class="string">"#69c46d"</span></span><br><span class="line">  <span class="attr">link_color:</span> <span class="string">"#858585"</span></span><br><span class="line">  <span class="attr">hr_color:</span> <span class="string">"#A4D8FA"</span></span><br><span class="line">  <span class="attr">read-mode-bg_color:</span> <span class="string">'#FAF9DE'</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-color_1.png" alt><br><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-color_2.png" alt></p>
<h2 id="代码高亮主题"><a href="#代码高亮主题" class="headerlink" title="代码高亮主题"></a>代码高亮主题</h2><p><code>Butterfly</code> 支持了 <a href="https://github.com/equinusocio/material-theme" target="_blank" rel="noopener">Material Theme</a>全部 5 种代码高亮样式：</p>
<ul>
<li>default</li>
<li>darker</li>
<li>pale night</li>
<li>light</li>
<li>ocean</li>
</ul>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">light</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>default</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-default.png" alt></p>
<blockquote>
<p>darker</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-darker.png" alt></p>
<blockquote>
<p>pale night</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-pale-night.png" alt></p>
<blockquote>
<p>light</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-light.png" alt></p>
<blockquote>
<p>ocean</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-highlight-ocean.png" alt></p>
<h2 id="代码复制"><a href="#代码复制" class="headerlink" title="代码复制"></a>代码复制</h2><p>主题支持代码复制功能</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-copy.png" alt></p>
<h2 id="代码换行"><a href="#代码换行" class="headerlink" title="代码换行"></a>代码换行</h2><p>在默认情况下，<code>hexo-highlight</code>在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后找到你站点的 Hexo 配置文件<code>_config.yml</code>，将<code>line_number</code>改成<code>false</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置<code>code_word_wrap</code>之前:</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-word-wrap-before.png" alt></p>
<blockquote>
<p>设置<code>code_word_wrap</code>之后:</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-code-word-wrap-after.png" alt></p>
<h2 id="社交图标"><a href="#社交图标" class="headerlink" title="社交图标"></a>社交图标</h2><p>Butterfly支持 <a href="https://fontawesome.com/v4.7.0/" target="_blank" rel="noopener">font-awesome v4</a>和 <a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">font-awesome v5</a>. 如需开启<a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">font-awesome v5</a>,需要在<code>Butterfly.yml</code>上开启</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cdn:</span></span><br><span class="line">  <span class="attr">css:</span></span><br><span class="line">    <span class="attr">fontawesome:</span> <span class="string">https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css</span></span><br><span class="line">    <span class="attr">fontawesomeV5:</span> <span class="string">https://use.fontawesome.com/releases/v5.8.1/css/all.css</span></span><br></pre></td></tr></table></figure>

<p>无论V4还是V5,书写格式都是一样的<code>图标名：url</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fa fa-github:</span> <span class="string">https://github.com/jerryc127</span></span><br><span class="line">  <span class="attr">fa fa-rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure>

<p>图标名可在这寻找</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-fontawesome.png" alt></p>
<p>PC:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-social-icon-pc.png" alt></p>
<p>Mobile:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-socila-icon-mobile.png" alt="1560603353743"></p>
<h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h2><p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/||fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/||fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/||fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/||fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/messageboard/||fa</span> <span class="string">fa-coffee</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/||fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/||fa</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>必须是 <code>/xxx/</code>，后面<code>||</code>分开，然后写图标名。菜单名称可自己修改。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-menu.png" alt></p>
<h2 id="主页文章节选-自动节选和文章页description"><a href="#主页文章节选-自动节选和文章页description" class="headerlink" title="主页文章节选(自动节选和文章页description)"></a>主页文章节选(自动节选和文章页description)</h2><p>因为主题UI的关系，<code>主页文章节选</code>只支持<code>自动节选</code>和<code>文章页description</code>。优先选择<code>自动节选</code>。</p>
<p>在<code>butterfly.yml</code>里可以开启<code>auto_excerpt</code>的选项，你的文章将会在自动截取部分显示在主页。（默认显示150个字）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>如果没有开启<code>自动节选</code>，则会显示文章页front-matter里面设置的<code>description</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-post-description.png" alt></p>
<blockquote>
<p>注意：如果开启了自动节选功能，代码块的显示将有可能不正常。</p>
</blockquote>
<h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p><code>顶部图</code>有2种配置：具体url 和（留空，true和false，三个效果一样）</p>
<h3 id="page页"><a href="#page页" class="headerlink" title="page页"></a>page页</h3><h4 id="当具体url时"><a href="#当具体url时" class="headerlink" title="当具体url时"></a>当具体url时</h4><p>主页的顶部图可以在<code>Butterfly.yml</code>设置<code>top_img</code></p>
<p>archives页的顶部图可以在<code>Butterfly.yml</code>设置<code>archive_img</code></p>
<p>其他<code>page</code>页的顶部图可以在各自的md页面设置<code>front-matter</code>中的<code>top_img</code></p>
<blockquote>
<p>除<code>主页</code>外，其他页面如果没有设置各自的<code>top_img</code>，则会显示与主页同样的<code>top_img</code>图片</p>
</blockquote>
<h4 id="当顶部图留空，true和false"><a href="#当顶部图留空，true和false" class="headerlink" title="当顶部图留空，true和false"></a>当顶部图留空，true和false</h4><p>主页会显示纯颜色的顶部图</p>
<p>其他page的顶部图没有设置时，也会显示纯颜色的顶部图</p>
<h3 id="post页"><a href="#post页" class="headerlink" title="post页"></a>post页</h3><p><code>post</code>页的顶部图会优先显示各自<code>front-matter</code>中的<code>top_img</code>,如果没有设置，则会缩略图（即各自``front-matter<code>中的</code>cover<code>)，如果没有则会显示默认的post顶部图,可在</code>Butterfly.yml<code>设置</code>post_img`</p>
<h2 id="文章相关项"><a href="#文章相关项" class="headerlink" title="文章相关项"></a>文章相关项</h2><p>这个选项是用来显示文章的相关信息的。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment">#or created or updated 文章日期是创建日或者更新日或都显示</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># or false 是否显示分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># or false 是否显示标签</span></span><br></pre></td></tr></table></figure>

<p>在文章顶部的资料，</p>
<p><code>date_type</code>: 可设置文章日期显示创建日期(<code>created</code>)或者更新日期(<code>updated</code>)或者两种都显示(<code>both</code>)</p>
<p><code>categories</code> 是否显示分类</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-post-info.png" alt></p>
<p><code>tags</code>是否显示标签</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-post-tag.png" alt></p>
<h2 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h2><p>为你的博客文章展示文章版权和许可协议。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-copyright.png" alt></p>
<h2 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h2><p>在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">itemlist:</span></span><br><span class="line">        <span class="attr">img:</span> <span class="string">/img/wechat.jpg</span></span><br><span class="line">        <span class="attr">text:</span> <span class="string">微信</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">itemlist:</span></span><br><span class="line">        <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">        <span class="attr">text:</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-post-donate.png" alt></p>
<h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span> <span class="string">https://xxxx/avatar.png</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-avatar.png" alt></p>
<h2 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h2><p>在文章页，会有一个目录，用于显示TOC</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>   <span class="comment">#显示章节数字</span></span><br></pre></td></tr></table></figure>

<h3 id="为特定的文章配置是否显示TOC和特定的目录章节数字"><a href="#为特定的文章配置是否显示TOC和特定的目录章节数字" class="headerlink" title="为特定的文章配置是否显示TOC和特定的目录章节数字"></a>为特定的文章配置是否显示TOC和特定的目录章节数字</h3><p>在你的文章<code>md</code>文件的头部，加入<code>toc_number</code>和<code>toc</code>项，并配置<code>true</code>或者<code>false</code>即可。</p>
<p><code>toc</code>是否显示文章TOC</p>
<p><code>toc_number</code> 是否显示章节数</p>
<p>配置之后你的特定的文章将会拥有它自己的目录数字的显示与否，而不会受全局的配置影响。</p>
<blockquote>
<p><code>enable: true</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-toc-true.png" alt></p>
<blockquote>
<p><code>number: false</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-toc-number-false.png" alt></p>
<h3 id="设置是否自动打开TOC"><a href="#设置是否自动打开TOC" class="headerlink" title="设置是否自动打开TOC"></a>设置是否自动打开TOC</h3><p>可选择进入文章页面时，是否自动打开sidebar显示TOC</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_open_sidebar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="博客年份"><a href="#博客年份" class="headerlink" title="博客年份"></a>博客年份</h2><p><code>since</code>是一个来展示你站点起始时间的选项。它位于页面的最底部。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">since:</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-since.png" alt></p>
<h2 id="页脚自定义文本"><a href="#页脚自定义文本" class="headerlink" title="页脚自定义文本"></a>页脚自定义文本</h2><p><code>footer_custom_text</code>是一个给你用来在页脚自定义文本的选项。通常你可以在这里写声明文本等。支持 HTML。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer_custom_text:</span> <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">&lt;a</span> <span class="string">href="https://jerryc.me/"&gt;blog&lt;/a&gt;!</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-footer-text.png" alt></p>
<h2 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h2><p>对于部分有备案的域名，可以在ICP配置显示。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ICP:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">粤ICP备xxxx</span></span><br></pre></td></tr></table></figure>

<h2 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h2><p>右下角会有夜间模式按钮</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nightshift:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-dark-mode.png" alt></p>
<h2 id="阅读模式"><a href="#阅读模式" class="headerlink" title="阅读模式"></a>阅读模式</h2><p>阅读模式下会去掉除文章外的内容，避免干扰阅读。</p>
<p>只会出现在文章页面，右下角会有阅读模式按钮。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">readmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-read-mode.png" alt></p>
<h2 id="简繁转换"><a href="#简繁转换" class="headerlink" title="简繁转换"></a>简繁转换</h2><p>简体繁体互换</p>
<p>右下角会有简繁转换按钮。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 默认按钮显示文字(网站是简体，应设置为'default: 繁')</span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">简</span></span><br><span class="line">  <span class="comment">#网站默认语言，1: 繁体中文, 2: 简体中文</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment">#延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0</span></span><br><span class="line">  <span class="attr">translateDelay:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">#博客网址</span></span><br><span class="line">  <span class="attr">cookieDomain:</span> <span class="string">"https://jerryc.me/"</span></span><br><span class="line">  <span class="comment">#当文字是简体时，按钮显示的文字</span></span><br><span class="line">  <span class="attr">msgToTraditionalChinese:</span> <span class="string">"繁"</span></span><br><span class="line">  <span class="comment">#当文字是繁体时，按钮显示的文字</span></span><br><span class="line">  <span class="attr">msgToSimplifiedChinese:</span> <span class="string">"简"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>简体</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-simp.png" alt></p>
<blockquote>
<p>繁体</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-tranditional.png" alt></p>
<h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>网页已运行时间</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">start_date:</span> <span class="number">6</span><span class="string">/7/2018</span> <span class="number">00</span><span class="string">:00:00</span>  </span><br><span class="line">  <span class="comment">##网页开通时间</span></span><br><span class="line">  <span class="comment">#格式: 月/日/年 时间</span></span><br><span class="line">  <span class="comment">#也可以写成 年/月/日 时间</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-runtime.png" alt></p>
<h2 id="侧边排版"><a href="#侧边排版" class="headerlink" title="侧边排版"></a>侧边排版</h2><p>可自行决定哪个项目需要显示</p>
<blockquote>
<p>至少需要显示一个</p>
</blockquote>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">card_author:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_announcement:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_recent_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_categories:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_tags:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_archives:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_webinfo:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>相关文章推荐的原理是根据文章tags的比重来推荐</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-relatedpost.png" alt></p>
<h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h2><p>可自行设置字体的<code>font-family</code></p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">Lato,</span> <span class="string">Helvetica</span> <span class="string">Neue</span> <span class="string">For</span> <span class="string">Number,</span> <span class="string">-apple-system,</span> <span class="string">BlinkMacSystemFont,</span> <span class="string">Segoe</span> <span class="string">UI,</span> <span class="string">Roboto,</span> <span class="string">PingFang</span> <span class="string">SC,</span> <span class="string">Hiragino</span> <span class="string">Sans</span> <span class="string">GB,"Microsoft</span> <span class="string">JhengHei",</span> <span class="string">"MicrMicrosoft YaHei"</span><span class="string">,</span> <span class="string">Helvetica</span> <span class="string">Neue,</span> <span class="string">Helvetica,</span> <span class="string">Arial,</span> <span class="string">sans-serif</span></span><br><span class="line">  <span class="attr">code-font:</span> <span class="string">consolas,</span> <span class="string">Menlo,</span> <span class="string">"PingFang SC"</span><span class="string">,</span> <span class="string">"Microsoft JhengHei"</span><span class="string">,"Microsoft</span> <span class="string">YaHei",</span> <span class="string">monospace,</span> <span class="string">Helvetica</span> <span class="string">Neue</span> <span class="string">For</span> <span class="string">Number</span></span><br></pre></td></tr></table></figure>

<h2 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h2><p>可设置主页中显示的网站副标题或者喜欢的座右铭。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subtitle:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sub1:</span> <span class="string">今日事,今日毕</span></span><br><span class="line">  <span class="attr">sub2:</span> <span class="string">Never</span> <span class="string">put</span> <span class="string">off</span> <span class="string">till</span> <span class="string">tomorrow</span> <span class="string">what</span> <span class="string">you</span> <span class="string">can</span> <span class="string">do</span> <span class="string">today</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-index-subtitle.gif" alt></p>
<h1 id="主题页面"><a href="#主题页面" class="headerlink" title="主题页面"></a>主题页面</h1><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">type: （tags,link,categories这三个页面需要配置）</span><br><span class="line">comments: (是否需要显示评论，默认true)</span><br><span class="line">description:</span><br><span class="line">top_img: (设置顶部图)</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img: （除非特定需要，可以不写）</span><br><span class="line">comments  是否显示评论（除非设置false,可以不写）</span><br><span class="line">cover:  缩略图</span><br><span class="line">toc:  是否显示toc （除非特定文章设置，可以不写）</span><br><span class="line">toc_number: 是否显示toc数字 （除非特定文章设置，可以不写）</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><ol>
<li><p>前往你的 Hexo 博客的根目录</p>
</li>
<li><p>输入<code>hexo new page tags</code></p>
</li>
<li><p>你会找到<code>source/tags/index.md</code>这个文件</p>
</li>
<li><p>修改这个文件：</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ol>
<li><p>前往你的 Hexo 博客的根目录</p>
</li>
<li><p>输入<code>hexo new page categories</code></p>
</li>
<li><p>你会找到<code>source/categories/index.md</code>这个文件</p>
</li>
<li><p>修改这个文件：</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: "categories"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h2><p>为你的博客创建一个相册页！</p>
<h3 id="创建相册页"><a href="#创建相册页" class="headerlink" title="创建相册页"></a>创建相册页</h3><ol>
<li><p>前往你的 Hexo 博客的根目录</p>
</li>
<li><p>输入<code>hexo new page gallery</code></p>
</li>
<li><p>你会找到<code>source/gallery/index.md</code>这个文件</p>
</li>
<li><p>修改这个文件：</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: "gallery"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>Butterfly 提供了一个叫做<code>gallery</code>的标签，让你能够在 markdown 文件里生成<code>gallery-item</code>。</p>
<p>修改你刚刚创建的<code>source/gallery/index.md</code>，并加上<code>gallery</code> 标签。</p>
<p><code>gallery img-url [title]</code></p>
<p>例子:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: "gallery"</span><br><span class="line">---</span><br><span class="line">&#123;% gallery https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse melody %&#125;</span><br><span class="line">&#123;% gallery https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png background %&#125;</span><br><span class="line">&#123;% gallery https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b demo1 %&#125;</span><br><span class="line">&#123;% gallery https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq demo2 %&#125;</span><br><span class="line">&#123;% gallery https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic demo3 %&#125;</span><br><span class="line">&#123;% gallery https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd %&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gallery-item 也拥有 fancybox 的效果!</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-gallery.png" alt></p>
<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>为你的博客创建一个友情链接！</p>
<h3 id="创建友情链接页面"><a href="#创建友情链接页面" class="headerlink" title="创建友情链接页面"></a>创建友情链接页面</h3><ol>
<li>前往你的 Hexo 博客的根目录</li>
<li>输入 <code>hexo new page link</code></li>
<li>你会找到<code>source/link/index.md</code>这个文件</li>
<li>修改这个文件：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2018-06-07 22:17:49</span><br><span class="line">type: "link"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a>友情链接添加</h3><p>在Hexo博客目录中的<code>source/_data</code>，创建一个文件<code>link.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">class:</span></span><br><span class="line">  <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="attr">1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://blog.xxx.com</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://cdn.xxxxx.top/avatar.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">xxxxxxx</span></span><br><span class="line">    <span class="attr">2:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">xxxxxx</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.xxxxxxcn/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://xxxxx/avatar.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">xxxxxxx</span>  </span><br><span class="line"></span><br><span class="line"> <span class="attr">class2:</span></span><br><span class="line">   <span class="attr">class_name:</span> <span class="string">链接无效</span></span><br><span class="line">   <span class="attr">link_list:</span></span><br><span class="line">     <span class="attr">1:</span></span><br><span class="line">       <span class="attr">name:</span> <span class="string">梦xxx</span></span><br><span class="line">       <span class="attr">link:</span> <span class="string">https://blog.xxx.com</span></span><br><span class="line">       <span class="attr">avatar:</span> <span class="string">https://xxxx/avatar.png</span></span><br><span class="line">       <span class="attr">descr:</span> <span class="string">xxxx</span></span><br><span class="line">     <span class="attr">2:</span></span><br><span class="line">       <span class="attr">name:</span> <span class="string">xx</span></span><br><span class="line">       <span class="attr">link:</span> <span class="string">https://www.axxxx.cn/</span></span><br><span class="line">       <span class="attr">avatar:</span> <span class="string">https://x</span></span><br><span class="line">       <span class="attr">descr:</span> <span class="string">xx</span></span><br></pre></td></tr></table></figure>

<h3 id="友情链接界面设置"><a href="#友情链接界面设置" class="headerlink" title="友情链接界面设置"></a>友情链接界面设置</h3><p>需要添加友情链接，可以在<code>Butterfly.yml</code>配置<br>可在友情链接上写上自己的个人资料，方便其他人添加。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Flink:</span></span><br><span class="line">  <span class="attr">headline:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">info_headline:</span> <span class="string">我的Blog资料</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Blog</span> <span class="string">名字：</span> <span class="string">JerryC</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Blog</span> <span class="string">地址：</span> <span class="string">https://jerryc.me/</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">Blog</span> <span class="string">头像：</span> <span class="string">https://jerryc.me/img/avatar.png</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">Blog</span> <span class="string">简介：</span> <span class="string">今日事,今日毕</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">如果需要交换友链,请留言</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-flink-headline.png" alt><br><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-flink.png" alt></p>
<h1 id="第三方支持"><a href="#第三方支持" class="headerlink" title="第三方支持"></a>第三方支持</h1><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><blockquote>
<p>只能选择一个评论服务商</p>
</blockquote>
<h3 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h3><p>注册 <a href="https://disqus.com/" target="_blank" rel="noopener">disqus</a>，配置你自己的 disqus，然后在<code>Butterfly</code>里开启它。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># or false</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">你的disqus的</span> <span class="string">short-name</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-disqus.png" alt></p>
<h3 id="Laibili（来必力）"><a href="#Laibili（来必力）" class="headerlink" title="Laibili（来必力）"></a>Laibili（来必力）</h3><p>注册<a href="http://www.laibili.com.cn/" target="_blank" rel="noopener">来必力</a>，配置你自己的来必力设置，然后在<code>Butterfly</code>里开启它。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">laibili:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># or false</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">你的laibili的uid</span></span><br></pre></td></tr></table></figure>

<p>laibili 的 uid 你能在这里找到:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-laibili.jpg" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-laibili_2.png" alt></p>
<h3 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h3><p>遵循 <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>的指示去获取你的 github Oauth 应用的 client id 和 secret 值。</p>
<p>然后配置<code>butterfly.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># or false</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">你的github用户名</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">你的github仓库</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">你的client</span> <span class="string">id</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">你的client</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-gitment.png" alt></p>
<h3 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h3><p>遵循 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>的指示去获取你的 github Oauth 应用的 client id 和 secret 值。以及查看它的相关配置说明。</p>
<p>然后配置<code>butterfly.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">你的client</span> <span class="string">id</span> </span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">你的client</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">你的github仓库</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">你的github用户名</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">该仓库的拥有者或协作者</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-gitalk.png" alt></p>
<h3 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h3><p>遵循 <a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">Valine</a>的指示去配置你的 LeanCloud 应用。以及查看相应的配置说明。</p>
<p>然后配置<code>butterfly.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appId:</span>   <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span>   <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># valine mail notify (true/false) https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># valine verify code (true/false)</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">en</span> <span class="comment"># i18n: zh-cn/en/tw</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Please</span> <span class="string">leave</span> <span class="string">your</span> <span class="string">footprints</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header inf</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-valine.png" alt></p>
<h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><blockquote>
<p>只能选择一个分享服务商</p>
</blockquote>
<h3 id="AddThis"><a href="#AddThis" class="headerlink" title="AddThis"></a>AddThis</h3><blockquote>
<p>找到你的 pub-id</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-addthis.jpg" alt></p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">addThis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># or false</span></span><br><span class="line">  <span class="attr">pubid:</span> <span class="string">你的pub-id</span></span><br></pre></td></tr></table></figure>

<h3 id="Sharejs"><a href="#Sharejs" class="headerlink" title="Sharejs"></a>Sharejs</h3><p>如果你不知道 <a href="https://github.com/overtrue/share.js/" target="_blank" rel="noopener">sharejs</a>，看看它的说明。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sites:</span> <span class="string">facebook,twitter,wechat,weibo,qq</span>  <span class="comment">#想要显示的内容</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-sharejs.png" alt></p>
<h3 id="Addtoany"><a href="#Addtoany" class="headerlink" title="Addtoany"></a>Addtoany</h3><p>可以到<a href="https://www.addtoany.com/" target="_blank" rel="noopener">addtoany</a>查看使用说明</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">addtoany:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">item:</span>   <span class="comment"># 显示的内容</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">facebook</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">twitter</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">wechat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sina_weibo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">facebook_messenger</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">email</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">copy_link</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-addtoany.png" alt></p>
<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><h3 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h3><ol>
<li><p>你需要安装 <a href="https://github.com/oncletom/hexo-algolia" target="_blank" rel="noopener">hexo-algolia</a>或 <a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch" target="_blank" rel="noopener">hexo-algoliasearch</a>. 根据它们的说明文档去做相应的配置。</p>
</li>
<li><p>配置<code>butterfly.yml</code></p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span> <span class="comment"># if there are no result</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure>

<h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><ol>
<li><p>你需要安装 <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>. 根据它的文档去做相应配置。<strong>注意格式只支持 xml</strong>。</p>
</li>
<li><p>配置<code>butterfly.yml</code></p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span> <span class="comment"># if there are no result</span></span><br></pre></td></tr></table></figure>

<h2 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h2><p>如果需要搜索引擎收录网站，可能需要登录对应搜索引擎的管理平台进行提交。<br>各自的验证码可从各自管理平台拿到</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="attr">google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster/</span></span><br><span class="line"><span class="attr">bing_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru/</span></span><br><span class="line"><span class="attr">yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://ziyuan.baidu.com/site/</span></span><br><span class="line"><span class="attr">baidu_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 360 Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># see http://zhanzhang.so.com/</span></span><br><span class="line"><span class="attr">qihu_site_verification:</span></span><br></pre></td></tr></table></figure>

<h2 id="分析统计"><a href="#分析统计" class="headerlink" title="分析统计"></a>分析统计</h2><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><ol>
<li><p>登录百度统计的<a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">官方网站</a></p>
</li>
<li><p>找到你百度统计的统计代码</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-baidu-tongji.jpg" alt></p>
<p>3. 配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">你的代码</span></span><br></pre></td></tr></table></figure>

<h3 id="谷歌分析"><a href="#谷歌分析" class="headerlink" title="谷歌分析"></a>谷歌分析</h3><ol>
<li><p>登录谷歌分析的<a href="https://www.google.com/analytics/" target="_blank" rel="noopener">官方网站</a></p>
</li>
<li><p>找到你的谷歌分析的跟踪 ID</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-google-analytics.jpg" alt></p>
<ol start="3">
<li>配置<code>butterfly.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">google_analytics:</span> <span class="string">你的代码</span> <span class="comment"># 通常以`UA-`打头</span></span><br></pre></td></tr></table></figure>

<h2 id="访问人数-UV-和-PV"><a href="#访问人数-UV-和-PV" class="headerlink" title="访问人数 (UV 和 PV)"></a>访问人数 (UV 和 PV)</h2><h3 id="busuanzi"><a href="#busuanzi" class="headerlink" title="busuanzi"></a>busuanzi</h3><p>访问 busuanzi 的<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">官方网站</a>查看更多的介绍。</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-busuanzi-site-pv.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-pv.png" alt></p>
<h2 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h2><blockquote>
<p>建议使用 KaTex 获得更好的效果，下文有介绍！</p>
</blockquote>
<p>配置<code>butterfly.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># or false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span> <span class="comment"># required</span></span><br></pre></td></tr></table></figure>

<p>然后你需要修改一下默认的<code>markdown</code>渲染引擎来实现 MathJax 的效果。</p>
<p>查看: <a href="https://www.npmjs.com/package/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a></p>
<p>以下操作在你 hexo 博客的目录下 (<strong>不是 Butterfly 的目录!</strong>):</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-mathjax-20201222194744193.png" alt></p>
<p>效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-mathjax-2.jpg" alt></p>
<h2 id="KaTeX"><a href="#KaTeX" class="headerlink" title="KaTeX"></a>KaTeX</h2><p>首先禁用<code>MathJax</code>（如果你配置过 MathJax 的话），然后修改你的<code>butterfly.yml</code>以便加载<code>katex.min.css</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css</span></span><br></pre></td></tr></table></figure>

<p>你不需要添加<code>katex.min.js</code>来渲染数学方程。相应的你需要卸载你之前的 hexo 的 markdown 渲染器以及<code>hexo-math</code>，然后安装新的<code>hexo-renderer-markdown-it-plus</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换 `hexo-renderer-kramed` 或者 `hexo-renderer-marked` 等hexo的markdown渲染器</span></span><br><span class="line"><span class="comment"># 你可以在你的package.json里找到hexo的markdwon渲染器，并将其卸载</span></span><br><span class="line"><span class="string">npm</span> <span class="string">un</span> <span class="string">hexo-renderer-marked</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line"><span class="string">npm</span> <span class="string">un</span> <span class="string">hexo-renderer-kramed</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载 `hexo-math`</span></span><br><span class="line"><span class="string">npm</span> <span class="string">un</span> <span class="string">hexo-math</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后安装 `hexo-renderer-markdown-it-plus`</span></span><br><span class="line"><span class="string">npm</span> <span class="string">i</span> <span class="string">@upupming/hexo-renderer-markdown-it-plus</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>

<p>注意到 <a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener"><code>hexo-renderer-markdown-it-plus</code></a>已经无人持续维护, 所以我们使用 <a href="https://github.com/upupming/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener"><code>@upupming/hexo-renderer-markdown-it-plus</code></a>。 这份 fork 的代码使用了 <a href="https://github.com/yzhang-gh/markdown-it-katex" target="_blank" rel="noopener"><code>@neilsustc/markdown-it-katex</code></a>同时它也是 VSCode 的插件 <a href="https://github.com/yzhang-gh/vscode-markdown" target="_blank" rel="noopener">Markdown All in One</a>所使用的, 所以我们可以获得最新的 KaTex 功能例如 <code>\tag{}</code>。</p>
<p>你还可以通过 <a href="https://github.com/yzhang-gh/markdown-it-katex" target="_blank" rel="noopener"><code>@neilsustc/markdown-it-katex</code></a>控制 KaTeX 的设置，所有可配置的选项参见 <a href="https://katex.org/docs/options.html。" target="_blank" rel="noopener">https://katex.org/docs/options.html。</a> 比如你想要禁用掉 KaTeX 在命令行上输出的冗长的警告信息，你可以在根目录的 <code>_config.yml</code> 中使用下面的配置将 <code>strict</code> 设置为 false:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown_it_plus:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">'@neilsustc/markdown-it-katex'</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">strict:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>当然，你还可以利用这个特性来定义一些自己常用的 <code>macros</code>。</p>
<p>因为 KaTeX 更快更轻量，因此没有 MathJax 的功能多（比如右键菜单）。为那些使用 MathJax 的用户，我们也为 KaTeX 默认添加了 <a href="https://github.com/upupming/katex-copytex" target="_blank" rel="noopener"><em>Copy As TeX Code</em></a>的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-katex.gif" alt></p>
<h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><h3 id="打字效果"><a href="#打字效果" class="headerlink" title="打字效果"></a>打字效果</h3><p>打字效果<a href="https://github.com/disjukr/activate-power-mode" target="_blank" rel="noopener">activate-power-mode</a></p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-type-animation.gif" alt></p>
<h3 id="静止彩带"><a href="#静止彩带" class="headerlink" title="静止彩带"></a>静止彩带</h3><p>好看的彩带背景，可设置每次刷新更换彩带，或者每次点击更换彩带</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">false</span>  <span class="comment">#设置是否每次点击都更换彩带</span></span><br></pre></td></tr></table></figure>

<p>相关配置可查看<a href="https://github.com/hustcc/ribbon.js" target="_blank" rel="noopener">canvas_ribbon</a></p>
<h3 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a>动态彩带</h3><p>好看的彩带背景，会飘动</p>
<p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon_piao:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-canvas-ribbon-piao.gif" alt></p>
<h3 id="烟花效果"><a href="#烟花效果" class="headerlink" title="烟花效果"></a>烟花效果</h3><p>配置<code>butterfly.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fireworks:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-firewall.gif" alt></p>
<h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>要为<code>Butterfly</code>配上 PWA 特性, 你需要如下几个步骤:</p>
<ol>
<li><p>打开 hexo 工作目录</p>
</li>
<li><p><code>npm install hexo-offline --save</code> 或者 <code>yarn add hexo-offline</code></p>
</li>
<li><p>修改<code>_config.yml</code> 在站点<code>_config.yml</code>中增加以下内容。</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># offline config passed to sw-precache.</span></span><br><span class="line"><span class="attr">offline:</span></span><br><span class="line">  <span class="attr">maximumFileSizeToCacheInBytes:</span> <span class="number">10485760</span> <span class="comment"># 缓存的最大文件大小，以字节为单位</span></span><br><span class="line">  <span class="attr">staticFileGlobs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">public/**/*.&#123;js,html,css,png,jpg,gif,svg,webp,eot,ttf,woff,woff2&#125;</span></span><br><span class="line">  <span class="comment"># 静态文件合集，如果你的站点使用了例如webp格式的文件，请将文件类型添加进去。</span></span><br><span class="line">  <span class="attr">stripPrefix:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">verbose:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">runtimeCaching:</span></span><br><span class="line">    <span class="comment"># CDNs - should be cacheFirst, since they should be used specific versions so should not change</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">urlPattern:</span> <span class="string">/*</span> <span class="comment"># 如果你需要加载CDN资源，请配置该选项，如果没有，可以不配置。</span></span><br><span class="line">      <span class="attr">handler:</span> <span class="string">cacheFirst</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">origin:</span> <span class="string">your_websie_url</span> <span class="comment"># 可替换成你的 url</span></span><br></pre></td></tr></table></figure>

<p>更多内容请查看 <a href="https://github.com/JLHwung/hexo-offline" target="_blank" rel="noopener">hexo-offline</a>的官方文档</p>
<ol start="4">
<li>在<code>butterfly.yml</code>中开启 pwa 选项。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pwa:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">manifest:</span> <span class="string">/img/pwa/manifest.json</span></span><br><span class="line">  <span class="attr">theme_color:</span> <span class="string">"#fff"</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/img/pwa/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">favicon_32_32:</span> <span class="string">/img/pwa/32.png</span></span><br><span class="line">  <span class="attr">favicon_16_16:</span> <span class="string">/img/pwa/16.png</span></span><br><span class="line">  <span class="attr">mask_icon:</span> <span class="string">/img/pwa/safari-pinned-tab.svg</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在创建<code>source/</code>目录中创建<code>manifest.json</code>文件。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"string"</span>, <span class="comment">//应用全称</span></span><br><span class="line">    <span class="attr">"short_name"</span>: <span class="string">"Junzhou"</span>, <span class="comment">//应用简称</span></span><br><span class="line">    <span class="attr">"theme_color"</span>: <span class="string">"#49b1f5"</span>, <span class="comment">//匹配浏览器的地址栏颜色</span></span><br><span class="line">    <span class="attr">"background_color"</span>: <span class="string">"#49b1f5"</span>,<span class="comment">//加载应用时的背景色</span></span><br><span class="line">    <span class="attr">"display"</span>: <span class="string">"standalone"</span>,<span class="comment">//首选显示模式 其他选项有：fullscreen,minimal-ui,browser</span></span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"/"</span>,</span><br><span class="line">    <span class="attr">"start_url"</span>: <span class="string">"/"</span>,</span><br><span class="line">    <span class="attr">"icons"</span>: [ <span class="comment">//该数组指定icons图标参数，用来时适配不同设备（需为png，至少包含一个192px*192px的图标）</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"src"</span>: <span class="string">"images/pwaicons/36.png"</span>, <span class="comment">//图标文件的目录，需在source/目录下自行创建。</span></span><br><span class="line">          <span class="attr">"sizes"</span>: <span class="string">"36x36"</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span>: <span class="string">"images/pwaicons/48.png"</span>,</span><br><span class="line">          <span class="attr">"sizes"</span>: <span class="string">"48x48"</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"src"</span>: <span class="string">"images/pwaicons/72.png"</span>,</span><br><span class="line">          <span class="attr">"sizes"</span>: <span class="string">"72x72"</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"src"</span>: <span class="string">"images/pwaicons/96.png"</span>,</span><br><span class="line">          <span class="attr">"sizes"</span>: <span class="string">"96x96"</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"src"</span>: <span class="string">"images/pwaicons/144.png"</span>,</span><br><span class="line">          <span class="attr">"sizes"</span>: <span class="string">"144x144"</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"src"</span>: <span class="string">"images/pwaicons/192.png"</span>,</span><br><span class="line">          <span class="attr">"sizes"</span>: <span class="string">"192x192"</span>,</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span>: <span class="string">"images/pwaicons/512.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span>: <span class="string">"512x512"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"splash_pages"</span>: <span class="literal">null</span> <span class="comment">//配置自定义启动动画。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>你也可以通过 <a href="https://app-manifest.firebaseapp.com/" target="_blank" rel="noopener">Web App Manifest</a>快速创建<code>manifest.json</code>。（Web App Manifest 要求至少包含一个 512*512 像素的图标）</p>
<ol start="6">
<li>可以通过<code>Chrome</code>插件<code>Lighthouse</code>检查 PWA 配置是否生效以及配置是否正确。</li>
</ol>
<ul>
<li>打开博客页面</li>
<li>启动<code>Lighthouse</code>插件 (<code>Lighthouse</code>插件要求至少包含一个 512*512 像素的图标)</li>
</ul>
<p>关于 PWA（渐进式增强 Web 应用）的更多内容请参阅 <a href="https://developers.google.com/web/tools/lighthouse/audits/address-bar" target="_blank" rel="noopener">Google Tools for Web Developers</a></p>
<h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>要为<code>Butterfly</code>配上字数统计特性, 你需要如下几个步骤:</p>
<ol>
<li><p>打开 hexo 工作目录</p>
</li>
<li><p><code>npm install hexo-wordcount --save</code> or <code>yarn add hexo-wordcount</code></p>
</li>
<li><p>配置<code>butterfly.yml</code>:</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/hexo-theme-butterfly-doc-word-count.png" alt></p>
<h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>要为你一些文章置顶，你需要如下步骤:</p>
<ol>
<li>打开 hexo 工作目录</li>
<li><code>npm uninstall hexo-generator-index --save</code> 然后 <code>npm install hexo-generator-index-pin-top --save</code></li>
<li>你要在文章的<code>front-matter</code>区域里添加<code>top: True</code>属性来把这篇文章置顶。</li>
<li>你可以参考 <a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">hexo-generator-index-pin-top</a>这个仓库来了解更多细节。</li>
</ol>
<p>举个例子:</p>
<p>你的某篇文章开头如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: xxxx</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  - </span>xxx</span><br><span class="line">date: 2018-08-08 08:08:08</span><br><span class="line">---</span><br><span class="line">// ....</span><br></pre></td></tr></table></figure>

<p>现在把<code>top: True</code>加进去：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: xxxx</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  - </span>xxx</span><br><span class="line">date: 2018-08-08 08:08:08</span><br><span class="line">top: True</span><br><span class="line">---</span><br><span class="line">// ....</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/2017/12/08/cmake/</url>
    <content><![CDATA[<p>指定cmake的最小版本</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>设置项目名称</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(demo)</span><br></pre></td></tr></table></figure>

<p>定义变量或者为变量赋值</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(haha <span class="string">"xxx"</span>) <span class="comment"># 这个是自定义变量</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)    <span class="comment"># 这个为CMAKE_CXX_STANDARD赋值</span></span><br></pre></td></tr></table></figure>

<p>设置编译输出</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(demo demo.cpp) <span class="comment"># 生成可执行文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(common STATIC util.cpp) <span class="comment"># 生成静态库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(common SHARED util.cpp) <span class="comment"># 生成动态库或共享库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(&lt;指定一个目录&gt; &lt;指定目录存放输出文件&gt;)</span><br></pre></td></tr></table></figure>

<p>搜索cpp文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(dir VAR)</span><br></pre></td></tr></table></figure>

<p>为目标文件链接依赖的库</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; &lt;lib&gt;)</span><br></pre></td></tr></table></figure>

<p>指定目录添加到编译器的头文件搜索路劲之下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(&lt;指定目录&gt;)</span><br></pre></td></tr></table></figure>

<p>从指定的文件加载、运行CMake代码</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(&lt;<span class="keyword">file</span>|moudle&gt;)</span><br></pre></td></tr></table></figure>

<p>在编译目标文件<target>时指定头文件</target></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; &lt;头文件目录&gt;)</span><br></pre></td></tr></table></figure>

<p>为链接器添加库的搜索路径</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(路径)</span><br></pre></td></tr></table></figure>

<p>加载外部库到项目中</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>()</span><br></pre></td></tr></table></figure>



<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>PUBLIC: 修饰的库或者目标会被链接，并成为链接接口的一部分</p>
<p>PRIVATE: 修饰的目标或库会被链接，但不能链接接口的一部分</p>
<p>INTERFACE: 修饰的库会被追加到链接接口中，但不会用来链接目标文件<target></target></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd命令</title>
    <url>/2017/12/05/cmd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>刷新dns：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab定时任务</title>
    <url>/2020/12/24/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><blockquote>
<p>crond 和crontab是不可分割的。crontab是一个命令，常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语chronos(χρόνος)，原意是时间。</p>
<p>而crond正是它的守护进程。cron服务是一个定时执行的服务，可以通过crontab 命令添加或者编辑需要定时执行的任务。</p>
</blockquote>
<h2 id="crontab操作"><a href="#crontab操作" class="headerlink" title="crontab操作"></a>crontab操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -u &#x2F;&#x2F;设定某个用户的cron服务</span><br><span class="line">crontab -l &#x2F;&#x2F;列出某个用户cron服务的详细内容</span><br><span class="line">crontab -r &#x2F;&#x2F;删除某个用户的cron服务</span><br><span class="line">crontab -e &#x2F;&#x2F;编辑某个用户的cron服务</span><br><span class="line">crontab -i &#x2F;&#x2F;打印提示，输入yes等确认信息</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1461714-20181016024833855-614863675.png" alt="1461714-20181016024833855-614863675"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>每一分钟执行一次 /bin/ls</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * &#x2F;bin&#x2F;ls</span><br></pre></td></tr></table></figure>

<p>每小时的第3和第15分钟执行command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 * * * * command</span><br></pre></td></tr></table></figure>

<p>每天上午8-11点的第3和15分钟执行command：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * * command</span><br></pre></td></tr></table></figure>

<p>每隔2天的上午8-11点的第3和15分钟执行command：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 8-11 *&#x2F;2 * * command</span><br></pre></td></tr></table></figure>

<p>每个星期一的上午8点到11点的第3和第15分钟执行command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * 1 command</span><br></pre></td></tr></table></figure>

<p>每晚的21:30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 21 * * * command</span><br></pre></td></tr></table></figure>

<p>每月1、10、22日的4 : 45</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">45 4 1,10,22 * * command</span><br></pre></td></tr></table></figure>



















]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2017/02/16/docker/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>windows安装docker</p>
<p>使用阿里云镜像来下载 <a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a> </p>
<p>centos安装docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker docker-common docker-selinux docker-engine</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo https://repo.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo sed -i 's+download.docker.com+repo.huaweicloud.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<p>配置阿里云镜像加速器</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200929204854511.png" alt="image-20200929204854511"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动镜像</span><br><span class="line">server docker start</span><br><span class="line"></span><br><span class="line">server docker restart</span><br></pre></td></tr></table></figure>



<p>测试hello-world</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><code>hello-world</code>其实就是镜像容器，本地没有hello-world镜像，就会去云上下载hello-world镜像</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>

<p>镜像命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images	#列出本地镜像信息</span><br><span class="line">docker search	#查询镜像</span><br><span class="line">docker pull		#获取镜像</span><br><span class="line">docker rmi		#删除某个镜像</span><br><span class="line">docker rmi -f $(docker images -qa) # 删除所有镜像</span><br></pre></td></tr></table></figure>

<p>容器命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run [options] </span><br><span class="line"></span><br><span class="line">docker ps # 列出docker所有容器</span><br><span class="line"></span><br><span class="line"># 退出容器</span><br><span class="line">exit # 容器停止退出</span><br><span class="line">ctrl + p + q 	#容器不停止退出</span><br><span class="line"></span><br><span class="line">docker start + 容器id		#启动容器</span><br><span class="line">dokcer stop + 容器id		#停止容器</span><br><span class="line"></span><br><span class="line">docker kill + 容器id		#强制停止容器</span><br><span class="line"></span><br><span class="line">docker rm + 容器id		# 删除已经停止的容器</span><br><span class="line">docker rm -f $(docker ps -a -q)	# 一次性删除多个容器</span><br><span class="line">docker ps -a -q | xargs docker rm  # 一次性删除多个容器</span><br></pre></td></tr></table></figure>

<p>重要命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d 容器名 # 以守护方式运行容器	在docker ps中看不到</span><br><span class="line">docker logs -f -t --tail 容器id 	#查看容器日志</span><br><span class="line">docker top 容器id		#查看容器内运行的进程</span><br><span class="line">docker inspect	#容器id</span><br><span class="line"># 进入正在运行的容器</span><br><span class="line">docker exec -it 容器id bashshell # 不进入容器，但是返回容器的执行shell的结果</span><br><span class="line">docker exec -it 容器id &#x2F;bin&#x2F;bash # 进入容器中</span><br><span class="line">docker attach + 容器id	# 直接进入容器，入会启动新的进程</span><br><span class="line"></span><br><span class="line"># 从容器内拷贝文件到主机上</span><br><span class="line">docker  cp 容器id:目录 当前用户路径</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/11/24/css/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><blockquote>
<p>层叠样式表(Cascading Style Sheets)，样式定义如何显示html</p>
</blockquote>
<p>如何使用CSS？</p>
<h2 id="外部引用"><a href="#外部引用" class="headerlink" title="外部引用"></a>外部引用</h2><p>在头部中使用link标签引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"xx.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>xx.css</code> 表示样式文件路径</p>
<h2 id="嵌入样式"><a href="#嵌入样式" class="headerlink" title="嵌入样式"></a>嵌入样式</h2><blockquote>
<p>使用<code>&lt;style&gt;</code>标签引用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">	background-color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h2><p>在标签中使用style属性可以定义样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p style&#x3D;&quot;color:blue&quot;&gt;你好&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="导入样式"><a href="#导入样式" class="headerlink" title="导入样式"></a>导入样式</h3><p>两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;xx.css&quot;</span><br><span class="line">@import url(&quot;xx.css&quot;)</span><br></pre></td></tr></table></figure>

<p>在哪使用？</p>
<ul>
<li>在xx.css文件中，可以引用另一个样式文件</li>
<li>或者在<code>&lt;style&gt;</code>标签中引用</li>
</ul>
<p>初始样式</p>
<blockquote>
<p>有些标签默认含有内外边距，且不同浏览器大小也不一样。为了统一我们可以重置标签的CSS默认样式。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><blockquote>
<p>计算机所有的概念和技术都是演化的产物，因为需要才会产生，在css中拥有很多选择器，选择器的作用就是定位html标签，不同的选择器代表不同的定位方式。</p>
</blockquote>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p class&#x3D;&quot;example1&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">.example1&#123;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>example1</code>就是定义的类选择器，通过这个选择器，定位所有拥有相同class的标签，注意：类选择器可以很多标签</p>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><blockquote>
<p>id选择器对应的标签是唯一的，不同于类选择器可以到处使用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;example1&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">#example1&#123;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><blockquote>
<p>指定具体的标签</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;xx&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">p&#123;</span><br><span class="line">	color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构选择器"><a href="#结构选择器" class="headerlink" title="结构选择器"></a>结构选择器</h3><blockquote>
<p>我们需要知道整个html的是树结构，多个元素之间存在父子关系、兄弟关系等。</p>
</blockquote>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>element element</td>
<td>div p</td>
<td>选择div元素内部的所有的p元素，p是div的后代</td>
</tr>
<tr>
<td>element,element</td>
<td>div,p</td>
<td>选择所有div元素和所有p元素<br>两个类选择器也可以</td>
</tr>
<tr>
<td>element+element</td>
<td>div+p</td>
<td>选择紧接在div元素后的p元素， div和p 是兄弟关系</td>
</tr>
<tr>
<td>element~element2</td>
<td>p~ul</td>
<td>选择p元素后的所有的ul元素，p和ul 是兄弟关系</td>
</tr>
<tr>
<td>element&gt;element</td>
<td>div&gt;p</td>
<td>选择div内的所有p元素，div和p是父子关系</td>
</tr>
</tbody></table>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><blockquote>
<p>比如</p><p class style> 中的class 和style 就是属性，属性存在标签内部</p>
</blockquote>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[attribute]</td>
<td><code>[target]</code><br><code>h1[target][id]</code> 多属性约束</td>
<td>带有 target 属性所有元素</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>[attribute=value]</td>
<td>targe 属性 等于”_blank” 的所有元素</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>[title~=houdunren]</td>
<td>title 属性包含单词 “houdunren” 的所有元素</td>
</tr>
<tr>
<td>[attribute|=value]</td>
<td>[title|=hd]</td>
<td><code>title 属性值为 &quot;hd&quot;的单词，或hd-cms</code> 以<code>-</code>连接的的独立单词</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=”hdcms”]</td>
<td>src 属性中包含 “hdcms” 字符的每个 元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=”https”]</td>
<td>src 属性值以 “https” 开头的每个 元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=”.jpeg”]</td>
<td>src 属性以 “.jpeg” 结尾的所有 元素</td>
</tr>
</tbody></table>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><blockquote>
<p>为元素的不同状态或不确定存在的元素设置样式规则。</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有<code>未被访问</code>的链接</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有<code>已被访问</code>的链接</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>鼠标<code>移动到元素</code>上时</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>点击<code>正在发生</code></td>
</tr>
<tr>
<td>:focus</td>
<td>a:focus</td>
<td>选择获得<code>焦点</code>的input元素</td>
</tr>
<tr>
<td>:root</td>
<td>a:root</td>
<td>选择文档的根元素即<code>html</code></td>
</tr>
<tr>
<td>:empyt</td>
<td>p:empty</td>
<td>选择<code>没有子元素</code>的每个元素(包括文本节点)</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>选择每个层级第一个元素为p的元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个层级最后一个元素为p的元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>当前层级的第一个p元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>当前层级的最后一个p元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择当前层级中唯一的一个p元素，<code>所有兄弟姐妹中唯一的女孩</code></td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>p元素是独生子</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>p元素是当前层级的第二个元素</td>
</tr>
<tr>
<td>:nth-child(odd)</td>
<td>p:nth-child(odd)</td>
<td>当前层级第偶数个p元素（可以不连续）</td>
</tr>
<tr>
<td>:nth-child(even)</td>
<td>p:nth-child(even)</td>
<td>当前层级第奇数个p元素（可以不连续）</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择当前层级的第二个p元素（可以不连续）</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>当前层级的倒数第2个元素为p元素</td>
</tr>
<tr>
<td>p:nth-last-child(2)</td>
<td>p:nth-last-of-type(2)</td>
<td>当前层级的倒数第2个p元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>除了括号中选择器中之外的元素</td>
</tr>
</tbody></table>
<h3 id="表单伪类"><a href="#表单伪类" class="headerlink" title="表单伪类"></a>表单伪类</h3><p>表单属性样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:enabled</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#dddddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked+label</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表单必选样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:required</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">2px</span> blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:optional</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#dcdcdc</span>; </span><br><span class="line">	<span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表单验证样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:invalid</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符伪类"><a href="#字符伪类" class="headerlink" title="字符伪类"></a>字符伪类</h3><table>
<thead>
<tr>
<th>状态</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>::first-letter</td>
<td>p:first-letter</td>
<td>选择每个元素的首字母</td>
</tr>
<tr>
<td>::first-line</td>
<td>p:first-line</td>
<td>选择每个元素的首行</td>
</tr>
<tr>
<td>::before</td>
<td>p:before</td>
<td>在每个元素的内容之前插入内容</td>
</tr>
<tr>
<td>::after</td>
<td>p:after</td>
<td>在每个元素的内容之后插入内容</td>
</tr>
</tbody></table>
<h2 id="元素权重"><a href="#元素权重" class="headerlink" title="元素权重"></a>元素权重</h2><p>元素会被多个样式一层层作用，这就是层叠样式表的来源。如果多个样式做用在元素上就会产生优先级权重问题。</p>
<p>使用类、ID、伪类都有不同的权重，具体应用哪条规则要看权限大小。</p>
<ul>
<li>相同权重的规则应用最后出现的</li>
<li>可以使用 <code>!important</code> 强制提升某个规则的权限</li>
</ul>
<h3 id="权重应用"><a href="#权重应用" class="headerlink" title="权重应用"></a>权重应用</h3><table>
<thead>
<tr>
<th>规则</th>
<th>粒度</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>0100</td>
</tr>
<tr>
<td>class，类属性值</td>
<td>0010</td>
</tr>
<tr>
<td>标签,伪元素</td>
<td>0001</td>
</tr>
<tr>
<td>*</td>
<td>0000</td>
</tr>
<tr>
<td>行内样式</td>
<td>1000</td>
</tr>
</tbody></table>
<h3 id="强制优先级"><a href="#强制优先级" class="headerlink" title="强制优先级"></a>强制优先级</h3><p>有时在规则冲突时，为了让某个规则强制有效可以使用 !important。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line"> 	 color: red !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h2 &#123;</span><br><span class="line"> 	 color: green;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>HDCMS<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="继承规则"><a href="#继承规则" class="headerlink" title="继承规则"></a>继承规则</h3><p>子元素可以继承父元素设置的样式。</p>
<ul>
<li>子元素并不是全部样式。比如边框、高度等并不会继承。</li>
<li>继承的规则没有权重</li>
</ul>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在开发中使用<code>*</code> 选择器会有一个问题。因为通配符的权限为0，而继承的规则没有权重，看以下代码产生的问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line">  	color: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h2 &#123;</span><br><span class="line">  	color: blue;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span>&gt;</span>hdcms <span class="tag">&lt;<span class="name">span</span>&gt;</span>内容管理系统<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>h2</code> 中的span并没有继承 <code>h2</code> 的颜色，就是因为继承没有权重。而使用了 <code>*</code> 权重为0的规则。</p>
<p><a href="https://www.w3cschool.cn/css/dict" target="_blank" rel="noopener">https://www.w3cschool.cn/css/dict</a></p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><h4 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h4><h4 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h4>]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>clang</title>
    <url>/2017/12/08/clang/</url>
    <content><![CDATA[<h2 id="clang安装"><a href="#clang安装" class="headerlink" title="clang安装"></a>clang安装</h2><p>centos</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install clang</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的使用</title>
    <url>/2019/11/25/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令用于初始化本地文件夹为网站的根目录</span></span><br><span class="line">hexo init [folder]</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">新建文章</span></span><br><span class="line">hexo new [文章类型] &lt;标题&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line">hexo g</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">启动服务器</span></span><br><span class="line">hexo s</span><br><span class="line">hexo server</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">部署网址</span></span><br><span class="line">hexo d</span><br><span class="line">hexo deploy</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">清理缓存文件</span></span><br><span class="line">hexo clean</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">监视文件</span></span><br><span class="line">hexo w</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">新建页面</span></span><br><span class="line">hexo new page "tags"</span><br></pre></td></tr></table></figure>



<p>next主题</p>
<h2 id="调整hexo页面宽度"><a href="#调整hexo页面宽度" class="headerlink" title="调整hexo页面宽度"></a>调整hexo页面宽度</h2><p> 打开/Hexo/themes/hexo-theme-next/source//css/_variables/custom.styl 添加两行代码即可： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$main-desktop &#x3D; 1200px </span><br><span class="line">$content-desktop &#x3D; 900px</span><br></pre></td></tr></table></figure>

<h2 id="本地搜索功能"><a href="#本地搜索功能" class="headerlink" title="本地搜索功能"></a>本地搜索功能</h2><p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改 站点配置文件_config.yml </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h2 id="文章中插入图片的方法"><a href="#文章中插入图片的方法" class="headerlink" title="文章中插入图片的方法"></a>文章中插入图片的方法</h2><ol>
<li><p><strong>设置站点配置<code>_config.yml</code></strong>:将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code> </p>
</li>
<li><p><strong>安装插件</strong>:<code>npm install https://github.com/CodeFalling/hexo-asset-image -- save</code> </p>
</li>
<li><p>配置typora</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1574954911889.png" alt="1574954911889"></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..&#x2F;..&#x2F;source&#x2F;_posts&#x2F;&#x2F;$&#123;filename&#125;</span><br></pre></td></tr></table></figure>

<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>1.</p>
<blockquote>
<p>Accessing non-existent property ‘lineno’ of module exports inside circular dependency</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAyNjM0MjM=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>版本：</p>
<p>换一个低版本的Node，我换成<code>Node 12.14.0</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试</title>
    <url>/2020/07/19/gdb%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>编译程序，加上-g选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g main.cpp -o test.out</span><br></pre></td></tr></table></figure>

<h2 id="进入gdb"><a href="#进入gdb" class="headerlink" title="进入gdb"></a>进入gdb</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb test.out</span><br></pre></td></tr></table></figure>

<h2 id="在gdb中运行程序"><a href="#在gdb中运行程序" class="headerlink" title="在gdb中运行程序"></a>在gdb中运行程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure>

<h2 id="退出gdb"><a href="#退出gdb" class="headerlink" title="退出gdb"></a>退出gdb</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) quit 或者q</span><br></pre></td></tr></table></figure>


<h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在某个函数处设置断点 在main函数处设置断点</span></span><br><span class="line">(gdb) break + main(func) </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在代码中的某一行处设置断点</span></span><br><span class="line">(gdb) break + 行号 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用于在指定文件对应行设置断点</span></span><br><span class="line">(gdb) break + filename:行号</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内存地址断点</span></span><br><span class="line">(gdb) break + &lt;0x...&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用于设置条件断点，在循环中使用非常方便</span></span><br><span class="line">(gdb) break + 行号 + if + 条件 </span><br><span class="line">(gdb) break 10 if i==3</span><br></pre></td></tr></table></figure>

<h2 id="查看断点信息"><a href="#查看断点信息" class="headerlink" title="查看断点信息"></a>查看断点信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看断点信息</span></span><br><span class="line">(gdb) info breakpoints </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看观察点信息</span></span><br><span class="line">(gdb) info watchpoints</span><br></pre></td></tr></table></figure>

<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除所有断点</span></span><br><span class="line">(gdb) clear </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指点断点</span></span><br><span class="line">(gdb) delete + 断点编号</span><br></pre></td></tr></table></figure>

<h2 id="使断点失效或恢复生效"><a href="#使断点失效或恢复生效" class="headerlink" title="使断点失效或恢复生效"></a>使断点失效或恢复生效</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) disable/enable + 断点编号</span><br></pre></td></tr></table></figure>

<h2 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置观察点，当变量被读出或吸入时程序被暂停</span></span><br><span class="line">(gdb) awatch/watch + 变量 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置观察点，当变量被读出时，程序被暂停</span></span><br><span class="line">(gdb) rwatch + 变量</span><br></pre></td></tr></table></figure>
<h2 id="捕捉"><a href="#捕捉" class="headerlink" title="捕捉"></a>捕捉</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置捕捉点来捕捉程序运行时的一些事件，如：载入共享库、或者C++的异常</span></span><br><span class="line">(gdb) catch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只设置一次捕捉点，当程序停住以后，应点被自动删除</span></span><br><span class="line">(gdb) tcatch</span><br></pre></td></tr></table></figure>
<h2 id="追踪变量"><a href="#追踪变量" class="headerlink" title="追踪变量"></a>追踪变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每次程序停下来，都会打印变量的值。</span></span><br><span class="line">(gdb) display + 变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看追踪列表</span></span><br><span class="line">info display</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除追踪</span></span><br><span class="line">(gdb) delete + 编号</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使追踪列表设置成失效或者生效</span></span><br><span class="line">(gdb) disable/enable + display 编号ß</span><br></pre></td></tr></table></figure>

<h2 id="执行下一条语句"><a href="#执行下一条语句" class="headerlink" title="执行下一条语句"></a>执行下一条语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</span></span><br><span class="line">(gdb) step</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</span></span><br><span class="line">(gdb) step</span><br></pre></td></tr></table></figure>

<h2 id="打印内部变量"><a href="#打印内部变量" class="headerlink" title="打印内部变量"></a>打印内部变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) print</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印动态内存的值</span></span><br><span class="line">(gdb) p *array@len</span><br></pre></td></tr></table></figure>

<h2 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure>

<h2 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) set variable &lt;变量&gt;=&lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<h2 id="显示变量的数据类型"><a href="#显示变量的数据类型" class="headerlink" title="显示变量的数据类型"></a>显示变量的数据类型</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) whatis + 变量</span><br></pre></td></tr></table></figure>

<h2 id="显示栈帧"><a href="#显示栈帧" class="headerlink" title="显示栈帧"></a>显示栈帧</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不仅显示backtrace，还显示局部变量</span></span><br><span class="line">(gdb) bt full </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示开头N个栈帧</span></span><br><span class="line">(gdb) bt N</span><br><span class="line"></span><br><span class="line">(gdb) bt full N</span><br></pre></td></tr></table></figure>

<h2 id="显示寄存器"><a href="#显示寄存器" class="headerlink" title="显示寄存器"></a>显示寄存器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info reg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用<span class="built_in">print</span> 打印寄存器的内容</span></span><br><span class="line">(gdb) p $寄存器 # p $pc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 十六进制显示寄存器内容。</span></span><br><span class="line">(gdb) p/x $寄存器</span><br><span class="line"></span><br><span class="line">(gdb) x $寄存器 # 显示程序指针内容</span><br><span class="line"></span><br><span class="line">(gdb) x/i $寄存器 # 显示程序指针汇编。</span><br><span class="line"></span><br><span class="line">(gdb) x/10i $寄存器 # 显示程序指针之后10条指令。</span><br></pre></td></tr></table></figure>

<h2 id="生成coredump文件"><a href="#生成coredump文件" class="headerlink" title="生成coredump文件"></a>生成coredump文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) generate-core-file</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>git基础</title>
    <url>/2017/11/26/git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>Git提供一个git config的工具，专门来配置或读取相应的工作环境变量。</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户普遍适用的配置。</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。</li>
</ul>
<p>用户信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"John Doe"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>

<p>文本编辑器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global core.editor emacs</span></span><br></pre></td></tr></table></figure>

<p>差异分析工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global merge.tool vimdiff</span></span><br></pre></td></tr></table></figure>

<p>查看配置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20191220231611951.png" alt="image-20191220231611951"></p>
<p>查看某个配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<p>Git获取帮助</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git help config</span><br></pre></td></tr></table></figure>



<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><p>初始化新仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>增加文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add *.c</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure>

<p>克隆仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone url</span><br></pre></td></tr></table></figure>

<p>查看git提交历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -p -2 #-p 选项展开显示每次提交的内容 -2显示最近的两次更</span><br><span class="line">git log --stat #显示简要的增改行数统计</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td>–word-diff</td>
<td>按 word diff 格式显示差异。</td>
</tr>
<tr>
<td>–stat</td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td>–shortstat</td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td>–name-only</td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td>–name-status</td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td>–abbrev-commit</td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td>–relative-date</td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td>–graph</td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td>–pretty</td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
<tr>
<td>–oneline</td>
<td>–pretty=oneline –abbrev-commit 的简化用法。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --since=2.weeks #显示最近的两周内的提交</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-(n)</td>
<td>仅显示最近的 n 条提交</td>
</tr>
<tr>
<td>–since, –after</td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td>–until, –before</td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td>–author</td>
<td>仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td>–committer</td>
<td>仅显示指定提交者相关的提交。</td>
</tr>
</tbody></table>
<p>修改最后一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>查看当前仓库基本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>

<p>显示项目所有分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>显示git修改的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>增加远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin "URL"</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1574781334458.png" alt="1574781334458"></p>
<h3 id="git上传大文件"><a href="#git上传大文件" class="headerlink" title="git上传大文件"></a>git上传大文件</h3><p>报错信息：RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</p>
<p>打开git bash增加配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.postBuffer  524288000</span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>

<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>

<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>django</title>
    <url>/2018/04/20/django/</url>
    <content><![CDATA[<h1 id="django"><a href="#django" class="headerlink" title="django"></a>django</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>django安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install Django</span><br></pre></td></tr></table></figure>



<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>



<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<h2 id="不指定APP-就导出所有的数据"><a href="#不指定APP-就导出所有的数据" class="headerlink" title="不指定APP,就导出所有的数据"></a>不指定APP,就导出所有的数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py dumpdata [app] &gt; app_data.json</span><br></pre></td></tr></table></figure>

<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py loaddata app_data.json</span><br></pre></td></tr></table></figure>

<h2 id="django开发文档"><a href="#django开发文档" class="headerlink" title="django开发文档"></a>django开发文档</h2><p><a href="https://docs.djangoproject.com/zh-hans/3.0/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/3.0/</a> </p>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="setting配置"><a href="#setting配置" class="headerlink" title="setting配置"></a>setting配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">    &#39;django.middleware.locale.LocaleMiddleware&#39;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE &#x3D; &#39;zh-Hans&#39;</span><br><span class="line">USE_I18N &#x3D; True</span><br><span class="line">USE_L10N &#x3D; True</span><br><span class="line">USE_TZ &#x3D; True</span><br><span class="line"></span><br><span class="line"># 指定翻译所在目录</span><br><span class="line">LOCALE_PATHS &#x3D; (</span><br><span class="line">    os.path.join(BASE_DIR, &#39;locale&#39;),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LANGUAGES &#x3D; [</span><br><span class="line">    (&quot;en&quot;, _(&quot;English&quot;)),</span><br><span class="line">    (&quot;zh-hans&quot;, _(&quot;Chinese&quot;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>生成翻译的文件<code>注意，移动使用zh_hans,而不是zh-hans</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemessages -l zh_hans</span><br><span class="line">python manage.py makemessages -l en</span><br></pre></td></tr></table></figure>

<p>编译翻译文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py compilemessages</span><br></pre></td></tr></table></figure>

<h3 id="第三方库国际化"><a href="#第三方库国际化" class="headerlink" title="第三方库国际化"></a>第三方库国际化</h3><p>创建软链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &lt;库的绝对路径&gt; .&#x2F;</span><br></pre></td></tr></table></figure>

<p>使用以下命令生成翻译文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemessages -l zh_hans --symlinks</span><br><span class="line">python manage.py makemessages -l en --symlinks</span><br></pre></td></tr></table></figure>

<p>然后执行翻译文件</p>
<h2 id="migrate回退"><a href="#migrate回退" class="headerlink" title="migrate回退"></a>migrate回退</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate &lt;app&gt; &lt;migrations script name&gt;</span><br></pre></td></tr></table></figure>

<p><code>migrations script name</code> 可以是 0010_auto_20210412_0925 ，也可以是0010 <code>编号</code></p>
]]></content>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2020/09/28/java/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="mac-m1安装java"><a href="#mac-m1安装java" class="headerlink" title="mac m1安装java"></a>mac m1安装java</h3><p>到<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.azul.com%2Fdownloads%2Fzulu-community%2F%3Fpackage%3Djdk" target="_blank" rel="noopener">zulu</a>下载jdk</p>
<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter notebook</title>
    <url>/2019/11/25/jupyter%20notebook/</url>
    <content><![CDATA[<blockquote>
<p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——<a href="https://link.jianshu.com/?t=https%3A%2F%2Fjupyter-notebook.readthedocs.io%2Fen%2Fstable%2Fnotebook.html" target="_blank" rel="noopener">Jupyter Notebook官方介绍</a></p>
</blockquote>
<p>简而言之，Jupyter Notebook是以网页的形式打开，可以在网页页面中<strong>直接</strong>编写代码和运行代码，代码的运行结果也会直接在代码块下显示。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>

<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook --help</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200112002102816.png" alt="image-20200112002102816"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/09/28/javascript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript（JS）是一种具有函数优先的轻量级，解释型或即时编译型的编译语言。JavaScript是一种基于原型编程、多范式动态脚本语言，并且支持面向对象、命令式和声明式风格。</p>
<p>JavaScript的标准是ECMAScript。截止2012年，所有的现代浏览器都完整的支持ECMAScript 5.1，旧版本的浏览器至少支持ECMAScript 3 标准。2015年6月17日，ECMA国际组织发布了 ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为 <code>ECMAScript 6</code> 或者 <code>ES6</code>。自此，ECMAScript 每年发布一次新标准。本文档目前覆盖了最新 ECMAScript 的草案，也就是 ECMAScript2020。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>内嵌脚本，使用<code>script标签</code>嵌入javascript代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">'xxx'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>外部文件</p>
<blockquote>
<p>引用外部文件时，不要在当前标签中嵌入JavaScript代码。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>推荐script标签放入body中的最后。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>定义变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myVar; &#x2F;&#x2F;声明变量</span><br><span class="line">myVar &#x3D; 1;	&#x2F;&#x2F;变量赋值</span><br><span class="line"></span><br><span class="line">let myVar &#x3D; 1; &#x2F;&#x2F;声明的同时赋值</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串</td>
<td>let myVar = “xx”;</td>
</tr>
<tr>
<td>Number</td>
<td>数字</td>
<td>let myVar = 1;</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值</td>
<td>let myVar = true;</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
<td>let myVar = [1,”ds”,2];</td>
</tr>
<tr>
<td>Object</td>
<td>对象</td>
<td>let myVar = {name: “xx”,age: 18}</td>
</tr>
</tbody></table>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>返回原始类型</p>
<ul>
<li>Number/string/boolean</li>
<li>function</li>
<li>object</li>
<li>undefined</li>
</ul>
<h4 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h4><p><strong><code>instanceof</code></strong> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let hd &#x3D; [];</span><br><span class="line">let houdunren &#x3D; &#123;&#125;;</span><br><span class="line">console.log(hd instanceof Array); &#x2F;&#x2F;true</span><br><span class="line">console.log(houdunren instanceof Array); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>判断一个变量是数组还是对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">b &#x3D; &#123;</span><br><span class="line">	n: 1,</span><br><span class="line">	m: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.constructor &#x3D;&#x3D;&#x3D; Array);</span><br><span class="line">console.log(a.constructor &#x3D;&#x3D;&#x3D; Object);</span><br><span class="line"></span><br><span class="line">console.log(b.constructor &#x3D;&#x3D;&#x3D; Array);</span><br><span class="line">console.log(b.constructor &#x3D;&#x3D;&#x3D; Object);</span><br></pre></td></tr></table></figure>



<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>基本上所有类型都可以隐式转换为Boolean类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>true</th>
<th>false</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>非空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>Number</td>
<td>非0的数值</td>
<td>0、NaN</td>
</tr>
<tr>
<td>Array</td>
<td>数组不参与比较</td>
<td>参与比较的空数组</td>
</tr>
<tr>
<td>Object</td>
<td>所有对象</td>
<td></td>
</tr>
<tr>
<td>undefined</td>
<td>无</td>
<td>undefined</td>
</tr>
<tr>
<td>null</td>
<td>无</td>
<td>null</td>
</tr>
<tr>
<td>NaN</td>
<td>无</td>
<td>NaN</td>
</tr>
</tbody></table>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><h4 id="字符串创建"><a href="#字符串创建" class="headerlink" title="字符串创建"></a>字符串创建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"xxx"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.length);</span><br></pre></td></tr></table></figure>

<h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Are&quot; + &quot; you&quot; +&quot;OK?&quot; &#x2F;&#x2F; 拼接字符串</span><br><span class="line"></span><br><span class="line">a +&#x3D; &quot;1234&quot; &#x2F;&#x2F; 在字符串上追加</span><br><span class="line"></span><br><span class="line">let d &#x3D; 11 + &quot;10&quot;;</span><br><span class="line">console.log(typeof d,d); &#x2F;&#x2F;将Number转换成字符串再进行拼接</span><br></pre></td></tr></table></figure>

<h4 id="获取字符串"><a href="#获取字符串" class="headerlink" title="获取字符串"></a>获取字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.toString())	<span class="comment">//获取字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`xxx`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;show()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.toUpperCase <span class="comment">// 全部转换为答谢</span></span><br><span class="line"></span><br><span class="line">a.toLowerCase	<span class="comment">// 全部转换为小写</span></span><br></pre></td></tr></table></figure>

<h4 id="去除字符串中的空白"><a href="#去除字符串中的空白" class="headerlink" title="去除字符串中的空白"></a>去除字符串中的空白</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.trim()	<span class="comment">//删除字符串左右的空白字符</span></span><br><span class="line"></span><br><span class="line">a.trimLeft() <span class="comment">//删除字符串的左边的空白</span></span><br><span class="line"></span><br><span class="line">a.trimRight() <span class="comment">//删除字符串右边的空白</span></span><br></pre></td></tr></table></figure>

<h4 id="获取字符串中的字符"><a href="#获取字符串中的字符" class="headerlink" title="获取字符串中的字符"></a>获取字符串中的字符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.charAt(<span class="number">3</span>) <span class="comment">// 通过index获取字符串中的字符</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">3</span>] <span class="comment">//通过下标也可以直接获取字符</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取字符串</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"zhongguoren"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">3</span>)); <span class="comment">// 获取index 3 之后的所有字符</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">3</span>,<span class="number">6</span>));  <span class="comment">//左闭右开, 获取index 3,4,5 字符</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">3</span>,<span class="number">-1</span>)); <span class="comment">// 获取index 3 到 index =1(表示最后一个字符的index) ，3之后的所有字符</span></span><br><span class="line"><span class="built_in">console</span>.log(a.slice(<span class="number">-2</span>)); <span class="comment">// 获取index -2 -1 ，最后两个字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.substring(<span class="number">3</span>));  <span class="comment">//左闭右开</span></span><br><span class="line"><span class="built_in">console</span>.log(a.substring(<span class="number">3</span>,<span class="number">6</span>));  <span class="comment">//左闭右开, 获取index 3,4,5 字符</span></span><br><span class="line"><span class="built_in">console</span>.log(a.substring(<span class="number">3</span>,<span class="number">-9</span>)); <span class="comment">// 将-9 转换为0， 相当于a.substring(3,0)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.substr(<span class="number">3</span>,<span class="number">0</span>)) <span class="comment">// 相当于a.substr(0,3)</span></span><br><span class="line"><span class="built_in">console</span>.log(a.substr(<span class="number">3</span>,<span class="number">6</span>));  <span class="comment">// 从index 往后获取6位</span></span><br><span class="line"><span class="built_in">console</span>.log(a.substr(<span class="number">-3</span>,<span class="number">2</span>)); <span class="comment">// 获取-3，-2</span></span><br></pre></td></tr></table></figure>

<h4 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">"o"</span>)); <span class="comment">// 查找字符串中第一个遇到o字符的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">"o"</span>,<span class="number">3</span>)); <span class="comment">//从index 3之后开始找第一个遇到的0字符的位置 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.lastIndexOf(<span class="string">"o"</span>)); <span class="comment">//逆向查找</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastIndexOf(<span class="string">"o"</span>,<span class="number">7</span>)); <span class="comment">//从第index 7字符向前搜索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.search(<span class="string">"ren"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.search(<span class="regexp">/\.ren/i</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.includes(<span class="string">"ren"</span>)); <span class="comment">// 判断是否包含子字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(a.includes(<span class="string">"ren"</span>, <span class="number">5</span>)); <span class="comment">//从指定index 位置开始查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.startsWith(<span class="string">"z"</span>)); <span class="comment">//从第一个字符开始匹配，一旦有字符串不匹配返回false，否则返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.startsWith(<span class="string">"h"</span>,<span class="number">1</span>)); <span class="comment">// 指定从第几个index 开始匹配</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.endsWith(<span class="string">"n"</span>)); <span class="comment">//从最后一个字符开始往前匹配，不匹配返回false，否则返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.endsWith(<span class="string">"e"</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换字符串</span></span><br><span class="line"><span class="keyword">let</span> c = a.replace(<span class="string">"zhongguo"</span>,<span class="string">"jiangsu"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(str.replace(/\//g, "-")); 可以使用正则表达式</span></span><br></pre></td></tr></table></figure>

<h4 id="重复生成"><a href="#重复生成" class="headerlink" title="重复生成"></a>重复生成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;*&quot;.repeat(3));</span><br></pre></td></tr></table></figure>

<h4 id="分割字母"><a href="#分割字母" class="headerlink" title="分割字母"></a>分割字母</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a.split(&quot;&quot;)); &#x2F;&#x2F;将字符串转换成一个个字符，放在数组中</span><br></pre></td></tr></table></figure>

<h4 id="字符串转换为数组"><a href="#字符串转换为数组" class="headerlink" title="字符串转换为数组"></a>字符串转换为数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;1,2,3&quot;.split(&quot;,&quot;)) &#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>

<h3 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number(数值)"></a>Number(数值)</h3><h4 id="创建Number"><a href="#创建Number" class="headerlink" title="创建Number"></a>创建Number</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否数组"><a href="#判断是否数组" class="headerlink" title="判断是否数组"></a>判断是否数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是整数</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<h4 id="指定返回的小数位数可以四舍五入"><a href="#指定返回的小数位数可以四舍五入" class="headerlink" title="指定返回的小数位数可以四舍五入"></a>指定返回的小数位数可以四舍五入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">21.212</span>).toFixed(<span class="number">2</span>); <span class="comment">//21.21</span></span><br></pre></td></tr></table></figure>

<h4 id="提取字符串开始去除空白后的数字转为整数"><a href="#提取字符串开始去除空白后的数字转为整数" class="headerlink" title="提取字符串开始去除空白后的数字转为整数"></a>提取字符串开始去除空白后的数字转为整数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"  123dsds"</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"123.11"</span>); <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h4 id="转换字符串为浮点数，忽略字符串空白字符"><a href="#转换字符串为浮点数，忽略字符串空白字符" class="headerlink" title="转换字符串为浮点数，忽略字符串空白字符"></a>转换字符串为浮点数，忽略字符串空白字符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">" 11dsds"</span>)); <span class="number">99</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"121.21"</span>)); <span class="number">121.21</span></span><br></pre></td></tr></table></figure>

<h4 id="获取最大值、最小值"><a href="#获取最大值、最小值" class="headerlink" title="获取最大值、最小值"></a>获取最大值、最小值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apple(<span class="built_in">Math</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br></pre></td></tr></table></figure>

<h4 id="舍入处理"><a href="#舍入处理" class="headerlink" title="舍入处理"></a>舍入处理</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">1.111</span>));	<span class="comment">// 向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">1.555</span>));	<span class="comment">// 向下取整</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">1.5</span>));	<span class="comment">// 四舍五入处理</span></span><br></pre></td></tr></table></figure>

<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">5</span>);	<span class="comment">//0~5的随机数，不包括5</span></span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">5</span>+<span class="number">1</span>));	<span class="comment">//返回0~5的随机数，包括5</span></span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">5</span> - <span class="number">2</span>)) + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面取2~5的随机数（不包括5）</span></span><br><span class="line"><span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">5</span> - <span class="number">2</span>)) + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面取2~5的随机数</span></span><br><span class="line"><span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">5</span> - <span class="number">2</span> + <span class="number">1</span>)) + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机点名</span></span><br><span class="line"><span class="keyword">let</span> stus = [<span class="string">'小明'</span>, <span class="string">'张三'</span>, <span class="string">'王五'</span>, <span class="string">'爱情'</span>];</span><br><span class="line"><span class="keyword">let</span> pos = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * stus.length);</span><br><span class="line"><span class="built_in">console</span>.log(stus[pos]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stus = [<span class="string">'小明'</span>, <span class="string">'张三'</span>, <span class="string">'王五'</span>, <span class="string">'爱情'</span>];</span><br><span class="line"><span class="keyword">let</span> pos = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">3</span><span class="number">-1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stus[pos]);</span><br></pre></td></tr></table></figure>

<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><blockquote>
<p>无效的数值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"dsjkds"</span>); <span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isNaN()	<span class="comment">// 判断是否是NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点精度处理"><a href="#浮点精度处理" class="headerlink" title="浮点精度处理"></a>浮点精度处理</h4><p>大部分变成语言在浮点数计算是都会有精度误差问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="built_in">console</span>.log(hd)<span class="comment">// 结果：0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>处理方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">2</span>)) <span class="comment">//0.3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span> - <span class="number">0.9</span>) <span class="comment">//0.09999999999999998</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1.0</span> - <span class="number">0.9</span>).toFixed(<span class="number">2</span>)) <span class="comment">//0.10</span></span><br></pre></td></tr></table></figure>

<p>将小数转为整数进行计算后，再转为小数也可以解决精度问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//取两个数值中小数位最大的</span></span><br><span class="line">  <span class="keyword">let</span> n1 = <span class="keyword">this</span>.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>].length</span><br><span class="line">  <span class="keyword">let</span> n2 = num.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>].length</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//得到10的N次幂</span></span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(n1, n2))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> * m + num * m) / m</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0.1</span>).add(<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure>

<p><strong>推荐做法</strong></p>
<p>市面上已经存在很多针对数学计算的库 <a href="https://mathjs.org/examples/browser/basic_usage.html.html" target="_blank" rel="noopener">mathjs</a>、<a href="http://mikemcl.github.io/decimal.js" target="_blank" rel="noopener">decimal.js</a>等，我们就不需要自己构建了。下面来演示使用 <a href="http://mikemcl.github.io/decimal.js" target="_blank" rel="noopener">decimal.js</a>进行浮点计算。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/decimal.js/10.2.0/decimal.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(Decimal.add(<span class="number">0.1</span>, <span class="number">0.2</span>).valueOf())</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>网站中处理时间是很常用的功能，通过Date类型提供的丰富功能可以非常方便的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(now);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> date); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(now * <span class="number">1</span>); <span class="comment">//获取时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用函数获取当前时间</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>()); <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前时间戳单位毫秒</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());</span><br></pre></td></tr></table></figure>

<h5 id="计算脚本执行时间"><a href="#计算脚本执行时间" class="headerlink" title="计算脚本执行时间"></a>计算脚本执行时间</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(end - start);</span><br></pre></td></tr></table></figure>

<p>当前也可以使用控制台测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"testFor"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"testFor"</span>);</span><br></pre></td></tr></table></figure>

<p>根据指定的日期与时间定义日期对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2028-02-22 03:25:02'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(now);</span><br><span class="line"></span><br><span class="line">now = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2028</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(now);</span><br></pre></td></tr></table></figure>

<p>使用展示运算符处理更方便</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info = [<span class="number">2020</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">32</span>];</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(...info);</span><br><span class="line"><span class="built_in">console</span>.dir(date);</span><br></pre></td></tr></table></figure>

<p>类型转换</p>
<p>将日期转为数值类型就是转为时间戳单位是毫秒</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2020-2-22 10:33:12"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hd * <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(hd));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hd.valueOf())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(date.getTime());</span><br></pre></td></tr></table></figure>

<p>将时间戳转换为标准日期的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> param = [<span class="number">1990</span>, <span class="number">2</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">22</span>, <span class="number">19</span>];</span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(...param);</span><br><span class="line"><span class="keyword">const</span> timestamp = date.getTime();</span><br><span class="line"><span class="built_in">console</span>.log(timestamp);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(timestamp));</span><br></pre></td></tr></table></figure>

<p>对象方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化输出日期</span></span><br><span class="line"><span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;time.getFullYear()&#125;</span>-<span class="subst">$&#123;time.getMonth()&#125;</span>-<span class="subst">$&#123;time.getDate()&#125;</span> <span class="subst">$&#123;time.getHours()&#125;</span>:<span class="subst">$&#123;time.getMinutes()&#125;</span>:<span class="subst">$&#123;time.getSeconds()&#125;</span>`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>封装函数用于复用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateFormat</span>(<span class="params">date, format = <span class="string">"YYYY-MM-DD HH:mm:ss"</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    YYYY: date.getFullYear(),</span><br><span class="line">    MM: date.getMonth() + <span class="number">1</span>,</span><br><span class="line">    DD: date.getDate(),</span><br><span class="line">    HH: date.getHours(),</span><br><span class="line">    mm: date.getMinutes(),</span><br><span class="line">    ss: date.getSeconds()</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> config) &#123;</span><br><span class="line">    format = format.replace(key, config[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">"YYYY年MM月DD日"</span>));</span><br></pre></td></tr></table></figure>

<p>下面是系统提供的日期时间方法，更多方法请查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">MDN官网</a></p>
<h4 id="moment-js"><a href="#moment-js" class="headerlink" title="moment.js"></a>moment.js</h4><p>Moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率。</p>
<h3 id="Array数组类型"><a href="#Array数组类型" class="headerlink" title="Array数组类型"></a>Array数组类型</h3><p>创建数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array(1,2,3);</span><br><span class="line"></span><br><span class="line">const array &#x3D; [&quot;ds&quot;,&quot;ddd&quot;]</span><br><span class="line"></span><br><span class="line">const array &#x3D; [[&quot;hdcms&quot;], [&quot;1111&quot;]];</span><br></pre></td></tr></table></figure>

<p>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array &#x3D; [&quot;ds&quot;,&quot;ddd&quot;];</span><br><span class="line"></span><br><span class="line">array.length;</span><br></pre></td></tr></table></figure>

<p>Array.of</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let hd &#x3D; Array.of(3);</span><br><span class="line">console.log(hd);</span><br><span class="line"></span><br><span class="line">hd &#x3D; Array.of(1,2,3);</span><br><span class="line">console.log(hd);</span><br></pre></td></tr></table></figure>

<p>类型检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.isArray([1,&quot;111&quot;,&quot;hdcms&quot;]);</span><br><span class="line">Array.isArray(9);</span><br></pre></td></tr></table></figure>

<p>字符串</p>
<p> 大部分数据类型都可以使用，.toString() 函数转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(([1, 2, 3]).toString()); &#x2F;&#x2F; 1,2,3</span><br></pre></td></tr></table></figure>

<p>也可以使用函数String转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(String([1,2,3]))</span><br></pre></td></tr></table></figure>

<p>或使用join连接字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3].join(&quot;-&quot;);</span><br></pre></td></tr></table></figure>



<p>Array.from</p>
<p>使用<code>Array.from</code> 可将类数组转换为数组，类数组指包含length 属性或可迭代的对象</p>
<ul>
<li>第一个参数为要转换为数据，第二个参数为类似于map函数的回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'xxx'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str)); <span class="comment">//["x", "x", "x"]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="string">'a'</span>, <span class="string">'xx'</span>, ...a];</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//["a", "xx", 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hd</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">hd(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"xx"</span>); <span class="comment">//[1, 2, 3, "xx"]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hd</span>(<span class="params">site, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(site, args); <span class="comment">//xx (3) [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">hd(<span class="string">"xx"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name,url] = [<span class="string">"xx"</span>,<span class="string">"123"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="string">'1111'</span>, <span class="string">'hdcms'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b] = hd();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//houdunren</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="string">'xx'</span>, <span class="string">'1111'</span>, <span class="string">'hdcms'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> web = <span class="string">"后盾人"</span>;</span><br><span class="line">[web, url] = [<span class="string">"111.com"</span>, <span class="string">"111.com"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(web);</span><br></pre></td></tr></table></figure>

<p>字符串解构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...a] = <span class="string">"111.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//Array(13)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [,url]=[<span class="string">'后盾人'</span>,<span class="string">'111.com'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(url);<span class="comment">//houdunren.com</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [name, ...arr] = [<span class="string">'后盾人'</span>, <span class="string">'111'</span>, <span class="string">'111.com'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(name, arr); <span class="comment">//后盾人 (2) ["hdcms", "houdunren.com"]</span></span><br></pre></td></tr></table></figure>

<p>数组参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hd</span>(<span class="params">[a, b]</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">hd([<span class="string">'111'</span>, <span class="string">'111'</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="string">"xx"</span>,<span class="string">"123"</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"222"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组追加元素</span></span><br><span class="line">arr[arr.length] = <span class="string">"333"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h4 id="批量添加元素"><a href="#批量添加元素" class="headerlink" title="批量添加元素"></a>批量添加元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; [1,2,3];</span><br><span class="line"></span><br><span class="line">let b &#x3D; [&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">b.push(...a);</span><br><span class="line">console.log(b);</span><br><span class="line"></span><br><span class="line">b.push(&#39;444&#39;,&#39;555&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="根据区间创建新数组"><a href="#根据区间创建新数组" class="headerlink" title="根据区间创建新数组"></a>根据区间创建新数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rangeArray</span>(<span class="params">begin, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">    array.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(rangeArray(<span class="number">1</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h4 id="从末尾弹出元素"><a href="#从末尾弹出元素" class="headerlink" title="从末尾弹出元素"></a>从末尾弹出元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"1"</span>,<span class="string">"2"</span>];</span><br><span class="line">arr.pop();</span><br></pre></td></tr></table></figure>

<h4 id="从数组前面去除一个元素"><a href="#从数组前面去除一个元素" class="headerlink" title="从数组前面去除一个元素"></a>从数组前面去除一个元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.shift();</span><br></pre></td></tr></table></figure>

<h4 id="从数组前面添加元素"><a href="#从数组前面添加元素" class="headerlink" title="从数组前面添加元素"></a>从数组前面添加元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.unshift();</span><br></pre></td></tr></table></figure>

<h4 id="填充数组元素"><a href="#填充数组元素" class="headerlink" title="填充数组元素"></a>填充数组元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Array</span>(<span class="number">4</span>).fill(<span class="string">"111"</span>));</span><br></pre></td></tr></table></figure>

<p>指定填充位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].fill(<span class="string">"1"</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h4 id="数组截取"><a href="#数组截取" class="headerlink" title="数组截取"></a>数组截取</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice()); <span class="comment">//[0, 1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="添加、删除、替换"><a href="#添加、删除、替换" class="headerlink" title="添加、删除、替换"></a>添加、删除、替换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">//返回删除的元素 [1, 2, 3] </span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//删除数据后的原数组 [0, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>通过修改length删除最后一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"123"</span>, <span class="string">"234"</span>];</span><br><span class="line">arr.length = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>通过制定第三个参数来设置在删除位置添加的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>, <span class="number">3</span>, <span class="string">'123'</span>, <span class="string">'123'</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向末尾添加元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(arr.length,<span class="number">0</span>,<span class="string">"222"</span>,<span class="string">"333"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向数组前添加元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'123'</span>, <span class="string">'234'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素位置调整函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">array, before, to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (before &lt; <span class="number">0</span> || to &gt;= array.length) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"指定位置错误"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newArray = [...array];</span><br><span class="line">  <span class="keyword">const</span> elem = newArray.splice(before, <span class="number">1</span>);</span><br><span class="line">  newArray.splice(to, <span class="number">0</span>, ...elem);</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.table(move(array, <span class="number">0</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h4 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = [&#123; <span class="attr">name</span>: <span class="string">"111"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"222"</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">user = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">user.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">user.splice(<span class="number">0</span>, user.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法死</span></span><br><span class="line"><span class="keyword">while</span> (user.pop()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并拆分"><a href="#合并拆分" class="headerlink" title="合并拆分"></a>合并拆分</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"111"</span>, <span class="string">"222"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'-'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> price = <span class="string">"99,78,68"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(price.split(<span class="string">","</span>)); <span class="comment">//["99", "78", "68"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">"111"</span>, <span class="string">"222"</span>];</span><br><span class="line"><span class="keyword">let</span> hd = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> cms = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.concat(hd, cms)); <span class="comment">//["111", "222", 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...array, ...hd, ...cms]);</span><br></pre></td></tr></table></figure>

<h5 id="copyWithin-从数组中赋值一部分到同数组中的另外位置"><a href="#copyWithin-从数组中赋值一部分到同数组中的另外位置" class="headerlink" title="copyWithin 从数组中赋值一部分到同数组中的另外位置"></a>copyWithin 从数组中赋值一部分到同数组中的另外位置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)); <span class="comment">//[1, 2, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h5><blockquote>
<p>从前向后查找元素出现的位置，如果找不到返回-1</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">2</span>)); <span class="comment">// 2 从前面查找2出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'8'</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">8</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//从第二个元素开始向后查找</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><blockquote>
<p>从后向前查找元素出现的位置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">2</span>)); <span class="comment">// 4 从后查找2出现的位置</span></span><br></pre></td></tr></table></figure>

<p>第二个参数用于指定开始位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//从第五个元素向前查找</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//从最后一个字符向前查找</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">2</span>, <span class="number">-2</span>));</span><br></pre></td></tr></table></figure>

<h5 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h5><blockquote>
<p>查找字符串返回值是布尔类型更方便判断</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">6</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><blockquote>
<p>find 方法找到后会把值返回出来</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> find = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item == <span class="string">"1"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(find); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能查找引用类型</span></span><br><span class="line"><span class="keyword">const</span> user = [&#123; <span class="attr">name</span>: <span class="string">"李四"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"张三"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"后盾人"</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> find = user.includes(&#123; <span class="attr">name</span>: <span class="string">"后盾人"</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(find);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以方便的查找引用类型</span></span><br><span class="line"><span class="keyword">const</span> user = [&#123; <span class="attr">name</span>: <span class="string">"李四"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"张三"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"后盾人"</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> find = user.find(<span class="function"><span class="params">user</span> =&gt;</span> (user.name = <span class="string">"后盾人"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(find);</span><br></pre></td></tr></table></figure>

<h5 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h5><blockquote>
<p>返回索引值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'8'</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v == <span class="number">8</span>;</span><br><span class="line">&#125;)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h4 id="reverse-数组逆序"><a href="#reverse-数组逆序" class="headerlink" title="reverse 数组逆序"></a>reverse 数组逆序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()); <span class="comment">//[9, 2, 4, 1]</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">//[1, 2, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v2 - v1;</span><br><span class="line">&#125;)); <span class="comment">//[9, 4, 2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lessons = [</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">"媒体查询响应式布局"</span>, <span class="attr">click</span>: <span class="number">78</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">"FLEX 弹性盒模型"</span>, <span class="attr">click</span>: <span class="number">12</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">"MYSQL多表查询随意操作"</span>, <span class="attr">click</span>: <span class="number">99</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sortLessons = lessons.sort(<span class="function">(<span class="params">v1, v2</span>) =&gt;</span> v2.click - v1.click);</span><br><span class="line"><span class="built_in">console</span>.log(sortLessons);</span><br></pre></td></tr></table></figure>

<h4 id="获取数组所有键"><a href="#获取数组所有键" class="headerlink" title="获取数组所有键"></a>获取数组所有键</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"后盾人"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归检测元素every"><a href="#递归检测元素every" class="headerlink" title="递归检测元素every"></a>递归检测元素every</h4><blockquote>
<p>要所有元素操作都要返回真结果才为真。相当于 “与”</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"李四"</span>, <span class="attr">js</span>: <span class="number">89</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"马六"</span>, <span class="attr">js</span>: <span class="number">55</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">js</span>: <span class="number">78</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> resust = user.every(<span class="function"><span class="params">user</span> =&gt;</span> user.js &gt;= <span class="number">60</span>);</span><br><span class="line"><span class="built_in">console</span>.log(resust);</span><br></pre></td></tr></table></figure>

<h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><blockquote>
<p>如果有一个返回true，表达式结果就是真。 相当于 “或”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let words &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;];</span><br><span class="line">let title &#x3D; &#39;1234567&#39;</span><br><span class="line"></span><br><span class="line">let state &#x3D; words.some(function (item, index, array) &#123;</span><br><span class="line">	return title.indexOf(item) &gt;&#x3D; 0;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (state) console.log(&#39;标题含有违规关键词&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote>
<p>以过滤数据中元素</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lessons = [</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">'媒体查询响应式布局'</span>,<span class="attr">category</span>: <span class="string">'css'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">'FLEX 弹性盒模型'</span>,<span class="attr">category</span>: <span class="string">'css'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">'MYSQL多表查询随意操作'</span>,<span class="attr">category</span>: <span class="string">'mysql'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cssLessons = lessons.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item.category.toLowerCase() == <span class="string">'css'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cssLessons);</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lessons = [</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">'媒体查询响应式布局'</span>,<span class="attr">category</span>: <span class="string">'css'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">'FLEX 弹性盒模型'</span>,<span class="attr">category</span>: <span class="string">'css'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">title</span>: <span class="string">'MYSQL多表查询随意操作'</span>,<span class="attr">category</span>: <span class="string">'mysql'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lessons.map(<span class="function"><span class="params">item</span> =&gt;</span> item.title));</span><br><span class="line"></span><br><span class="line">lessons = lessons.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    item.title = <span class="string">`[后盾人] <span class="subst">$&#123;item[<span class="string">'title'</span>]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(lessons);</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArrayELem</span>(<span class="params">array, elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> (total += cur == elem ? <span class="number">1</span> : <span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(countArrayELem(numbers, <span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayMax</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(</span><br><span class="line">  	(max, elem) =&gt; (max &gt; elem ? max : elem), array[<span class="number">0</span>]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrayMax([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取价格最高的商品</span></span><br><span class="line"><span class="keyword">let</span> cart = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"iphone"</span>, <span class="attr">price</span>: <span class="number">12000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"imac"</span>, <span class="attr">price</span>: <span class="number">25000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"ipad"</span>, <span class="attr">price</span>: <span class="number">3600</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxPrice</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(</span><br><span class="line">    (goods, elem) =&gt; (goods.price &gt; elem.price ? goods : elem),</span><br><span class="line">    array[<span class="number">0</span>]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxPrice(cart));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算购物车中的商品总价</span></span><br><span class="line"><span class="keyword">let</span> cart = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"iphone"</span>, <span class="attr">price</span>: <span class="number">12000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"imac"</span>, <span class="attr">price</span>: <span class="number">25000</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"ipad"</span>, <span class="attr">price</span>: <span class="number">3600</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = cart.reduce(</span><br><span class="line">	(total, goods) =&gt; total += goods.price, <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(total); <span class="comment">//40600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterArr = arr.reduce(<span class="function">(<span class="params">pre, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pre.includes(cur) === <span class="literal">false</span>) &#123;</span><br><span class="line">      pre = [...pre, cur];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(filterArr); <span class="comment">// [1,2,6]</span></span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lessons.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    item.title = item.title.substr(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">&#125;);<span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a[i]);</span><br><span class="line">	a[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> a) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> a) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> a.entries()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>用于存储任何类型的唯一值，无论是基本还是对象引用。</p>
<ul>
<li>只能保存没有键名</li>
<li>严格类型检测如字符串数组不等于数值数字</li>
<li>值是唯一的</li>
<li>遍历顺序是添加的顺序，方便保存回调函数</li>
</ul>
<h4 id="使用数组作为初始数据"><a href="#使用数组作为初始数据" class="headerlink" title="使用数组作为初始数据"></a>使用数组作为初始数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"1"</span>,<span class="string">"2"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(hd.values());</span><br></pre></td></tr></table></figure>

<h4 id="创建Set-添加数据"><a href="#创建Set-添加数据" class="headerlink" title="创建Set 添加数据"></a>创建Set 添加数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面的数值1与&quot;1&quot;属于两个不同的值</span><br><span class="line">let set &#x3D; new Set();</span><br><span class="line">set.add(1);</span><br><span class="line">set.add(&quot;1&quot;);</span><br><span class="line">console.log(set);</span><br></pre></td></tr></table></figure>

<h4 id="不允许重复添加"><a href="#不允许重复添加" class="headerlink" title="不允许重复添加"></a>不允许重复添加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let hd &#x3D; new Set();</span><br><span class="line"></span><br><span class="line">hd.add(&quot;1&quot;);</span><br><span class="line">hd.add(&quot;2&quot;);</span><br><span class="line">hd.add(&quot;2&quot;);</span><br><span class="line"></span><br><span class="line">console.log(hd.values);</span><br></pre></td></tr></table></figure>

<h4 id="获取数量"><a href="#获取数量" class="headerlink" title="获取数量"></a>获取数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set.size</span><br></pre></td></tr></table></figure>

<h4 id="元素检测"><a href="#元素检测" class="headerlink" title="元素检测"></a>元素检测</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set.has(&quot;key&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set.delete(&quot;key&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="清楚所有元素"><a href="#清楚所有元素" class="headerlink" title="清楚所有元素"></a>清楚所有元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set.clear();</span><br></pre></td></tr></table></figure>

<h4 id="Set转换为数组"><a href="#Set转换为数组" class="headerlink" title="Set转换为数组"></a>Set转换为数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.from(set);</span><br></pre></td></tr></table></figure>

<h4 id="移除大于5的数值"><a href="#移除大于5的数值" class="headerlink" title="移除大于5的数值"></a>移除大于5的数值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let hd &#x3D; new Set(&quot;&quot;)</span><br></pre></td></tr></table></figure>







<h2 id="JavaScript中函数定义方式"><a href="#JavaScript中函数定义方式" class="headerlink" title="JavaScript中函数定义方式"></a>JavaScript中函数定义方式</h2><p>函数声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">param</span>)</span>&#123;</span><br><span class="line"><span class="comment">//somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//somthings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'param1'</span>,<span class="string">'parma2'</span>,<span class="string">'somethings'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = func(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>自调用函数 （不需要调用自己会执行）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//somethings</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote>
<p>JavaScript语言中，生成示例对象的传统方法是通过构造函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">weight, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.weight + <span class="string">', '</span> + <span class="keyword">this</span>.height + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> person(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.weight);	<span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(b.height);	<span class="comment">//200</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString());	<span class="comment">//(100,200)</span></span><br></pre></td></tr></table></figure>

<p>这种写法和传统的面向对象语言（C++和java）差异很大，明明是一个函数怎么变成了类，很容易让人感到困惑。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><code>ES6</code>的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">constructor</span>(weight,height) &#123;</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">  	<span class="keyword">this</span>.height = height;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//成员函数</span></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.weight + <span class="string">', '</span> + <span class="keyword">this</span>.height + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b.weight);	<span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(b.height);	<span class="comment">//200</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toString());	<span class="comment">//(100,200)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person)	<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(person.prototype.constructor == b.constructor)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这两种方式是一样的。</p>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常声明一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名一个类</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具名一个类</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>prototype属性，在ES6的类上面继续存在，事实上，类的所有方法都定义在类的prototype属性上。</p>
<p>可以通过prototype对象<code>添加类的方法</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>object.assign</code>方法也可以很方便地一次向类<code>添加多个方法</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.assign(person.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>deleteProperty</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reflect.deleteProperty(person.prototype, &#39;toString&#39;)</span><br></pre></td></tr></table></figure>

<p><code>prototype</code>对象的<code>constructor</code>属性，直接指向<code>类</code>的本身，这与 ES5 的行为是一致的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person.prototype.constructor &#x3D;&#x3D;&#x3D; person</span><br></pre></td></tr></table></figure>

<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显示定义，一个空的constructor方法会被默认添加。</p>
<h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = x;</span><br><span class="line">    <span class="keyword">this</span>.height = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.weight + <span class="string">', '</span> + <span class="keyword">this</span>.height + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person_obj = <span class="keyword">new</span> person(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">person_obj.toString() <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">person_obj.hasOwnProperty(<span class="string">'weight'</span>) <span class="comment">// true</span></span><br><span class="line">person_obj.hasOwnProperty(<span class="string">'height'</span>) <span class="comment">// true</span></span><br><span class="line">person_obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line">person_obj.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210122103451604.png" alt="image-20210122103451604"></p>
<p>x和y都是实例对象person自身的属性(因为定义在this变量上)，所以<code>hasOwnProperty</code>方法返回true，而toString是原型对象的属性，所以返回false。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210124162001072.png" alt="image-20210124162001072"></p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><blockquote>
<p>静态属性，class本身的属性，即直接定义在类内部的属性，不需要实例化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个带有静态属性的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类本身可以直接调用</span></span><br><span class="line">person.a; <span class="comment">// 1</span></span><br><span class="line">person.b = <span class="number">2</span>;</span><br><span class="line">person.b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过new关键字生成的对象，无法调用该方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> distance(a, b) &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = a.x - b.x</span><br><span class="line">    <span class="keyword">const</span> dy = a.y - b.y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(dx, dy) <span class="comment">// 毕达哥拉斯定理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(Point.distance(p1, p2)) <span class="comment">// 7.0710678118654755</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在p1、p2对象中找不到静态方法distance</p>
</blockquote>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>该属性能获取或者返回class的类名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; new person();</span><br><span class="line">console.log(a.name);</span><br></pre></td></tr></table></figure>

<h3 id="get和set"><a href="#get和set" class="headerlink" title="get和set"></a>get和set</h3><p>下面我们通过get Dheight中获取两倍的height，set Dheight中缩小两倍存入height</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(weight, height) &#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> Dheight() &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> Dheight(value) &#123;</span><br><span class="line">  <span class="keyword">this</span>.height = value / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> person(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.height);</span><br><span class="line"><span class="built_in">console</span>.log(obj.Dheight);</span><br><span class="line">obj.Dheight = <span class="number">400</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.height);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> a() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"getter"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> a(value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"setter"</span>);</span><br><span class="line">      <span class="keyword">this</span>._a = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getter不可单独出现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> a() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> a(a) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a = a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Child()</span><br><span class="line">test.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(test.a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">// 或者都放在子类中</span></span><br><span class="line">  <span class="keyword">get</span> a() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> a(a) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a = a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> Child1()</span><br><span class="line">test1.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>getter 与 setter 必须同级出现</p>
</blockquote>
<h3 id="静态方法、原型方法与实例方法"><a href="#静态方法、原型方法与实例方法" class="headerlink" title="静态方法、原型方法与实例方法"></a>静态方法、原型方法与实例方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticFunc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sum(a, b) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">StaticFunc.sum(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeFunc</span> </span>&#123;</span><br><span class="line">  sum(a, b) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> protoFunc = <span class="keyword">new</span> PrototypeFunc()</span><br><span class="line">protoFunc.sum(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceFunc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化时被调用，为实例化对象增加方法</span></span><br><span class="line"><span class="keyword">const</span> instanceFunc = <span class="keyword">new</span> InstanceFunc()</span><br><span class="line">instanceFunc.sum(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="创建子类"><a href="#创建子类" class="headerlink" title="创建子类"></a>创建子类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(weight, height) &#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speck() &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">man</span> <span class="keyword">extends</span> <span class="title">human</span> </span>&#123;</span><br><span class="line">  listen() &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> man(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">  	<span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speck() &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  listen() &#123;</span><br><span class="line">  	<span class="keyword">super</span>.speck()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> l = <span class="keyword">new</span> Lion(<span class="string">'Mickey'</span>)</span><br><span class="line">l.speck() <span class="comment">// 'Mickey'</span></span><br><span class="line">l.listen() <span class="comment">// 'Mickey'</span></span><br></pre></td></tr></table></figure>











]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的面向对象</title>
    <url>/2019/12/05/js%E4%B8%AD%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>输出结果: 1，按照其他语言的特性来说，a没有声明就使用，会报错，这里<code>var a;</code>声明了变量，<code>var a;这个动作会提升至作用域的最上面，所有a不是未声明。</code></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下定时器</title>
    <url>/2019/12/05/linux%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>signl相关的函数</p>
<h3 id="1、signal"><a href="#1、signal" class="headerlink" title="1、signal"></a>1、signal</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure>

<p>参数一：是一个信号。 除了SIGKILL和SIGSTOP外的任何一种信号</p>
<p>参数二：</p>
<ol>
<li>无返回值的函数地址</li>
<li>SIG_IGN：忽略参数signum所指的信号</li>
<li>SIG_DFL：恢复系统对信号的默认处理</li>
</ol>
<p>注：当一个信号的信号处理函数执行时，如果进程又接收到了该信号，该信号会自动被储存而不会中断信号处理函数的执行，直到信号处理函数执行完毕再重新调用相应的处理函数。但是如果在信号处理函数执行时进程收到了其它类型的信号，该函数的执行就会被中断</p>
<h3 id="2、kill"><a href="#2、kill" class="headerlink" title="2、kill"></a>2、kill</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br></pre></td></tr></table></figure>

<ol>
<li>如果参数pid是正数，那么该调用将信号sig发送到进程号为pid的进程</li>
<li>如果pid等于0，那么信号sig将发送给当前进程所属进程组里的所有进程</li>
<li>如果参数pid等于-1，信号sig将发送给除了进程1和自身以外的所有进程</li>
<li>如果参数pid小于-1，信号sig将发送给属于进程组-pid的所有进程</li>
<li>如果参数sig为0，将不发送信号</li>
</ol>
<h3 id="3、-pause"><a href="#3、-pause" class="headerlink" title="3、 pause"></a>3、 pause</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pause(void);</span><br></pre></td></tr></table></figure>

<p>当前的进程暂停（进入睡眠状态），直到被信号(signal)所中断</p>
<h3 id="4、alarm"><a href="#4、alarm" class="headerlink" title="4、alarm"></a>4、alarm</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds);</span><br></pre></td></tr></table></figure>

<p>说明：后一次设定将取消前一次的设定<br>注：一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替<br>返回值：返回上一个闹钟时间的剩余时间，否则返回0<br>信号：SIGALRM</p>
<h3 id="5、setitimer"><a href="#5、setitimer" class="headerlink" title="5、setitimer"></a><strong>5、setitimer</strong></h3><p>要求不太精确的话，使用alarm()和signal()就行了，但是如果想要实现精度较高的定时功能的话，就要使用setitimer函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">//下一次的取值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">//本次的设定值</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;    <span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;   <span class="comment">//微秒，1秒 = 1000000 微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参数一：</p>
<ol>
<li>ITIMER_REAL: 以系统真实的时间来计算，它送出SIGALRM信号</li>
<li>ITIMER_VIRTUAL: -以该进程在用户态下花费的时间来计算，它送出SIGVTALRM信号</li>
<li>ITIMER_PROF: 以该进程在用户态下和内核态下所费的时间来计算，它送出SIGPROF信号</li>
</ol>
<p>it_interval：指定间隔时间<br>it_value：指定初始定时时间</p>
<ol>
<li>如果只指定it_value，就是实现一次定时</li>
<li>如果同时指定 it_interval，则超时后，系统会重新初始化it_value为it_interval，实现重复定时</li>
<li>两者都清零，则会清除定时器</li>
</ol>
<p>tv_sec：提供秒级精度<br>tv_usec：提供微秒级精度，以值大的为先<br>old_value：用来保存先前的值，常设为NULL</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM,<span class="built_in">print</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">t</span>;</span></span><br><span class="line"> </span><br><span class="line">    t.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">    t.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    t.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    t.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL,&amp;t,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(;;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令</title>
    <url>/2019/12/05/linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>用来查找本地程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis -- locate programs</span><br></pre></td></tr></table></figure>

<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>在用户路径中定位程序文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which -- locate a program file in the user's path</span><br><span class="line"></span><br><span class="line">which [-as] program ...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200102225812732.png" alt="image-20200102225812732"></p>
<h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>


<h2 id="硬链接和软连接"><a href="#硬链接和软连接" class="headerlink" title="硬链接和软连接"></a>硬链接和软连接</h2><p>我们都知道，在linux系统中，本质上是通过inode(index node)来对文件进行访问（或者说数据控制）的。linux的人性化设置，使得平时我们可以通过文件名来访问文件。其实吧，不是一般性的说，<strong>文件名，就是inode的别名。</strong></p>
<p><strong>认识目录项，inode以及block</strong></p>
<p>这里有几个简单的知识点：</p>
<ol>
<li>一个文件可以被存储在一个或者多个block中；</li>
<li>每个文件都会并且<code>只能占用一个inode</code>,inode可以指向该文件所在的block，inode中还存储该文件的各种属性，如rwx…;</li>
<li>想读取该文件，必须经过目录项的文件名来指向到正确的inode号码才能读取。</li>
</ol>
<p>看到这里，该提出两个问题了：</p>
<ol>
<li><strong>什么是目录项？</strong>当新建一个目录时，文件系统会分配一个inode和至少一块block给该目录。其中，inode记录该目录的相关权限和属性，并记录分配到的那块block号码。而<strong>block则是记录在这个目录下的文件名和这些文件名所对应的inode号码数据，这就是我们所说的数据项</strong>。</li>
<li><strong>当几个不同文件名，指向同一个inode号码时，会发生什么事？</strong>这就引出了我们要说的内容了，硬连接（hard link）和软连接（symbolic link）。<br>这幅图可以完美说明这一切：</li>
</ol>
<p>软连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s myfile soft //dest相当于source的快捷方式，可以是目录</span><br></pre></td></tr></table></figure>


<p>硬链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln myfile hard ##只能是文件</span><br></pre></td></tr></table></figure>


<ul>
<li>硬链接： 与普通文件没什么不同，<code>inode</code> 都指向同一个文件在硬盘中的区块</li>
<li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</li>
</ul>
<h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free #查看内存</span><br><span class="line"></span><br><span class="line">df #查看磁盘</span><br><span class="line"></span><br><span class="line">top #查看cpu占用率</span><br><span class="line"></span><br><span class="line">uname #查看内核版本</span><br></pre></td></tr></table></figure>

<h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><h3 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h3><p>（1）sftp xxx.xxx.xxx.xxx 登入（默认root用户），若指定用户sftp <a href="mailto:username@xxx.xxx.xxx.xxx">username@xxx.xxx.xxx.xxx</a> 进行登录</p>
<p>（2）登入成功后，会提示输入密码</p>
<p>（3）进入目录，ls查看目录下内容</p>
<p>（4）cd切换目录，get获取文件，put上传文件</p>
<p>（5）quit / bye / exit 退出sftp</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls 查看当前目录下文件</span><br><span class="line">help 查看sftp支持哪些命令</span><br><span class="line">cd 指定目录</span><br><span class="line">pwd 查看当前目录</span><br><span class="line">get xxx.txt 下载xxx文件</span><br><span class="line">put xxx.txt 上传文件</span><br></pre></td></tr></table></figure>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p><strong>centos</strong></p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install openssh-server</span><br></pre></td></tr></table></figure>

<p>查看是否开放22端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -nL</span><br></pre></td></tr></table></figure>
<p>开启sshd服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service sshd start</span><br></pre></td></tr></table></figure>

<p>重新启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure>

<p>设置开机自启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig sshd on</span><br></pre></td></tr></table></figure>
<p>检查 sshd 服务是否已经开启，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -e | grep sshd</span><br></pre></td></tr></table></figure>

<p>检查 <strong>22</strong> 号端口是否开启监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -an | grep 22</span><br></pre></td></tr></table></figure>

<h3 id="怎么使用ssh免密登入服务器"><a href="#怎么使用ssh免密登入服务器" class="headerlink" title="怎么使用ssh免密登入服务器"></a>怎么使用ssh免密登入服务器</h3><p>客户端生成ssh key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>在客户机的客户目录下会生成 <strong>.ssh</strong>目录</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1580882279416.png" alt="1580882279416"></p>
<p>里面会包含id_rsa、id_rsa.pub(密钥和公钥)，将id_rsa.pub 传到服务器上。</p>
<p>登入服务端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br><span class="line">chmod 700 -R .ssh</span><br><span class="line"></span><br><span class="line">touch ~/.ssh/authorized_keys</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  #将客户机上的公钥写入 authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl</span><br><span class="line"></span><br><span class="line">wget</span><br><span class="line"></span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line">mtr</span><br><span class="line"></span><br><span class="line">host</span><br><span class="line"></span><br><span class="line">whois</span><br><span class="line"></span><br><span class="line">dhclient</span><br><span class="line"></span><br><span class="line">netstat</span><br><span class="line"></span><br><span class="line">ps -ax|grep 程序名称</span><br><span class="line"></span><br><span class="line">lsof -i:8000  # 查看端口占用</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下进程堆栈查看gstack</title>
    <url>/2020/06/20/linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%A0%86%E6%A0%88%E6%9F%A5%E7%9C%8Bgstack/</url>
    <content><![CDATA[<h2 id="gstack安装"><a href="#gstack安装" class="headerlink" title="gstack安装"></a>gstack安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gdb -y</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gstack pid</span><br></pre></td></tr></table></figure>

<p>先获取需要查看的进程 ps -ef</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gstack 29913</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200620214020985.png" alt="image-20200620214020985"></p>
]]></content>
  </entry>
  <entry>
    <title>linux API</title>
    <url>/2020/05/23/linux-API/</url>
    <content><![CDATA[<h1 id="linux-API"><a href="#linux-API" class="headerlink" title="linux-API"></a>linux-API</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>头文件unistd.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure>

<ul>
<li>pid_t: 成功调用则返回两个值，子进程返回0，父进程返回子进程返回<code>子进程ID</code>;否则，出错返回-1.</li>
</ul>
<p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/20160909221749058.jpg" alt="img"></p>
<p>从图中我们可以看出除了正文段外，子进程的所有其它段都分配了物理空间，并将父进程的相关内容拷贝过来。父进程的task_struct结构中的打开文件描述符，进程组ID，。</p>
<p>关于父子进程共享文件描述符</p>
<p>如果一个进程打开了一个文件以后，创建子进程，子进程会继承父进程的环境和<strong>上下文</strong>中的大部分内容，包括文件描述符。此时父子进程享有相同的文件偏移量，执行相同的程序读取文件中的字符。程序执行结果是随机的，可能是父进程先读，产生一个偏移，再由子进程读其相邻字符，也可能结果相反。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"程序开始运行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after fork()"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//子进程从这里开始执行的</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子进程创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"父进程创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程创建失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"程序运行结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序开始运行</span><br><span class="line">after fork()</span><br><span class="line">父进程创建</span><br><span class="line">after fork()</span><br><span class="line">子进程创建</span><br><span class="line">程序运行结束</span><br><span class="line">程序运行结束</span><br></pre></td></tr></table></figure>

<p>相关的一些函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getpid() &#x2F;&#x2F;获取进程id</span><br><span class="line">getppid() &#x2F;&#x2F;获取父进程id</span><br></pre></td></tr></table></figure>

<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h2><p>头文件：<code>unistd.h</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid_t vfork(void);</span><br></pre></td></tr></table></figure>

<p>vfork()函数也用于创建一个新进程，vfork创建的子进程与父进程共享数据段。</p>
<ul>
<li>vfork创建的进程保证子进程先运行，只有子进程通过exec或者exit之后走，父进程才能运行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建子进程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// num = 3;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建父进程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"num:"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程创建失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么会有fork"><a href="#为什么会有fork" class="headerlink" title="为什么会有fork"></a>为什么会有fork</h3><p>因为以前的fork当它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，</p>
<p>并且在儿子“霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec或者exit后，相当于儿子买了自己的房子了，这时候就相当于分家了。此时vfork保证子进程先运行，在她调用exec或exit之后父进程才可能被调度运行。 </p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone </p>
<p>clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。 </p>
<p>没有复制的数据结构则通过指针的复制让子进程共享（arg）,具体要复制的资源，则可以通过flags进行制定，并返回子进程的PID。</p>
<p>头文件: <code>sched.h</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure>

<p>flags:</p>
<table>
<thead>
<tr>
<th>Namespace 分类</th>
<th>系统调用参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>提供了主机名相关的设置</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>提供了文件系统相关的挂载，用于复制和文件系统相关的资源</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>提供了独立的进程空间支持</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>提供了网络相关支持</td>
</tr>
</tbody></table>
<p>一个进程主要由四个要素组成：</p>
<p>1.一段需要执行</p>
<p>2.进程自己的专用堆栈空间</p>
<p>3.进程控制块（PCB）</p>
<p>4.进程专有的Namespace</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIBER_STACK 8192</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_something</span><span class="params">(<span class="keyword">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is son, the pid is:%d, the a is: %d\n"</span>, getpid(), ++a);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>); <span class="comment">//这里我也不清楚，如果这里不释放，不知道子线程死亡后，该内存是否会释放</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(FIBER_STACK); <span class="comment">//为子进程申请系统堆栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The stack failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creating son thread!!!\n"</span>);</span><br><span class="line"></span><br><span class="line">    clone(&amp;do_something, (<span class="keyword">char</span> *)<span class="built_in">stack</span> + FIBER_STACK, CLONE_VM | CLONE_VFORK, <span class="number">0</span>); <span class="comment">//创建子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is father, my pid is: %d, the a is: %d\n"</span>, getpid(), a);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>头文件：unistd.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sleep(5); &#x2F;&#x2F;停5秒</span><br></pre></td></tr></table></figure>



<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>夺舍进程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>l (list)                           命令行参数列表</p>
</li>
<li><p>p (path)                       搜素file时使用path变量</p>
</li>
<li><p>v (vector)                    使用命令行参数数组</p>
</li>
<li><p>e (environment)       使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p>
</li>
</ul>
<h2 id="sethostname"><a href="#sethostname" class="headerlink" title="sethostname"></a>sethostname</h2><p> 这个系统调用能够设置我们的主机名 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sethostname(const char *name, size_t len);</span><br></pre></td></tr></table></figure>



<h2 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h2><p> 可以改变我们程序的运行目录 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int chdir(const char *path);</span><br></pre></td></tr></table></figure>



<h2 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h2><p> 这个系统调用能够用于设置根目录 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int chroot(const char *path);</span><br></pre></td></tr></table></figure>



<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p> 这个系统调用用于挂载文件系统 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mount(const char *source, const char *target,</span><br><span class="line">                 const char *filesystemtype, unsigned long mountflags,</span><br><span class="line">                 const void *data);</span><br></pre></td></tr></table></figure>


















]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>mac下Vscode打开zsh终端乱码</title>
    <url>/2020/03/15/mac%E4%B8%8BVscode%E6%89%93%E5%BC%80zsh%E7%BB%88%E7%AB%AF%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200315231311169.png" alt="image-20200315231311169"></p>
<p>字体: <code>Meslo LG M for Powerline</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>go语言</title>
    <url>/2021/05/05/go%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="go"><a href="#go" class="headerlink" title="go"></a>go</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="go基本组成"><a href="#go基本组成" class="headerlink" title="go基本组成"></a>go基本组成</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main	<span class="comment">// 定义报名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>	<span class="comment">// 导入外部包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序开始执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go build hello.go</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行./hello</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>

<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>规则</p>
<ul>
<li><p>一行代表一个语句结束</p>
</li>
<li><p>标识符用来命名变量、类型等程序实体。标识符组成是字母、数字、下划线，第一个字符必须是字母或下划线而不能是数字</p>
</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>Go代码中使用25个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<p>36个预定义标识符</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><blockquote>
<p>这个部分和C语言一样，就是多了一个简短写法和类型自动推导</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准格式 声明变量</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 简短格式 定义变量</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line"><span class="comment">// 类型自动推导</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"xx"</span></span><br><span class="line">d := <span class="string">"xxx"</span></span><br><span class="line">fmt.Println(a,b,c,d)</span><br></pre></td></tr></table></figure>
<p>匿名变量</p>
<blockquote>
<p>当你不想获取一个值，可以使用_来处理</p>
<p>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a,_ :&#x3D; getdata()</span><br></pre></td></tr></table></figure>

<p>批量声明变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	name string</span><br><span class="line">	age int</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>bool</li>
<li>string</li>
<li>int、int8、int16、int32、int64</li>
<li>uint、uint8、uint16、uint32、uint64、uintptr</li>
<li>byte // uint8 的别名</li>
<li>rune // int32 的别名 代表一个 Unicode 码</li>
<li>float32、float64</li>
<li>complex64、complex128</li>
</ul>
<h3 id="如何定义字符串？"><a href="#如何定义字符串？" class="headerlink" title="如何定义字符串？"></a>如何定义字符串？</h3><p>单行字符串-<code>字符串字面量</code>，使用双引号，不能跨行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const str &#x3D; &quot;12344&quot;</span><br></pre></td></tr></table></figure>



<p>多行字符串-使用<code>反引号</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>拼接字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str :&#x3D; &quot;123&quot; + &quot;111&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; + 号必须放在第一行末尾</span><br><span class="line">str :&#x3D; &quot;1123&quot; +</span><br><span class="line">&quot;111&quot;</span><br></pre></td></tr></table></figure>

<h3 id="如何定义枚举？"><a href="#如何定义枚举？" class="headerlink" title="如何定义枚举？"></a>如何定义枚举？</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">     Arrow Weapon = <span class="literal">iota</span>    <span class="comment">// 开始生成枚举值, 默认为0</span></span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>常量生成器iota</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Weekday int	&#x2F;&#x2F; 类似typedef的</span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday &#x3D; iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="如何定义类型别名、类型声明"><a href="#如何定义类型别名、类型声明" class="headerlink" title="如何定义类型别名、类型声明"></a>如何定义类型别名、类型声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type D &#x3D; int   &#x2F;&#x2F; 类型别名</span><br><span class="line">type I int    &#x2F;&#x2F; 类型声明</span><br></pre></td></tr></table></figure>

<p>类型声明的类型是一个新的类型，只是它们的功能一样</p>
<p>类型别名它们就是一种类型</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>生命周期</p>
<ul>
<li>函数体内定义的变量</li>
<li>函数的参数和返回值</li>
</ul>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>生命周期</p>
<ul>
<li>函数体外声明的变量</li>
<li>在一个源文件中定义，所有源文件都可以使用</li>
<li>全局变量必须以var关键字开头，如果想要在外部中使用全局变量的首字母必须<code>大写</code></li>
</ul>
<p>Go语言中字符串中实现使用UTF-8编码，通过rune类型，可以方便地每个UTF-8字符进行访问。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><blockquote>
<p>和C语言差不多，目前还未发现有细节差别</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valueOfTypeB &#x3D; typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure>

<h3 id="int转换string"><a href="#int转换string" class="headerlink" title="int转换string"></a>int转换string</h3><blockquote>
<p>strconv包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Itoa(i int) string</span><br><span class="line"></span><br><span class="line">str :&#x3D; strconv.Itoa(int)</span><br></pre></td></tr></table></figure>

<h3 id="string转换int"><a href="#string转换int" class="headerlink" title="string转换int"></a>string转换int</h3><blockquote>
<p>strconv包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Atoi(s string) (i int, err error)</span><br><span class="line"></span><br><span class="line">num, err :&#x3D; strconv.Atoi(str)</span><br></pre></td></tr></table></figure>

<h3 id="Parse-系列函数"><a href="#Parse-系列函数" class="headerlink" title="Parse 系列函数"></a>Parse 系列函数</h3><blockquote>
<p>strconv包</p>
</blockquote>
<p>包含ParseBool()、ParseFloat()、ParseInt()、ParseUint()</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>长度是不可变的</p>
</blockquote>
<p>定义数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var var_name [元素数量]type</span><br></pre></td></tr></table></figure>

<p>声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a [3]int</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">a[1] &#x3D; 2</span><br><span class="line">a[2] &#x3D; 3</span><br></pre></td></tr></table></figure>

<p>声明并初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a [3]int&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">var a [...]int&#123;1,2,3,4&#125; &#x2F;&#x2F;会自动计算长度</span><br></pre></td></tr></table></figure>

<p>获取数组长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(array)</span><br></pre></td></tr></table></figure>

<p>多维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array [3][4]int&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>数组切片</p>
<blockquote>
<p>切片是一段连续的内存区域，可以是数组，也可以是切片本身</p>
<p>切片是一个引用类型，类似于Python list类型</p>
<p>长度可以变化的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a  &#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">fmt.Println(a, a[1:2])</span><br><span class="line">a[3:]	&#x2F;&#x2F; 4,5</span><br><span class="line">a[:4]	&#x2F;&#x2F; 1,2,3,4</span><br><span class="line">a[:] &#x2F;&#x2F; 1,2,3,4,5</span><br></pre></td></tr></table></figure>

<p>创建切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make( []Type, size, cap) &#x2F;&#x2F; cap预分配的数量</span><br><span class="line"></span><br><span class="line">a :&#x3D; make([]int, 2)</span><br><span class="line">b :&#x3D; make([]int, 2, 10)</span><br><span class="line">[]int&#123;&#125;</span><br><span class="line">[]int&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure>



<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>定义map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var varname map[keytype]valuetype</span><br><span class="line"></span><br><span class="line">var a map[string]int &#x2F;&#x2F; 定义一个类型为string,值为int的map</span><br></pre></td></tr></table></figure>





<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>指针变量是存储其他变量的内存地址</p>
<p>go的指针不支持加减运算</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a int &#x3D; 1</span><br><span class="line">ptr :&#x3D; &amp;a &#x2F;&#x2F; 断定义</span><br><span class="line">var ptr *int &#x3D; &amp;a</span><br></pre></td></tr></table></figure>

<p>取址符<code>&amp;</code>获取一个变量的地址</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>go语言不需要关心变量是分配在栈上或者堆上。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const name [type] &#x3D; value</span><br></pre></td></tr></table></figure>

<h2 id="批量声明常量"><a href="#批量声明常量" class="headerlink" title="批量声明常量"></a>批量声明常量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    e  &#x3D; 2.7182818</span><br><span class="line">    pi &#x3D; 3.1415926</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    a &#x3D; 1</span><br><span class="line">    b</span><br><span class="line">    c &#x3D; 2</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) &#x2F;&#x2F; &quot;1 1 2 2&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有常量的运算都是在编译器完成的，这样不仅可以减少运行时的工作，也方便其他代码的编译优化。</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func 函数名(形参) (返回值列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络学习"><a href="#网络学习" class="headerlink" title="网络学习"></a>网络学习</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span> &#123;</span><br><span class="line">	_,_ = fmt.Fprintf(w,<span class="string">"hello Golang"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>,sayHello)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">":9090"</span>,<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"http serve failed,err:%v\n"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>方法的集合</p>
<p>可以实现类似C++多态的能力</p>
</blockquote>
<p>定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type 接口类型名 interface&#123;</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空接口</p>
<blockquote>
<p>可以作为函数参数 Println 实现</p>
<p>空接口类型可以作为map的value</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type xxx interface&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go判断变量</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux知识收集</title>
    <url>/2019/12/05/linux%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="LAMP和LNMP区别是什么？"><a href="#LAMP和LNMP区别是什么？" class="headerlink" title="LAMP和LNMP区别是什么？"></a>LAMP和LNMP区别是什么？</h1><p>LAMP==Linux+Apache+Mysql+PHP</p>
<p>LNMP==Linux+Nginx+Mysql+PHP</p>
<p>LAMP是Linux+Apache+Mysql+PHP的组合方式，用的是Linux；LNMP是Linux+Nginx+Mysql+PHP的组合方式，其特点是利用Nginx的快速与轻量级，替代以前的LAMP(Linux+Apache+Mysql+PHP)的方式。由于安装方便，并且安装脚本也随时更新。</p>
<p>LAMP使用的是Apache，Apache是世界是用排名第一的<a href="https://www.baidu.com/s?wd=Web服务器&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Web服务器</a>软件，其几乎可以在所有广泛使用的计算机平台上运营，由于其跨平台和安全性被广泛使用，是最流行的Web服务端软件之一。</p>
<p>LNMP使用的是Nginx，Nginx是一款高性能额Http和反向代理服务器，也是一个AMAP/POP3/SMTP服务器，Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日，2011年6月1日，nginx 1.0.4发布。</p>
<h3 id="nginx使用"><a href="#nginx使用" class="headerlink" title="nginx使用"></a>nginx使用</h3><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reopen #重启Nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload #重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><span class="line"></span><br><span class="line">nginx -s stop #强制停止Nginx服务</span><br><span class="line"></span><br><span class="line">nginx -s quit #优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br><span class="line"></span><br><span class="line">nginx -t #检测配置文件是否有语法错误，然后退出</span><br><span class="line"></span><br><span class="line">nginx -?,-h #打开帮助信息</span><br><span class="line"></span><br><span class="line">nginx -v #显示版本信息并退出</span><br><span class="line"></span><br><span class="line">nginx -V #显示版本和配置选项信息，然后退出</span><br><span class="line"></span><br><span class="line">nginx -t #检测配置文件是否有语法错误，然后退出</span><br><span class="line"></span><br><span class="line">nginx -T #检测配置文件是否有语法错误，转储并退出</span><br><span class="line"></span><br><span class="line">nginx -q #在检测配置文件期间屏蔽非错误信息</span><br><span class="line"></span><br><span class="line">nginx -p prefix #设置前缀路径(默认是:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;)</span><br><span class="line"></span><br><span class="line">nginx -c filename #设置配置文件(默认是:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf)</span><br><span class="line"></span><br><span class="line">nginx -g directives #设置配置文件外的全局指令</span><br><span class="line"></span><br><span class="line">killall nginx #杀死所有nginx进程</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2019/11/25/makefile/</url>
    <content><![CDATA[<h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>make命令执行时，需要一个Makefile文件，make命令需要怎么样的去编译和链接程序</p>
<h2 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites...</span><br><span class="line">command</span><br></pre></td></tr></table></figure>


<h2 id="单文件编译"><a href="#单文件编译" class="headerlink" title="单文件编译"></a>单文件编译</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"hello world"</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用命令行进行编译</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>


<p>使用makefile编译</p>
<p>1.创建一个makefile文件（<code>注: 没有扩展名</code>）</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test: test.cpp</span></span><br><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>


<p><code>test</code>：最终生成的目标文件</p>
<p><code>test.cpp</code>：依赖文件</p>
<p><code>g++ test.cpp -o test</code>： 编译命令</p>
<h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span> &lt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = a[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun1.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fun1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">33</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">66</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; func1(a,<span class="number">5</span>) &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test: test.cpp fun1.o #目标文件：依赖文件</span></span><br><span class="line">g++ test.cpp fun1.o -o test	<span class="comment">#编译命令</span></span><br><span class="line"></span><br><span class="line"><span class="section">fun1.o: fun1.cpp	#[.o]文件：生成[.o]的依赖文件</span></span><br><span class="line">g++ -c fun1.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">#清理操作</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o test	<span class="comment">#删除所有[.o]文件</span></span><br></pre></td></tr></table></figure>


<p>执行操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make #执行编译</span><br><span class="line"></span><br><span class="line">make clean #执行清理操作</span><br></pre></td></tr></table></figure>


<h2 id="清零目标文件的规则"><a href="#清零目标文件的规则" class="headerlink" title="清零目标文件的规则"></a>清零目标文件的规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o test</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm *.o test</span><br><span class="line"></span><br><span class="line"><span class="comment">#.PHONY 意思表示clean是一个伪目标， 在rm命令前面加一个“-”(减号)的意思，某些文件出现问题，不需要管，继续后面的事。clean的规则不要放在文件的开头，不然就是变成make的默认目标，clean从来就是放在最后。</span></span><br></pre></td></tr></table></figure>


<h2 id="引用其他的Makefile"><a href="#引用其他的Makefile" class="headerlink" title="引用其他的Makefile"></a>引用其他的Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;  <span class="comment">#可以包含路径和通配符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line"><span class="comment">#include foo.make *.mk</span></span><br></pre></td></tr></table></figure>


<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>系统默认自动化变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$^: 代表所有的依赖文件</span><br><span class="line">$@: 代表目标</span><br><span class="line">$&lt;: 代表第一个依赖文件</span><br></pre></td></tr></table></figure>


<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">objects = main.o a.o b.o c.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用变量</span></span><br><span class="line"><span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>


<p>使用“ :=  ”操作符进行变量赋值</p>
<p>这种方法，前面的变量不能使用后面的变量，只能使用前面已经定义好的变量</p>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o	<span class="comment">#变量</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span>		    #目标文件:依赖</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c	<span class="comment">#[.o]文件为目标文件 </span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>




<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o	<span class="comment">#变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"><span class="comment">#########等价于###########</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line"></span><br><span class="line">bar.o : nar.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>

<p>上面的例子中，指明了我们的目标从$object 中获取，</p>
<p>“%.o”表明要所有以“.o”结 尾的目标，也就是“foo.o bar.o”，也就是变量$object 集合的模式，</p>
<p>而依赖模式“%.c”，则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，</p>
<p>于是，我们的 依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，</p>
<p>“​$&lt;”表示 <strong>所有的依赖目标集</strong>（也就是“foo.c bar.c”），</p>
<p>“$@”<strong>表示目标集</strong> （也就是“foo.o bar.o”）。 于是，上面的规则展开后等价于下面的规则：  </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c	<span class="comment">#这里filter函数作用，只要变量中 [.o]的内容</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el	<span class="comment">#这里filter函数作用，只要变量中 [.elc]的内容</span></span><br><span class="line">emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>mac使用</title>
    <url>/2019/12/18/mac%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>name</th>
<th>简介</th>
<th>获取方式</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a></td>
<td>markdown编辑器</td>
<td>官网免费开源</td>
</tr>
<tr>
<td><a href="https://www.u.tools/" target="_blank" rel="noopener">utools</a></td>
<td>搜索工具</td>
<td>官网免费开源</td>
</tr>
<tr>
<td><a href="https://git-fork.com/" target="_blank" rel="noopener">fork</a></td>
<td>git图形化界面工具</td>
<td>官网免费开源</td>
</tr>
<tr>
<td><a href="https://www.iina.io/" target="_blank" rel="noopener">IINA</a></td>
<td>视频播放工具</td>
<td>官网免费开源</td>
</tr>
<tr>
<td><a href="https://www.freedownloadmanager.org/zh/" target="_blank" rel="noopener">Free download manager</a></td>
<td>下载工具</td>
<td>官网免费开源</td>
</tr>
<tr>
<td><a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">Google Chrome</a></td>
<td>浏览器</td>
<td>官网免费开源</td>
</tr>
<tr>
<td><a href="https://lemon.qq.com/" target="_blank" rel="noopener">腾讯柠檬清理</a></td>
<td>清理工具</td>
<td>官网免费</td>
</tr>
<tr>
<td><a href="https://jietu.qq.com/" target="_blank" rel="noopener">腾讯看图</a></td>
<td>看图工具</td>
<td>官网免费</td>
</tr>
<tr>
<td><a href="https://kantu.qq.com/" target="_blank" rel="noopener">腾讯截图</a></td>
<td>截图工具</td>
<td>官网免费</td>
</tr>
<tr>
<td><a href="https://www.snipaste.com/" target="_blank" rel="noopener">Snipaste</a></td>
<td>截图工具</td>
<td>官网免费</td>
</tr>
<tr>
<td><a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">Clion</a></td>
<td>C++开发工具</td>
<td>官网收费</td>
</tr>
<tr>
<td><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">Pycharm</a></td>
<td>python开发工具</td>
<td>官网收费</td>
</tr>
<tr>
<td><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">webstorm</a></td>
<td>前端开发工具</td>
<td>官网收费</td>
</tr>
<tr>
<td><a href="https://www.wiz.cn/zh-cn" target="_blank" rel="noopener">为知笔记</a></td>
<td>云笔记工具</td>
<td>官网收费</td>
</tr>
<tr>
<td><a href="https://www.foxitsoftware.cn/" target="_blank" rel="noopener">福昕pdf阅读器</a></td>
<td>pdf阅读器</td>
<td>官网免费</td>
</tr>
<tr>
<td>ZenTermLite</td>
<td>ssh工具</td>
<td>AppStore</td>
</tr>
<tr>
<td>Onedrive</td>
<td>云存储</td>
<td>AppStore</td>
</tr>
<tr>
<td><a href="https://pan.baidu.com/download#pan" target="_blank" rel="noopener">百度网盘</a></td>
<td>云存储</td>
<td>官网免费</td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a></td>
<td>编辑器</td>
<td>官网免费开源</td>
</tr>
<tr>
<td>SiteSucker</td>
<td>离线网站下载神器</td>
<td>收费软件</td>
</tr>
</tbody></table>
<p>安装brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure>

<p>更新brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>刷新DNS缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>

<p>查看端口使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof</span><br><span class="line"></span><br><span class="line">lsof | less</span><br><span class="line"></span><br><span class="line">lsof -i:8080</span><br></pre></td></tr></table></figure>

<p>配置免密码登入ssh</p>
<p><a href="https://zhanqi.net/post/180814/" target="_blank" rel="noopener">https://zhanqi.net/post/180814/</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>nativefier</title>
    <url>/2019/12/22/nativefier/</url>
    <content><![CDATA[<p>nativefier 就是基于 Electron 封装的，只需要一行命令就可以生成不同平台的桌面应用程序。</p>
<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install nativefier -g</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nativefier "http://medium.com"</span><br><span class="line"></span><br><span class="line">nativefier --name "Some Awesome App" "http://medium.com"</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>nvm</title>
    <url>/2020/11/24/nvm/</url>
    <content><![CDATA[<h2 id="Mac-安装nvm"><a href="#Mac-安装nvm" class="headerlink" title="Mac 安装nvm"></a>Mac 安装nvm</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">curl -o- <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/creationix</span><span class="regexp">/nvm/v</span><span class="number">0</span>.<span class="number">33.8</span>/install.sh <span class="params">| bash</span></span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">wget -qO- <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/creationix</span><span class="regexp">/nvm/v</span><span class="number">0</span>.<span class="number">33.8</span>/install.sh <span class="params">| bash</span></span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示所有可用的版本</span><br><span class="line">nvm list</span><br><span class="line"></span><br><span class="line"># 安装版本</span><br><span class="line">nvm install 11.13.0</span><br><span class="line"></span><br><span class="line"># 使用版本</span><br><span class="line">nvm use 11.13.0</span><br><span class="line"></span><br><span class="line"># 卸载版本</span><br><span class="line">nvm uninstall 11.13.0</span><br><span class="line"></span><br><span class="line"># 显示node是运行在32位还是64位</span><br><span class="line">nvm arch</span><br><span class="line"></span><br><span class="line"># 安装node</span><br><span class="line">nvm install 11.13.0 [arch]</span><br><span class="line"></span><br><span class="line"># 开启node.js版本管理</span><br><span class="line">nvm on&#x2F;off</span><br><span class="line"></span><br><span class="line"># 设置下载代理</span><br><span class="line">nvm proxy [url]</span><br></pre></td></tr></table></figure>

<h3 id="下载node太慢"><a href="#下载node太慢" class="headerlink" title="下载node太慢"></a>下载node太慢</h3><p>Macos</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NVM_NODEJS_ORG_MIRROR&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node</span><br></pre></td></tr></table></figure>

<p>windows</p>
<p>到nvm安装的目录中settings.txt中，添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;</span><br><span class="line">npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>linux使用</title>
    <url>/2019/12/05/linux%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="显示环境变量"><a href="#显示环境变量" class="headerlink" title="显示环境变量"></a>显示环境变量</h3><ul>
<li>set显示当前shell的变量，包括当前用户的数量</li>
<li>env命令显示当前用户的变量</li>
<li>export命令显示当前导出成用户变量的shell变量</li>
</ul>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p><strong>设置临时的环境变量：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export AA&#x3D;&quot;hello world&quot;</span><br></pre></td></tr></table></figure>


<p>你可以使用<code>echo $AA</code>打印环境变量内容</p>
<p><strong>删除环境变量：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset AA</span><br></pre></td></tr></table></figure>

<p><strong>添加常用环境变量路径：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;$PATH:&#x2F;root&#x2F;&quot;</span><br></pre></td></tr></table></figure>


<p><strong>创建长期的环境变量</strong></p>
<ul>
<li>/etc/profile ：</li>
</ul>
<p>  此文件为系统的每个用户设置永久环境信息,当用户第一次登录时,该文件被执行并从/etc/profile.d目录的配置文件中搜集shell的设置.</p>
<ul>
<li>/etc/bashrc:</li>
</ul>
<p>  为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。</p>
<ul>
<li>~/.bash_profile:</li>
</ul>
<p>  <em>每个用户</em>都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件 仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p>
<ul>
<li>~/.bashrc:</li>
</ul>
<p>  该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取</p>
<ul>
<li>~/.bash_logout:</li>
</ul>
<p>  当每次退出系统(退出bash shell)时,执行该文件.</p>
<p>（1）全局配置文件<br>功能：定义全局的环境变量。<br>包含的配置文件：<br>/etc/profile<br>/etc/profile.d/*.sh<br>/etc/bashrc</p>
<p>（2）全局配置文件<br>功能：自定义当前用户的环境变量<br>包含的配置文件：<br> ~/.bash_profile<br> ~/.bashrc</p>
<h3 id="centos7-如何开放端口"><a href="#centos7-如何开放端口" class="headerlink" title="centos7 如何开放端口"></a>centos7 如何开放端口</h3><p>检查防火墙是否已经启动, running说明防火墙已经开启了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>

<p>开启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld.service</span><br></pre></td></tr></table></figure>

<p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>

<p>查看防火墙规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<p>查看22端口是否开放：yes为开放，no为未开放。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --query-port=22/tcp</span><br></pre></td></tr></table></figure>

<p>开放22端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;22&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>

<p>重新载入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="centos设置软件源"><a href="#centos设置软件源" class="headerlink" title="centos设置软件源"></a>centos设置软件源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup #备份</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo #设置阿里源</span><br><span class="line">yum makecache #生成缓存</span><br></pre></td></tr></table></figure>

<h3 id="Centos-安装man手册"><a href="#Centos-安装man手册" class="headerlink" title="Centos 安装man手册"></a>Centos 安装man手册</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y man man-pages</span><br></pre></td></tr></table></figure>



<p>linux压缩和解压</p>
<p>打包压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf filename.tar.gz pack&#x2F;  #打包压缩为一个.gz格式的压缩包</span><br><span class="line">tar -jcvf filename.tar.bz2 pack&#x2F; #打包压缩为一个.bz2格式的压缩包</span><br><span class="line">tar -Jcvf filename.tar.xz pack&#x2F;  #打包压缩为一个.xz格式的压缩包</span><br></pre></td></tr></table></figure>

<p>解包解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf filename.tar.gz &#x2F;pack  #解包解压.gz格式的压缩包到pack文件夹</span><br><span class="line">tar -jxvf filename.tar.bz2 &#x2F;pack #解包解压.bz2格式的压缩包到pack文件夹</span><br><span class="line">tar -Jxvf filename.tar.xz &#x2F;pack  #解包解压.xz格式的压缩包到pack文件夹</span><br><span class="line"></span><br><span class="line">unzip filename.zip</span><br><span class="line">tar -Zxvf filename.tar.Z</span><br><span class="line"></span><br><span class="line">tar -xvf filename.tar</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python之爬虫</title>
    <url>/2020/02/03/python%E4%B9%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><h3 id="小说爬虫"><a href="#小说爬虫" class="headerlink" title="小说爬虫"></a>小说爬虫</h3><p>获取静态页面，直接使用requests就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threadpool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">novelSpider</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, domian_url, url)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param url:小说大全url</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.domian_url = domian_url  <span class="comment"># 网站域名</span></span><br><span class="line">        self.url = url  <span class="comment"># 小说大全url</span></span><br><span class="line">        <span class="comment"># 获取每部小说的信息</span></span><br><span class="line">        self.NovelInfoList = self.getEveryNovelUrl()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求网页源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getnovelRequestText</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36'</span>&#125;</span><br><span class="line">        response = requests.get(url, headers=headers)  <span class="comment"># 带消息头请求防止网站反爬虫</span></span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取每个小说的url</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEveryNovelUrl</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :return: 返回所有小说的url和小说名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        allNovelHtml = self.getnovelRequestText(self.url)</span><br><span class="line">        <span class="comment"># print('所有网页url\n',allNovelHtml)</span></span><br><span class="line">        <span class="keyword">if</span> len(allNovelHtml) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 获取maindiv</span></span><br><span class="line">            maindiv = re.findall(<span class="string">r'&lt;div id="main"&gt;(.*?)&lt;/div&gt;'</span>, allNovelHtml, re.S)</span><br><span class="line">            <span class="comment"># print(maindiv)</span></span><br><span class="line">            <span class="keyword">if</span> len(maindiv) &gt; <span class="number">0</span>:</span><br><span class="line">                NovelInfoList = re.findall(<span class="string">r'&lt;a href="(.*?)"&gt;(.*?)&lt;'</span>, maindiv[<span class="number">0</span>], re.S)</span><br><span class="line">                <span class="comment"># print(NovelInfoList)</span></span><br><span class="line">                <span class="keyword">return</span> NovelInfoList</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分析小说url获取每章节的url和章节名</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEveryChapterUrl</span><span class="params">(self, novelUrl)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param novelUrl: 小说的url</span></span><br><span class="line"><span class="string">        :return: 每个章节的url和章节名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        novelUrl = self.domian_url + novelUrl</span><br><span class="line">        <span class="comment"># 获取小说页面</span></span><br><span class="line">        chapterInfoHtml = self.getnovelRequestText(novelUrl)</span><br><span class="line">        div = re.findall(<span class="string">r'&lt;div id="list"&gt;(.*?)&lt;/div&gt;'</span>, chapterInfoHtml, re.S)</span><br><span class="line">        <span class="keyword">if</span> len(div) &gt; <span class="number">0</span>:</span><br><span class="line">            Allchapter = re.findall(<span class="string">r'&lt;dt&gt;&lt;b&gt;.*?&lt;/dt&gt;.*?&lt;/dt&gt;(.*?)&lt;/dl&gt;'</span>, div[<span class="number">0</span>], re.S)</span><br><span class="line">            <span class="keyword">if</span> len(Allchapter) &gt; <span class="number">0</span>:</span><br><span class="line">                chapter_info_list = re.findall(<span class="string">r'href=\'(.*?)\'&gt;(.*?)&lt;'</span>, Allchapter[<span class="number">0</span>], re.S)</span><br><span class="line">                <span class="keyword">return</span> chapter_info_list</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取正文内容</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getchapterContentAndWrite</span><span class="params">(self, f, chapter_info_list)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> chapter_info <span class="keyword">in</span> chapter_info_list:</span><br><span class="line">            chapter_url = self.domian_url + chapter_info[<span class="number">0</span>]</span><br><span class="line">            chapter_title = chapter_info[<span class="number">1</span>]</span><br><span class="line">            print(chapter_url,chapter_title)</span><br><span class="line">            chapterHtml = self.getnovelRequestText(chapter_url)</span><br><span class="line">            context = re.findall(<span class="string">r'&lt;div id="content"&gt;.*?&lt;/p&gt;.*?&lt;br/&gt;(.*?)&lt;p&gt;.*?&lt;/div&gt;'</span>, chapterHtml, re.S)</span><br><span class="line">            <span class="keyword">if</span> len(context) &gt; <span class="number">0</span>:</span><br><span class="line">                afterTransContent = self.tranStr(context[<span class="number">0</span>])</span><br><span class="line">                self.writeFile(f, chapter_title, afterTransContent)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tranStr</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        context = context.replace(<span class="string">'&lt;br/&gt;'</span>, <span class="string">'\n'</span>)</span><br><span class="line">        context = context.replace(<span class="string">'&lt;br /&gt;'</span>, <span class="string">'\n'</span>)</span><br><span class="line">        context = context.replace(<span class="string">'&amp;nbsp;'</span>, <span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> context</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据清理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开文件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openFile</span><span class="params">(self, novelName)</span>:</span></span><br><span class="line">        <span class="comment"># 打开文件</span></span><br><span class="line">        <span class="keyword">return</span> open(novelName, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeFile</span><span class="params">(self, f, chapter_title, context)</span>:</span></span><br><span class="line">        f.write(chapter_title)</span><br><span class="line">        f.write(context)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        func_args = []</span><br><span class="line">        <span class="comment"># 遍历说有小说</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(self.NovelInfoList):</span><br><span class="line">            <span class="comment"># if index &lt; 3:  # 这里先爬5部</span></span><br><span class="line">            <span class="keyword">if</span> len(value) == <span class="number">2</span>:</span><br><span class="line">                func_args.append(([self, value[<span class="number">0</span>], value[<span class="number">1</span>]], <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># func_args = [([],None)]</span></span><br><span class="line">        <span class="comment"># 使用线程池进行多线程进行爬虫</span></span><br><span class="line">        pool = threadpool.ThreadPool(<span class="number">100</span>)</span><br><span class="line">        requests = threadpool.makeRequests(novelSpider.threadFun, func_args)</span><br><span class="line">        [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">        pool.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threadFun</span><span class="params">(self, novelUrl, novelName)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        一部小说一个线程</span></span><br><span class="line"><span class="string">        :param novelUrl: 小说的url</span></span><br><span class="line"><span class="string">        :param novelName: 小说名</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 小说路径</span></span><br><span class="line">        nvoelPath = os.path.join(os.getcwd(), <span class="string">"novelDir"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过小说名创建一个文件</span></span><br><span class="line">        f = self.openFile(os.path.join(nvoelPath,novelName + <span class="string">".txt"</span>))  <span class="comment"># 返回一个文件对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取一部小说的所有章节的url和名字</span></span><br><span class="line">        chapter_info_list = self.getEveryChapterUrl(novelUrl)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取正文写入文件</span></span><br><span class="line">        <span class="keyword">if</span> len(chapter_info_list) &gt; <span class="number">0</span>:</span><br><span class="line">            self.getchapterContentAndWrite(f, chapter_info_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    domian_url = <span class="string">'http://www.yuetutu.com/'</span></span><br><span class="line">    url = <span class="string">'http://www.yuetutu.com/cbook_all.html'</span></span><br><span class="line">    novelcollect = novelSpider(domian_url, url)</span><br><span class="line">    novelcollect.run()</span><br></pre></td></tr></table></figure>

<h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><p>现在很多网站都有反爬虫机制，使用selenium可以进行模拟浏览器的操作</p>
<p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<p>下载google浏览器驱动 <a href="https://mirrors.huaweicloud.com/chromedriver/" target="_blank" rel="noopener">https://mirrors.huaweicloud.com/chromedriver/</a> </p>
<p>打开chrome，输入 chrome://settings/help</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python之面向对象</title>
    <url>/2019/12/05/python%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<ul>
<li>普通方法：对象访问</li>
<li>私有方法：两个下划线开头，只能在类内部访问</li>
<li>静态方法：类和对象访问，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的</li>
<li>类方法：类和对象访问，不能和其他方法重名，不然会相互覆盖，后面定义的会覆盖前面的</li>
<li>多继承情况下：从左到右查找方法，找到为止，不然就抛出异常</li>
</ul>
<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    name=<span class="string">"Tom"</span>  <span class="comment"># 公有的类属性 相当与C++中的static修饰的变量（静态成员变量）</span></span><br><span class="line">    __age=<span class="number">18</span>    <span class="comment"># 私有的类属性</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建实例化对象</span></span><br><span class="line">p = people()</span><br><span class="line">print(p.name) <span class="comment"># 实例化对象属性</span></span><br><span class="line"><span class="comment"># print(p.__age) # 不能访问私有属性</span></span><br><span class="line"></span><br><span class="line">print(people.name)  <span class="comment"># 类对象可以直接调用，不需要实例化对象就可以使用</span></span><br><span class="line"><span class="comment"># print(people.__age) # 类对象也不能访问私有属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加实例化属性</span></span><br><span class="line">p.height = <span class="number">187</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改实例化属性</span></span><br><span class="line">p.name = <span class="string">"jack"</span></span><br><span class="line"></span><br><span class="line">print(p.height)</span><br><span class="line">print(p.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加类对象属性</span></span><br><span class="line">people.height = <span class="number">191</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改类对象属性</span></span><br><span class="line">people.name = <span class="string">"looper"</span></span><br><span class="line"></span><br><span class="line">print(people.height)</span><br><span class="line">print(people.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们给类对象增加一个属性，那我们在通过类对象创建实例，实例对象会有这个属性吗？</span></span><br><span class="line">a = people()</span><br><span class="line">print(a.height) <span class="comment">#通过测试发现真的会改变</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote>
<p>构造函数在类实例化后自动调用__init__()</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,age)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p = people(<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>上面的<em>self</em>表示实例化对象，</p>
<p><strong>构造函数</strong>的实质，就是通过类对象创建实例化对象后，实例对象添加实例属性。</p>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p> 在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__some</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"私有方法"</span>)	<span class="comment"># 私有方法以__ 开头</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">'runoob'</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure>

<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s = student(<span class="string">'ken'</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure>



<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span><span class="params">()</span>:</span></span><br><span class="line">    topic = <span class="string">''</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,t)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫 %s，我是一个演说家，我演讲的主题是 %s"</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span><span class="params">(speaker,student)</span>:</span></span><br><span class="line">    a =<span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g,t)</span>:</span></span><br><span class="line">        student.__init__(self,n,a,w,g) </span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">"Tim"</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">"Python"</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br></pre></td></tr></table></figure>

<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用父类方法'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'调用子类方法'</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br><span class="line">super(Child,c).myMethod() <span class="comment">#用子类对象调用父类已被覆盖的方法</span></span><br></pre></td></tr></table></figure>





<h2 id="super使用"><a href="#super使用" class="headerlink" title="super使用"></a>super使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示意super函数间接调用父类中被覆盖的方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.work被调用'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="string">'''B类继承A类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.work被调用'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">super_work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''调用B类自己的work方法'''</span></span><br><span class="line">        self.work()  <span class="comment"># B.work被调用，调用自身类的方法，和调用属性一样</span></span><br><span class="line">        super(B, self).work()  <span class="comment"># A.work被调用， 借助super调用父类被覆盖的方法</span></span><br><span class="line">        super().work()  <span class="comment"># A.work被调用  这种必须在方法内使用 ，可以省略（自身类）参数</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"><span class="comment"># b.work()  # B.work被调用，调自身的类</span></span><br><span class="line"><span class="comment"># super(B, b).work()  # A.work被调用(使用super是调用B的父类)</span></span><br><span class="line"><span class="comment"># super().work()  # RuntimeError: super(): no arguments   不知道调用谁，所以此种省略参数的只能在内部使用</span></span><br><span class="line">b.super_work()  <span class="comment"># 以上懂了，这回也就懂了</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python多进程multiprocessing</title>
    <url>/2020/04/18/python%E5%A4%9A%E8%BF%9B%E7%A8%8Bmultiprocessing/</url>
    <content><![CDATA[<h1 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h1><p>multiprocessing是python中多进程的包，由于python全局解释器锁的存在，导致python多线程无法使用cpu多核。</p>
<p>但是multiprocessing库带来的多进程是真正的多进程，可以让python充分使用 机器上的多个核心 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span>	<span class="comment">#进程函数</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        print(p.map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">#这里list中有3个参数表示，启动三个进程</span></span><br></pre></td></tr></table></figure>

<p>这是python文档上一个例子，使用Pool来创建线程，Pool(5)<code>表示一个进程池中最多有5给进行同时运行</code>。</p>
<h2 id="Process-类"><a href="#Process-类" class="headerlink" title="Process 类"></a><code>Process</code> 类</h2><p>通过Prcocess来创建进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(title)</span>:</span></span><br><span class="line">    print(title)</span><br><span class="line">    print(<span class="string">'module name:'</span>, __name__) <span class="comment"># 模块名</span></span><br><span class="line">    print(<span class="string">'parent process:'</span>, os.getppid()) <span class="comment"># 父进程id</span></span><br><span class="line">    print(<span class="string">'process id:'</span>, os.getpid()) <span class="comment"># 当前进程id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    info(<span class="string">'function f'</span>)	<span class="comment">#子进程调用下这个函数</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    info(<span class="string">'main line'</span>) <span class="comment"># 主进程调用这个函数</span></span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p> <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing" target="_blank" rel="noopener"><code>multiprocessing</code></a> 支持三种启动进程的方法。这些 <em>启动方法</em> 有 </p>
<p><em>spawn</em></p>
<p>父进程启动一个新的Python解释器进程。子进程只会继承那些运行进程对象的 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Process.run" target="_blank" rel="noopener"><code>run()</code></a> 方法所需的资源。特别是父进程中非必须的文件描述符和句柄不会被继承。相对于使用 <em>fork</em> 或者 <em>forkserver</em>，使用这个方法启动进程相当慢。</p>
<p>可在Unix和Windows上使用。 Windows上的默认设置。</p>
<p><em>fork</em></p>
<p>父进程使用 <a href="https://docs.python.org/zh-cn/3.7/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 来产生 Python 解释器分叉。子进程在开始时实际上与父进程相同。父进程的所有资源都由子进程继承。请注意，安全分叉多线程进程是棘手的。</p>
<p>只存在于Unix。Unix中的默认值。</p>
<p><em>forkserver</em></p>
<p>程序启动并选择* forkserver * 启动方法时，将启动服务器进程。从那时起，每当需要一个新进程时，父进程就会连接到服务器并请求它分叉一个新进程。分叉服务器进程是单线程的，因此使用 <a href="https://docs.python.org/zh-cn/3.7/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 是安全的。没有不必要的资源被继承。</p>
<p>可在Unix平台上使用，支持通过Unix管道传递文件描述符。</p>
<h2 id="multiprocessing进程间通信"><a href="#multiprocessing进程间通信" class="headerlink" title="multiprocessing进程间通信"></a>multiprocessing进程间通信</h2><p>Queue</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue() <span class="comment"># 主进程创建一个Queue</span></span><br><span class="line">    p = Process(target=f, args=(q,)) <span class="comment">#将Queue当做参数传入子进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())    <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>Pipe</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe() <span class="comment"># 创建管道，管道的每一端都有读写，当两个进程同事读或者写，管道中数据可能会损坏</span></span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<h3 id="进程间的同步"><a href="#进程间的同步" class="headerlink" title="进程间的同步"></a>进程间的同步</h3><p>Lock 进程锁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(l, i)</span>:</span></span><br><span class="line">    l.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'hello world'</span>, i)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        l.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Process(target=f, args=(lock, num)).start()</span><br></pre></td></tr></table></figure>

<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a><strong>共享内存</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    n.value = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        a[i] = -a[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = Value(<span class="string">'d'</span>, <span class="number">0.0</span>)</span><br><span class="line">    arr = Array(<span class="string">'i'</span>, range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = Process(target=f, args=(num, arr))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(num.value)</span><br><span class="line">    print(arr[:])</span><br></pre></td></tr></table></figure>

<p>服务器进程</p>
<p> 由 <code>Manager()</code> 返回的管理器对象控制一个服务器进程，该进程保存Python对象并允许其他进程使用代理操作它们。 </p>
<p> <code>Manager()</code> 返回的管理器支持类型： <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.managers.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Lock" target="_blank" rel="noopener"><code>Lock</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Semaphore" target="_blank" rel="noopener"><code>Semaphore</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.BoundedSemaphore" target="_blank" rel="noopener"><code>BoundedSemaphore</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Condition" target="_blank" rel="noopener"><code>Condition</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Event" target="_blank" rel="noopener"><code>Event</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Barrier" target="_blank" rel="noopener"><code>Barrier</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 、 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Value" target="_blank" rel="noopener"><code>Value</code></a> 和 <a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.Array" target="_blank" rel="noopener"><code>Array</code></a> 。例如 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d, l)</span>:</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line">    d[<span class="string">'2'</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">0.25</span>] = <span class="literal">None</span></span><br><span class="line">    l.reverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> manager: <span class="comment">#manger的管理数据的进程</span></span><br><span class="line">        d = manager.dict()</span><br><span class="line">        l = manager.list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        p = Process(target=f, args=(d, l))</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>python之迭代器、生成器、装饰器</title>
    <url>/2019/12/05/python%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><strong>为变量创建一个迭代器</strong></p>
<p>迭代器是访问集合元素的一种方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)	<span class="comment"># 创建迭代器对象</span></span><br><span class="line">print(next(it)) <span class="comment"># next函数读取迭代器下一个元素</span></span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it))</span><br><span class="line">print(next(it)) <span class="comment"># 抛出StopIteration异常</span></span><br></pre></td></tr></table></figure>

<p><strong>为类创建迭代器</strong></p>
<p>需要在类中实现两种方法__iter__() 与__next__()。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    x = self.a</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">    	self.a += <span class="number">1</span></span><br><span class="line">    	<span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myclass:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在python中，一边循环一边计算的机制，称为生成器：generator</p>
<p><strong>为什么要有生成器？</strong></p>
<p> 列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。 </p>
<p>如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
<p>如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。</p>
<p>简单一句话：我又想要得到庞大的数据，又想让它占用空间少，那就用生成器！</p>
<p><strong>如何创建生成器？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="comment"># 这是一个列表</span></span><br><span class="line">print(L)</span><br><span class="line"></span><br><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) <span class="comment"># 这是一个生成器</span></span><br><span class="line">print(g)</span><br></pre></td></tr></table></figure>

<p>如果一个函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。调用函数就是创建了一个生成器（generator）对象。</p>
<p>1.  生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是<strong>通过重复调用next()方法，直到捕获一个异常</strong></p>
<p>2. 带有yield的函数不是一个普通的函数，而是一个生成器generator。可用next()调用生成器对象来取值。next 两种方式 t.<strong>next</strong>() | next(t)。可用for 循环获取返回值（每执行一次，取生成器里面一个值）,基本上不会用next()来获取下一个返回值，而是直接使用for循环来迭代。</p>
<p>3. yield相当于return返回一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行。</p>
<p><strong>普通的斐波那契数列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; <span class="number">5</span>:</span><br><span class="line">        print(b)</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        current = current + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fib()</span><br></pre></td></tr></table></figure>



<p><strong>使用yield的斐波那契数列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># fib()</span></span><br><span class="line">s = fib()</span><br><span class="line">print(type(s))</span><br><span class="line">print(next(s))</span><br><span class="line">print(next(s))</span><br><span class="line">print(next(s))</span><br><span class="line">print(next(s))</span><br><span class="line">print(next(s))</span><br><span class="line"><span class="comment"># print(next(s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以遍历</span></span><br><span class="line">L = [i <span class="keyword">for</span> i <span class="keyword">in</span> fib()]</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure>

<h2 id="send-使用"><a href="#send-使用" class="headerlink" title="send() 使用"></a>send() 使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">        temp = <span class="keyword">yield</span> i</span><br><span class="line">        print(temp)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = gen()</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>因为next(f)每次执行到yield就会暂停，返回yield修饰的值，再次调用next(f) 循环继续执行，由于之前执行到yield就结束了，继续执行会从下一行执行，temp就没有赋值，所有打印中就有很多None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">        temp = <span class="keyword">yield</span> i</span><br><span class="line">        print(temp)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = gen()</span><br><span class="line">print(next(f))</span><br><span class="line">print(f.send(<span class="string">'haha'</span>))</span><br><span class="line">print(f.send(<span class="string">'haha'</span>))</span><br><span class="line">print(f.send(<span class="string">'haha'</span>))</span><br></pre></td></tr></table></figure>

<p>由于迭代器第二次执行时，tmep是没有赋值，send(“haha”)的作用使用”haha”替代<strong>yield i</strong></p>
<h2 id="应用：使用生成器退出两层循环"><a href="#应用：使用生成器退出两层循环" class="headerlink" title="应用：使用生成器退出两层循环"></a>应用：使用生成器退出两层循环</h2><p>使用标识位来退出两层循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l: list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">l2: list = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">False</span> <span class="comment"># 定义一个标识为 用来退出第二层循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> l2:</span><br><span class="line">        <span class="keyword">if</span> i + j == <span class="number">15</span>:</span><br><span class="line">            print(i)</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>使用生成器来推出两层循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l: list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">l2: list = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_func</span><span class="params">(l,l2)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l2:</span><br><span class="line">            <span class="keyword">yield</span> i,j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> generator_func(l,l2):</span><br><span class="line">    <span class="keyword">if</span> x + y == <span class="number">15</span>:</span><br><span class="line">        print(x,y)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Enter func"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>) </span><br><span class="line">    print(<span class="string">"exit func"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>我们想要打印这个函数的执行时间</p>
<p>方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">"Enter func"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"exit func"</span>)</span><br><span class="line">    print(time.time() - start)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>在函数的开始和结尾加上时间戳（time.time()）</p>
<p><strong>缺点</strong>：这方法需要修改<strong>函数定义</strong></p>
<p>方法二:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">	start = time.time()</span><br><span class="line">	func()</span><br><span class="line">	print(time.time() - start)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Enter func"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"exit func"</span>)</span><br><span class="line"></span><br><span class="line">timer(func)</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：这个方法需要修改函数的<strong>调用方式</strong></p>
<p>方法三：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Enter func"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"exit func"</span>)</span><br><span class="line"></span><br><span class="line">func = timer(func)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>使用@timer 语法糖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer # --&gt;语法糖 相当于 func = timer(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Enter func"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"exit func"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用库</title>
    <url>/2019/12/05/python%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%93/</url>
    <content><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h4 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a>json.dumps</h4><blockquote>
<p>将Python对象编码成JSON字符串</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = [ &#123; <span class="string">'a'</span> : <span class="number">1</span>, <span class="string">'b'</span> : <span class="number">2</span>, <span class="string">'c'</span> : <span class="number">3</span>, <span class="string">'d'</span> : <span class="number">4</span>, <span class="string">'e'</span> : <span class="number">5</span> &#125; ]</span><br><span class="line"></span><br><span class="line">data2 = json.dumps(data)</span><br><span class="line">print(data2)</span><br></pre></td></tr></table></figure>

<p>json.loads</p>
<blockquote>
<p>用于将JSON数据转化为Python字符串的数据类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">jsonData = <span class="string">'&#123;"a":1,"b":2,"c":3,"d":4,"e":5&#125;'</span>;</span><br><span class="line"></span><br><span class="line">text = json.loads(jsonData)</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>

<h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><blockquote>
<p>数据压缩</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/02/03/redis/</url>
    <content><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>删除所有key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;删除当前数据库中的所有Key</span><br><span class="line">flushdb</span><br><span class="line">&#x2F;&#x2F;删除所有数据库中的key</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>python数据类型</title>
    <url>/2019/12/05/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><h3 id="数字int"><a href="#数字int" class="headerlink" title="数字int"></a>数字int</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="输出二进制数0b"><a href="#输出二进制数0b" class="headerlink" title="输出二进制数0b"></a>输出二进制数0b</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(ob110011)</span><br></pre></td></tr></table></figure>

<h4 id="输出八进制数0o"><a href="#输出八进制数0o" class="headerlink" title="输出八进制数0o"></a>输出八进制数0o</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">0o123</span>)</span><br></pre></td></tr></table></figure>

<h4 id="输出十六进制数0x"><a href="#输出十六进制数0x" class="headerlink" title="输出十六进制数0x"></a>输出十六进制数0x</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">0xF15</span>)</span><br></pre></td></tr></table></figure>

<h4 id="将二进制、八进制、十六进制转换为十进制"><a href="#将二进制、八进制、十六进制转换为十进制" class="headerlink" title="将二进制、八进制、十六进制转换为十进制"></a>将二进制、八进制、十六进制转换为十进制</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(二进制数,<span class="number">2</span>)</span><br><span class="line">int(八进制数,<span class="number">8</span>)</span><br><span class="line">int(十六进制数,<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<h4 id="将十进制转换为二进制、八进制、十六进制"><a href="#将十进制转换为二进制、八进制、十六进制" class="headerlink" title="将十进制转换为二进制、八进制、十六进制"></a>将十进制转换为二进制、八进制、十六进制</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bin(十进制数)</span><br><span class="line">oct(十进制数)</span><br><span class="line">hex(十进制数)</span><br></pre></td></tr></table></figure>

<h3 id="长整型long"><a href="#长整型long" class="headerlink" title="长整型long"></a>长整型long</h3><p>在python3中没有长整型Long</p>
<h3 id="浮点数float"><a href="#浮点数float" class="headerlink" title="浮点数float"></a>浮点数float</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.1</span></span><br><span class="line">print(<span class="string">'浮点数'</span>,a)</span><br></pre></td></tr></table></figure>

<p>转换位float</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">float(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="保留小数点"><a href="#保留小数点" class="headerlink" title="保留小数点"></a>保留小数点</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(round(<span class="number">1.1234</span>,<span class="number">2</span>)) <span class="comment">#第二个参数指保留两位小数</span></span><br></pre></td></tr></table></figure>

<h4 id="取整方式"><a href="#取整方式" class="headerlink" title="取整方式"></a>取整方式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向下取整</span></span><br><span class="line">print(int(<span class="number">12.23</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向上取整</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">print(math.ceil(<span class="number">3.33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四合五入</span></span><br><span class="line">print(round(<span class="number">4.4</span>))</span><br><span class="line">print(round(<span class="number">4.6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆分整数和小数部分</span></span><br><span class="line">print(math.modf(<span class="number">4.25</span>))  <span class="comment">#返回元组 （小数部分，整数部分）</span></span><br></pre></td></tr></table></figure>

<p><strong>相关的一些方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(abs(<span class="number">-45</span>)) <span class="comment"># 绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="comment">## 比较函数</span></span><br><span class="line">print(operator.lt(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment"># less than小于，成立为True，反之False</span></span><br><span class="line"></span><br><span class="line">print(operator.le(<span class="number">2</span>,<span class="number">1</span>)) <span class="comment"># less than or equal to小于等于</span></span><br><span class="line"></span><br><span class="line">print(operator.eq(<span class="number">2</span>,<span class="number">1</span>)) <span class="comment"># equal相等</span></span><br><span class="line"></span><br><span class="line">print(operator.ne(<span class="number">2</span>,<span class="number">1</span>)) <span class="comment"># not equal不相等</span></span><br><span class="line"></span><br><span class="line">print(operator.gt(<span class="number">2</span>,<span class="number">1</span>)) <span class="comment"># greater than大于</span></span><br><span class="line"></span><br><span class="line">print(operator.ge(<span class="number">2</span>,<span class="number">1</span>)) <span class="comment"># great than or equal to大于等于</span></span><br></pre></td></tr></table></figure>

<h3 id="复数complex"><a href="#复数complex" class="headerlink" title="复数complex"></a>复数complex</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> + <span class="number">2j</span></span><br><span class="line">print(<span class="string">'复数'</span>，a)</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">'StringA'</span> <span class="comment"># 单引号字符串</span></span><br><span class="line">c = <span class="string">'StringB'</span> <span class="comment"># 双引号字符串</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拼接字符串</span></span><br><span class="line">print(b + c)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">分割字符串，首先需要确定起点与结尾，</span></span><br><span class="line"><span class="string">字符串每个字符对应的index</span></span><br><span class="line"><span class="string">-------------------------------</span></span><br><span class="line"><span class="string"> s  t  r  i  n  g  A</span></span><br><span class="line"><span class="string"> 0  1  2  3  4  5  6 #正序index</span></span><br><span class="line"><span class="string">-7 -6 -5 -4 -3 -2 -1 #逆序index</span></span><br><span class="line"><span class="string">-------------------------------</span></span><br><span class="line"><span class="string">分割规则，是左闭右开</span></span><br><span class="line"><span class="string">a = 'stringA'</span></span><br><span class="line"><span class="string">b[1:3] 分别对应index为1、2，输出tr</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(b[<span class="number">1</span>:<span class="number">3</span>]) <span class="comment"># 从index为1，开始输出到2。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出所有的字符</span></span><br><span class="line">print(b[:]) </span><br><span class="line">print(b[::]) </span><br><span class="line">print(b[<span class="number">0</span>:]) </span><br><span class="line">print(b[<span class="number">0</span>::]) </span><br><span class="line"></span><br><span class="line">print(b[::<span class="number">-1</span>]) <span class="comment">#逆序所有字符串</span></span><br><span class="line">print(b[<span class="number">-1</span>])</span><br><span class="line">print(b[<span class="number">-2</span>])</span><br><span class="line">print(b[<span class="number">-3</span>])</span><br><span class="line">print(b[<span class="number">-7</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回子串在字符串中出现的字数</span></span><br><span class="line">print(string1.count(<span class="string">'n'</span>))</span><br><span class="line">print(string1.count(<span class="string">'n'</span>,<span class="number">0</span>,<span class="number">5</span>)) <span class="comment"># 也可以指定检查的范围</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串的编解码,将字符串编码成UTF-8</span></span><br><span class="line">string1 = <span class="string">'一点半'</span></span><br><span class="line">utf8 = string1.encode(<span class="string">"UTF-8"</span>)</span><br><span class="line">print(<span class="string">'UTF-8编码格式:'</span>,utf8)</span><br><span class="line">utf8_decode = utf8.decode(<span class="string">'UTF-8'</span>,<span class="string">'strict'</span>)</span><br><span class="line">print(<span class="string">"utf8编码:%s"</span> % utf8_decode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串种的tab符号转为空格</span></span><br><span class="line">string2 = <span class="string">'hello\tworld'</span></span><br><span class="line">print(string2)</span><br><span class="line">print(string2.expandtabs(<span class="number">4</span>))</span><br><span class="line">print(string2.expandtabs(<span class="number">16</span>)) <span class="comment"># 将tab符号（'\t'）转为空格后生成的新字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于将序列中的元素以指定的字符连接生成一个新的字符串。</span></span><br><span class="line">s1 = <span class="string">'-'</span></span><br><span class="line">seq = (<span class="string">"y"</span>,<span class="string">"d"</span>,<span class="string">"b"</span>)</span><br><span class="line">print(s1.join(seq))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于创建字符映射的转换表，对于接受两个参数，第一个参数是字符串，表示需要转换的字符，第二参数也是字符串表示转换的目标。</span></span><br><span class="line"></span><br><span class="line">intab = <span class="string">"aeiou"</span></span><br><span class="line">outtab = <span class="string">"12345"</span></span><br><span class="line">trantab = str.maketrans(intab, outtab)</span><br><span class="line"></span><br><span class="line">str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> (str.translate(trantab))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串中的str1替换成str2</span></span><br><span class="line">print(<span class="string">"hello world"</span>.replace(<span class="string">'llo'</span>,<span class="string">' is'</span>,<span class="number">1</span>)) <span class="comment"># 第三个参数，替换次数不能超过max次</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串对齐方式"><a href="#字符串对齐方式" class="headerlink" title="字符串对齐方式"></a>字符串对齐方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 需要输出的字符串总长度，不够的部分使用第二给参数，从中间往两边填充</span></span><br><span class="line">print(string1.center(<span class="number">50</span>,<span class="string">'#'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个原字符串左对齐，并使用空格填充指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串</span></span><br><span class="line">print(<span class="string">"ydb"</span>.ljust(<span class="number">50</span>,<span class="string">"*"</span>)) <span class="comment"># 输出字符串的总长度为50，源字符左对齐，不够部分使用*补齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出定长字符串，源字符串右对齐，不够的部分设置固定字符。</span></span><br><span class="line">str1 = <span class="string">'yuandongbin'</span></span><br><span class="line">print(str1.rjust(<span class="number">50</span>,<span class="string">'*'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定长度的字符串，原字符串右对齐，前面填充0</span></span><br><span class="line">print(<span class="string">"this is dog"</span>.zfill(<span class="number">50</span>))</span><br></pre></td></tr></table></figure>

<h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回字符串中最大的字母</span></span><br><span class="line">print(max(<span class="string">"ydb"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串中最小的字母</span></span><br><span class="line">print(min(<span class="string">"ydb"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串的str在字符串中的最后的出现的位置。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">str -- 需要查找的字符串</span></span><br><span class="line"><span class="string">begin -- 开始查找的位置，默认为0</span></span><br><span class="line"><span class="string">end -- 结束查找位置，默认为字符串的长度</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">str1 = <span class="string">"this is dog"</span></span><br><span class="line">str2 = <span class="string">"is"</span></span><br><span class="line">print(str1.rindex(str2))</span><br><span class="line">print(str1.rindex(str2,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串最后出现的位置</span></span><br><span class="line">str1 = <span class="string">"this is dog"</span></span><br><span class="line">str2 = <span class="string">"is"</span></span><br><span class="line"></span><br><span class="line">print(str1.rfind(str2))</span><br></pre></td></tr></table></figure>

<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string1 = <span class="string">'yuandongbin'</span></span><br><span class="line"><span class="comment"># 字符串首字母大写 </span></span><br><span class="line">print(string1.capitalize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串中的所有大写字符转换为小写</span></span><br><span class="line">print(<span class="string">"123Ydb"</span>.lower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串中大写转为小写，小写转换为大写</span></span><br><span class="line">print(<span class="string">"Ydb"</span>.swapcase())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个单词的首个字母转化为大写，其余均为小写</span></span><br><span class="line">print(<span class="string">"this is Dog"</span>.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串中的小写字母转为大写字母</span></span><br><span class="line">print(<span class="string">"ydb"</span>.upper())</span><br></pre></td></tr></table></figure>

<h2 id="去除指定字符"><a href="#去除指定字符" class="headerlink" title="去除指定字符"></a>去除指定字符</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 截掉字符串左边的空格或指定重复字符。</span></span><br><span class="line">print(<span class="string">"1ydb"</span>.lstrip(<span class="string">"1"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除string字符串末尾的重复指定字符（默认为空格）</span></span><br><span class="line">print(<span class="string">"ydb1"</span>.rstrip(<span class="string">"1"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时去除头尾字符</span></span><br><span class="line">print(<span class="string">"1ydb1"</span>.strip(<span class="string">"1"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过指定分隔符对字符串进行切片，返回分割后的字符串列表</span></span><br><span class="line">str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="keyword">print</span> (str.split( ))       <span class="comment"># 以空格为分隔符</span></span><br><span class="line"><span class="keyword">print</span> (str.split(<span class="string">'i'</span>,<span class="number">1</span>))   <span class="comment"># 以 i 为分隔符</span></span><br><span class="line"><span class="keyword">print</span> (str.split(<span class="string">'w'</span>))     <span class="comment"># 以 w 为分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数keepends为False，不包含换行符，如果为True,则保留换行符。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'ab c\n\nde fg\rkl\r\n'</span>.splitlines())</span><br><span class="line">print(<span class="string">'ab c\n\nde fg\rkl\r\n'</span>.splitlines(<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<h2 id="字符串检查"><a href="#字符串检查" class="headerlink" title="字符串检查"></a>字符串检查</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断字符串是否以指定后缀结尾</span></span><br><span class="line">string1 = <span class="string">'有点不!!!'</span></span><br><span class="line">suffix = <span class="string">'!!'</span></span><br><span class="line">print(string1.endswith(suffix)) </span><br><span class="line">print(string1.endswith(suffix,<span class="number">0</span>,<span class="number">5</span>)) <span class="comment"># 开始和结束的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查字符是否是由字母和数字组成</span></span><br><span class="line">str1 = <span class="string">'ydb123'</span></span><br><span class="line">print(str1.isalnum())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查字符串中是否包含字符串str</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">str -- 指定检索的字符串</span></span><br><span class="line"><span class="string">begin -- 开始索引，默认为0</span></span><br><span class="line"><span class="string">end -- 结束索引，默认为字符串的长度</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">str1 = <span class="string">'hello world'</span></span><br><span class="line">str2 = <span class="string">'llo'</span></span><br><span class="line">print(str1.find(str2)) <span class="comment"># 返回包含字符串返回开始的索引值，否则返回-1</span></span><br><span class="line">print(str1.find(str2,<span class="number">4</span>)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串是否包含检测字符串是否只由字母或文字组成。</span></span><br><span class="line">print(str1.isalpha())</span><br><span class="line">print(<span class="string">"ydb"</span>.isalpha())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否只包含数字则返回True，否则False</span></span><br><span class="line">print(<span class="string">"123"</span>.isdigit())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串中是否由小写字母组成</span></span><br><span class="line">print(<span class="string">"abc"</span>.islower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串中是否只包含数字字符则返回True，否则返回False</span></span><br><span class="line"><span class="comment"># 数字可以是： Unicode 数字，全角数字（双字节），罗马数字，汉字数字。</span></span><br><span class="line">print(<span class="string">"123"</span>.isnumeric())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否只包含空格</span></span><br><span class="line">print(<span class="string">"  "</span>.isspace())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串中所有字母是否都为大写</span></span><br><span class="line">print(<span class="string">"YDB"</span>.isupper()) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查字符串是否以指定子字符串"xxxx"开头，是则为True，否则为False，如果beg和end指定值，则在指定范围内检查。</span></span><br><span class="line">print(<span class="string">"this is dog"</span>.startswith(<span class="string">'this'</span>))</span><br><span class="line">print(<span class="string">"this is dog"</span>.startswith(<span class="string">'this'</span>,<span class="number">8</span>))</span><br><span class="line">print(<span class="string">"this is dog"</span>.startswith(<span class="string">'this'</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查字符串是否只包含十进制字符。</span></span><br><span class="line">print(<span class="string">"ydb"</span>.isdecimal())</span><br><span class="line">print(<span class="string">"213131"</span>.isdecimal())</span><br></pre></td></tr></table></figure>

<h2 id="字符串查找-1"><a href="#字符串查找-1" class="headerlink" title="字符串查找"></a>字符串查找</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串中最大的字母</span></span><br><span class="line">print(max(<span class="string">"ydb"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串中最小的字母</span></span><br><span class="line">print(min(<span class="string">"ydb"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串的str在字符串中的最后的出现的位置。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">str -- 需要查找的字符串</span></span><br><span class="line"><span class="string">begin -- 开始查找的位置，默认为0</span></span><br><span class="line"><span class="string">end -- 结束查找位置，默认为字符串的长度</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">str1 = <span class="string">"this is dog"</span></span><br><span class="line">str2 = <span class="string">"is"</span></span><br><span class="line">print(str1.rindex(str2))</span><br><span class="line">print(str1.rindex(str2,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回字符串最后出现的位置</span></span><br><span class="line">str1 = <span class="string">"this is dog"</span></span><br><span class="line">str2 = <span class="string">"is"</span></span><br><span class="line"></span><br><span class="line">print(str1.rfind(str2))</span><br></pre></td></tr></table></figure>





<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line">d = [<span class="number">1</span>, <span class="number">1.1</span>, <span class="string">'string'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line">print(len(d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取列表元素的值  </span></span><br><span class="line">print(d[<span class="number">0</span>])</span><br><span class="line">print(d[<span class="number">1</span>])</span><br><span class="line">print(d[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表截断</span></span><br><span class="line">print(d[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新列表</span></span><br><span class="line">d.append(<span class="string">'yuandongbin'</span>)</span><br><span class="line">print(<span class="string">'更新后:'</span>,d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列表元素</span></span><br><span class="line"><span class="keyword">del</span>(d[<span class="number">3</span>])</span><br><span class="line">print(<span class="string">'删除d[3]元素后:'</span>,d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接两个列表</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">print(<span class="string">"拼接后："</span>,a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复列表</span></span><br><span class="line">a = [<span class="string">'Hi'</span>]*<span class="number">4</span></span><br><span class="line">print(<span class="string">"列表重复4倍"</span>,a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否存在列表中(el in list)</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">print(<span class="string">"元素是否在列表中"</span>,<span class="number">1</span> <span class="keyword">in</span> a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line">print(<span class="string">"开始迭代"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>]:</span><br><span class="line">    print(i)</span><br><span class="line">print(<span class="string">"迭代结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个列表</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="comment"># 比较使用operator</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表最大值和最小值</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">print(max(a))</span><br><span class="line">print(min(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># b = [1,'2','abc',4] </span></span><br><span class="line"><span class="comment"># print(max(b)) 这里列表元素中必须是同一种数据类型，不然比较会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将元组转换为列表</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(list(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往一个列表尾部添加新的列表</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计一个list中元素的个数</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">print(a.count(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取list中元素的第一个位置</span></span><br><span class="line">print(a.index(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将对象插入列表</span></span><br><span class="line">a.insert(<span class="number">3</span>,<span class="string">'yuan'</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过index移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</span></span><br><span class="line">a.pop(<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除列表中第一匹配值</span></span><br><span class="line">a.remove(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向列表中的元素</span></span><br><span class="line">a.reverse()</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># list排序</span></span><br><span class="line">a = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">a.sort() <span class="comment"># 默认升序</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">a.sort(reverse=<span class="literal">True</span>) <span class="comment"># 降序</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">stu=[(<span class="string">"winnie"</span>,<span class="string">"A"</span>,<span class="number">12</span>),(<span class="string">"lucy"</span>,<span class="string">"C"</span>,<span class="number">16</span>),(<span class="string">"john"</span>,<span class="string">"B"</span>,<span class="number">14</span>)]</span><br><span class="line"><span class="comment"># 这里的key是通过每个元组元素的第三个元素进行排序</span></span><br><span class="line">stu.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">print(stu)</span><br></pre></td></tr></table></figure>

<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建元组</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">b = (<span class="string">'yuan'</span>,<span class="string">'dong'</span>,<span class="string">'bin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元组</span></span><br><span class="line">print(a[<span class="number">1</span>])</span><br><span class="line">print(b[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元组(元组不能修改，但是可以拼接)</span></span><br><span class="line"><span class="comment"># a[0] = 100 这个修改是非法的</span></span><br><span class="line"></span><br><span class="line">c = a + b</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元组</span></span><br><span class="line"><span class="comment"># del(a[0]) 不支持 </span></span><br><span class="line">c = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">del</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素,元组类型是不可变类型，是不支持增加元素或者修改元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算元组长度</span></span><br><span class="line">print(len(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算元素出现次数</span></span><br><span class="line">print(a.count(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素第一个index</span></span><br><span class="line">print(a.index(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断对象是否在元组内</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制元组</span></span><br><span class="line">e = (<span class="string">'yuan'</span>,) *<span class="number">3</span></span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历元组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合是一种无序的并且里面存放不同元素的序列</p>
<p>特点：不重复、无序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用集合去除列表重复的元素"><a href="#使用集合去除列表重复的元素" class="headerlink" title="使用集合去除列表重复的元素"></a>使用集合去除列表重复的元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(set(f))</span><br><span class="line"></span><br><span class="line">f = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment"># 集合默认会将重复元素去除</span></span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用print输出的集合是无序的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment"># 计算集合元素个数</span></span><br><span class="line">print(len(f))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空集合</span></span><br><span class="line">f.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给集合添加元素</span></span><br><span class="line">f.add(<span class="number">1</span>) <span class="comment"># 可以添加不重复的元素</span></span><br><span class="line">print(f)  <span class="comment"># 不会有相同的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给集合添加元素或者集合</span></span><br><span class="line">f.update(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output: &#123;1, 2, 3, 4, 5, 6&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop随机删除一个元素</span></span><br><span class="line">f.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove删除指定元素,如果删除的元素不存在就会报错</span></span><br><span class="line">f.remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># discard 和remove用法一样，但是元素不存在，不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否在集合中存在</span></span><br><span class="line">print(<span class="number">2</span> <span class="keyword">in</span> f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝一个集合</span></span><br><span class="line">print(f.copy())</span><br></pre></td></tr></table></figure>

<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">set2 = set([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">print(set1.intersection(set2)) <span class="comment"># 方法一</span></span><br><span class="line">print(set1 &amp; set2) <span class="comment"># 方法二</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">print(set1.union(Set2)) <span class="comment"># 方法一</span></span><br><span class="line">print(set1 | set2) <span class="comment"># 方法二</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">print(set1.difference(set2)) <span class="comment"># 方法一</span></span><br><span class="line">print(set1 - set2)</span><br><span class="line"></span><br><span class="line">print(set2.difference(set1))</span><br><span class="line">print(set2 - set2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子集判断</span></span><br><span class="line">print(set1.issubset(set2)) <span class="comment"># 判断set1是否是set2的子集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 父集判断</span></span><br><span class="line">print(set1.issuperset(set2))</span><br></pre></td></tr></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2&#125;</span><br></pre></td></tr></table></figure>

<p>键必须是唯一，但是值则不需要。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 访问字典的值</span></span><br><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'ydb'</span>,<span class="string">'Age'</span>: <span class="string">'27'</span>&#125;</span><br><span class="line">print(dict[<span class="string">'Name'</span>])</span><br><span class="line">print(dict[<span class="string">'Age'</span>])</span><br><span class="line"><span class="comment"># 使用get方法进行获取key的值</span></span><br><span class="line">print(dict.get(<span class="string">'Name'</span>)) <span class="comment"># 返回字典key 'Name'对应的值，如果值不在字典中返回默认值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改字典, 一个值如果</span></span><br><span class="line">dict[<span class="string">'Age'</span>] = <span class="number">28</span> <span class="comment"># 更新Age</span></span><br><span class="line">dict[<span class="string">'School'</span>] = <span class="string">"菜鸟教程"</span> <span class="comment"># 添加学校</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字典元素</span></span><br><span class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>] <span class="comment"># 删除键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">dict.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除字典</span></span><br><span class="line"><span class="keyword">del</span> dict</span><br><span class="line"></span><br><span class="line">site= &#123;<span class="string">'name'</span>: <span class="string">'yuandongbin site'</span>,<span class="string">'url'</span>: <span class="string">'www.yuandongbin.xyz'</span>&#125;</span><br><span class="line">pop_obj = site.pop(<span class="string">'name'</span>,<span class="string">'xx'</span>) <span class="comment"># 返回删除的字典的value，如果key不存在，就返回默认值</span></span><br><span class="line">print(pop_obj) s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典中的键不可变，所以可以用数字，字符串或元组充当，而使用列表不行。</span></span><br><span class="line"></span><br><span class="line">dict1 = dict.copy() <span class="comment"># 深拷贝，修改dict的值不会影响拷贝之后的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断key是否在字典中</span></span><br><span class="line">print(<span class="string">'Name'</span> <span class="keyword">in</span> dict) </span><br><span class="line"></span><br><span class="line">dict.items()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典中所有的key</span></span><br><span class="line">print(dict.keys()) <span class="comment"># 返回dict_keys的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典中所有的values</span></span><br><span class="line">print(dict.values()) <span class="comment"># 返回dict_values对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加字典元素，如果key不存在于字典，添加key和value到字典</span></span><br><span class="line">dict.setdefault(key, default=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">dict2 = &#123;<span class="string">'school'</span>:<span class="string">'清华大学'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个字典增加另一个字典中</span></span><br><span class="line">dict.update(dict2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># popitem()方法随机返回并返回删除字典中的最后一对键和值</span></span><br><span class="line"></span><br><span class="line">site= &#123;<span class="string">'name'</span>: <span class="string">'yuandongbin site'</span>,<span class="string">'url'</span>: <span class="string">'www.yuandongbin.xyz'</span>&#125;</span><br><span class="line">pop_obj = site.popitem() <span class="comment"># 返回删除的字典的value，如果key不存在，就返回默认值</span></span><br><span class="line">print(pop_obj)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础知识</title>
    <url>/2019/12/05/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener">python官方文档</a></p>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="源文件的编码"><a href="#源文件的编码" class="headerlink" title="源文件的编码"></a>源文件的编码</h2><blockquote>
<p>Python默认源码文件的UTF-8</p>
</blockquote>
<p>使用其他的文件编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: cp1252 -*-</span><br></pre></td></tr></table></figure>



<h2 id="一切皆为对象"><a href="#一切皆为对象" class="headerlink" title="一切皆为对象"></a>一切皆为对象</h2><p>每一个数值、字符串、数据结构、函数、类、模块以及所有存在于Python解释器中的事务。</p>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>在Python中，对一个变量赋值，你就是创建一个指向等号右边对象第引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span> <span class="comment">#多个变量赋相同的值</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> <span class="comment">#多个变量分别赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="查看Python的关键字"><a href="#查看Python的关键字" class="headerlink" title="查看Python的关键字"></a>查看Python的关键字</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure>

<p>python单行注释以开头的，多行注释以三个单引号或者三个双引号</p>
<p>python是使用缩进来表示代码块，缩进的空格是可变的，但是同一个代码块的语句必须包含相同的缩进空格数</p>
<h3 id="变量赋值-1"><a href="#变量赋值-1" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>在Python中，对一个变量赋值，你就是创建一个指向等号右边对象第引用。</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(a,b) <span class="comment">#输出：[1, 2, 3] [1, 2, 3]</span></span><br><span class="line"> </span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">print(a,b) <span class="comment">#输出：[1, 2, 3, 4] [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>增量赋值：</p>
<p><code>x += 1</code> &lt;====&gt;   <code>x = x + 1</code></p>
<p>多重赋值：</p>
<p><code>x = y = z = 1</code></p>
<p>多元赋值：</p>
<p><code>x, y, z = 1, 2, &#39;a string&#39;</code></p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for item in range(1,4):</span><br><span class="line">print(item)</span><br><span class="line"> </span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"> </span><br><span class="line">下面我们打印下这个函数</span><br><span class="line">print(range(3))</span><br><span class="line"> </span><br><span class="line">结果：</span><br><span class="line">range(0, 3)</span><br></pre></td></tr></table></figure>




<ul>
<li>一个参数，range(n),即从0~n-1</li>
</ul>
<ul>
<li><p>两个参数，range(n,m), 即遍历的范围从n~m-1</p>
<p>循环之</p>
</li>
</ul>
<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h3><p>通过enumerate循环可以，可以获取遍历的index</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(list):</span><br><span class="line">	print(index,value)</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0 1</span></span><br><span class="line"><span class="string">1 1</span></span><br><span class="line"><span class="string">2 2</span></span><br><span class="line"><span class="string">3 3</span></span><br><span class="line"><span class="string">4 4</span></span><br><span class="line"><span class="string">5 5</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>


<h3 id="对象身份比较符"><a href="#对象身份比较符" class="headerlink" title="对象身份比较符"></a>对象身份比较符</h3><p><code>a is b</code></p>
<p>判断a 和 b是否是一个对象</p>
<p><code>a is not b</code></p>
<p>判断a 和 b不是一个对象</p>
<p><strong>应用场景</strong>：</p>
<p>判断变量是否是None，最好使用is</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br></pre></td></tr></table></figure>


<h3 id="type-和isinstance"><a href="#type-和isinstance" class="headerlink" title="type()和isinstance()"></a>type()和isinstance()</h3><p>type 获取变量的类型 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">print(type(a))</span><br></pre></td></tr></table></figure>

<p>isinstance <strong>判断一个对象是某种类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">print(isinstance(a,int)) <span class="comment">#返回bool类型值</span></span><br></pre></td></tr></table></figure>



<h3 id="多元赋值"><a href="#多元赋值" class="headerlink" title="多元赋值"></a>多元赋值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x,y,z = <span class="number">1</span>,<span class="number">2</span>,<span class="string">'string'</span></span><br></pre></td></tr></table></figure>

<h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><blockquote>
<p>print(…)    </p>
<p>print(value, …, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False)        </p>
<p>Prints the values to a stream, or to sys.stdout by default.    </p>
<p>Optional keyword arguments:    </p>
<p>file:  a file-like object (stream); defaults to the current sys.stdout.    </p>
<p>sep:   string inserted between values, default a space.    </p>
<p>end:   string appended after the last value, default a newline.    </p>
<p>flush: whether to forcibly flush the stream.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将内容输出到file</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'text.txt'</span>,w) <span class="keyword">as</span> f</span><br><span class="line">print(<span class="string">'hello world'</span>,file = f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出两个变量之间的间隔符，默认是空格，当然也可以指定</span></span><br><span class="line">print(<span class="number">1</span>,<span class="number">2</span>,sep=<span class="string">':'</span>)	<span class="comment"># output: 1:2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制字符串的结尾字符，默认是换行符'\n'</span></span><br><span class="line">print(<span class="string">'my name is '</span>,end=<span class="string">'yuandongbin'</span>) <span class="comment"># output: my name is yuandongbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flush 是否实时刷新流</span></span><br><span class="line"><span class="comment"># 一般print输出到屏幕之前，先将数据输出到内存，内存的内容不会实时刷新到屏幕上，将flush置为True，就会实时刷新显示到屏幕上。</span></span><br><span class="line">print(<span class="string">'实时刷新流'</span>，flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"the length of (%s) is %d"</span> %(<span class="string">'amdeo'</span>,len(<span class="string">'amdeo'</span>)))</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">符  号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%c</td>
<td align="left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">格式化字符串</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="left">格式化整数</td>
</tr>
<tr>
<td align="left">%u</td>
<td align="left">格式化无符号整型</td>
</tr>
<tr>
<td align="left">%o</td>
<td align="left">格式化无符号八进制数</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">格式化无符号十六进制数</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td align="left">%e</td>
<td align="left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%E</td>
<td align="left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%g</td>
<td align="left">%f和%e的简写</td>
</tr>
<tr>
<td align="left">%G</td>
<td align="left">%f 和 %E 的简写</td>
</tr>
<tr>
<td align="left">%p</td>
<td align="left">用十六进制数格式化变量的地址</td>
</tr>
</tbody></table>
<p>格式化操作符辅助指令:</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">用做左对齐</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td align="left">&lt;sp&gt;</td>
<td align="left">在正数前面显示空格</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td align="left">(var)</td>
<td align="left">映射变量(字典参数)</td>
</tr>
<tr>
<td align="left">m.n.</td>
<td align="left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody></table>
<h4 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h4><p>在 Python 中 print 默认是换行的:</p>
<p>如果不想写成自动换行的 <strong>print(i, end = ‘’ )</strong></p>
<p>列表解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[a+<span class="string">'-'</span>+b <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"ABC"</span> <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"DEF"</span>]</span><br></pre></td></tr></table></figure>

<p>元祖解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(a+<span class="string">'-'</span>+b <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"ABC"</span> <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"DEF"</span>)</span><br></pre></td></tr></table></figure>

<p>字典解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt = &#123;<span class="string">'A'</span>:<span class="number">1</span>,<span class="string">'B'</span>:<span class="number">2</span>&#125;</span><br><span class="line">&#123;value:key <span class="keyword">for</span> key,value <span class="keyword">in</span> dt.items()&#125;</span><br></pre></td></tr></table></figure>

<p>集合解析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line">&#123;i**i <span class="keyword">for</span> i <span class="keyword">in</span> s&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fun():</span><br><span class="line">	&#x2F;&#x2F; to do</span><br></pre></td></tr></table></figure>

<p>默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fun(a,b,c&#x3D;1,d&#x3D;4):</span><br><span class="line">	&#x2F;&#x2F; to do</span><br></pre></td></tr></table></figure>

<p>特殊参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210315214416491.png" alt="image-20210315214416491"></p>
<p><strong>/</strong>作为参数，后面只能使用位置参数</p>
<p>*****作为参数，后面只能使用关键字参数</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>shell数值计算</title>
    <url>/2020/05/12/shell%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h1><p>shell不可以直接进行算数运算</p>
<table>
<thead>
<tr>
<th>算术运算符</th>
<th>说明/含义</th>
</tr>
</thead>
<tbody><tr>
<td>+、-</td>
<td>加法（或正号）、减法（或负号）</td>
</tr>
<tr>
<td>*、/、%</td>
<td>乘法、除法、取余（取模）</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>++、–</td>
<td>自增和自减，可以放在变量的前面也可以放在变量的后面</td>
</tr>
<tr>
<td>!、&amp;&amp;、||</td>
<td>逻辑非（取反）、逻辑与（and）、逻辑或（or）</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>比较符号（小于、小于等于、大于、大于等于）</td>
</tr>
<tr>
<td>==、!=、=</td>
<td>比较符号（相等、不相等；对于字符串，= 也可以表示相当于）</td>
</tr>
<tr>
<td>&lt;&lt;、&gt;&gt;</td>
<td>向左移位、向右移位</td>
</tr>
<tr>
<td>~、|、 &amp;、^</td>
<td>按位取反、按位或、按位与、按位异或</td>
</tr>
<tr>
<td>=、+=、-=、*=、/=、%=</td>
<td>赋值运算符，例如 a+=1 相当于 a=a+1，a-=1 相当于 a=a-1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>运算操作符/运算命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(( ))</td>
<td>用于整数运算，效率很高，<strong>推荐使用</strong>。</td>
</tr>
<tr>
<td>let</td>
<td>用于整数运算，和 (()) 类似。</td>
</tr>
<tr>
<td>$[]</td>
<td>用于整数运算，不如 (()) 灵活。</td>
</tr>
<tr>
<td>expr</td>
<td>可用于整数运算，也可以处理字符串。比较麻烦，需要注意各种细节，不推荐使用。</td>
</tr>
<tr>
<td>bc</td>
<td>Linux下的一个计算器程序，可以处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器。</td>
</tr>
<tr>
<td>declare -i</td>
<td>将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。功能有限，仅支持最基本的数学运算（加减乘除和取余），不支持逻辑运算、自增自减等，所以在实际开发中很少使用。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo $((1+1))</span><br><span class="line">((a=1+2**3-4%3))</span><br><span class="line">echo $a</span><br><span class="line"></span><br><span class="line">b=$((1+2**3-4%3))</span><br><span class="line">echo $b</span><br><span class="line"></span><br><span class="line">echo $((2&gt;1))</span><br><span class="line"></span><br><span class="line">echo $((1==1))</span><br><span class="line"></span><br><span class="line">echo $((a++))</span><br><span class="line"></span><br><span class="line">if ((8&gt;5&amp;&amp;1==1))</span><br><span class="line">    then</span><br><span class="line">        echo "条件成立"</span><br><span class="line">    else</span><br><span class="line">        echo "条件不成立"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">let a=1+1</span><br><span class="line">echo $a</span><br><span class="line"></span><br><span class="line">a=`expr 2 + 1`</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>

<p>计算浮点数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=3.33</span><br><span class="line">b=3.3</span><br><span class="line">c=$(echo "$a + $b" | bc)</span><br><span class="line">d=$(echo "$a * $b" | bc)</span><br><span class="line">e=$(echo "scale=5; $a / $b" | bc)</span><br><span class="line">echo "c=a+b=$a+$b=$c"</span><br><span class="line">echo "d=a*b=$a*$b=$d"</span><br><span class="line">echo "e=a/b=$a/$b=$e"</span><br><span class="line"></span><br><span class="line">echo "scale=2; 10/3" | bc # scale=2 表示小数点后取2位， 不加默认是0️</span><br><span class="line"></span><br><span class="line">num1=14.5</span><br><span class="line">num2=5</span><br><span class="line">num3=32.4</span><br><span class="line">num4=`bc &lt;&lt; EOF</span><br><span class="line">scale=4</span><br><span class="line">a=($num1 / $num2)</span><br><span class="line">b=($num3 / $num2)</span><br><span class="line">a + b</span><br><span class="line">EOF`</span><br><span class="line"></span><br><span class="line">echo $num4</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>python股票自动化交易</title>
    <url>/2020/02/04/python%E8%82%A1%E7%A5%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<p>依赖库：</p>
<ul>
<li>tushare </li>
</ul>
<p>安装tushare</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install tushare</span><br></pre></td></tr></table></figure>

<p>使用<a href="http://tushare.org/" target="_blank" rel="noopener">文档</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>windows常用</title>
    <url>/2021/03/05/windows%E5%B8%B8%E7%94%A8/</url>
    <content><![CDATA[<h2 id="端口检查"><a href="#端口检查" class="headerlink" title="端口检查"></a>端口检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr &quot;443&quot;</span><br><span class="line"></span><br><span class="line">tasklist|findstr &quot;443&quot;</span><br></pre></td></tr></table></figure>

<h1 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h1><h3 id="treesize-free"><a href="#treesize-free" class="headerlink" title="treesize_free"></a>treesize_free</h3><blockquote>
<p>一款以树形结构列出目录结构的软件</p>
</blockquote>
<p><a href="https://www.jam-software.com/treesize_free" target="_blank" rel="noopener">TreeSize Free | JAM Software (jam-software.com)</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210610215317550.png" alt="image-20210610215317550"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>three.js</title>
    <url>/2021/05/09/three.js/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu</title>
    <url>/2019/12/05/ubuntu/</url>
    <content><![CDATA[<h2 id="WSL-Ubuntu"><a href="#WSL-Ubuntu" class="headerlink" title="WSL Ubuntu"></a>WSL Ubuntu</h2><p>WSL ubuntu修改root密码，登入powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu config --default-user root</span><br></pre></td></tr></table></figure>

<p>重新打开终端,使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<h2 id="修改软件源"><a href="#修改软件源" class="headerlink" title="修改软件源"></a>修改软件源</h2><h3 id="备份软件源文件"><a href="#备份软件源文件" class="headerlink" title="备份软件源文件"></a>备份软件源文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure>

<h3 id="修改文件并添加国内源"><a href="#修改文件并添加国内源" class="headerlink" title="修改文件并添加国内源"></a>修改文件并添加国内源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>



<p>下面软件源随意选择一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Ubuntu 官方源</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; gutsy-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">#网易163</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; trusty-backports main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">#清华大学软件源</span><br><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">#中科大开源</span><br><span class="line"># 默认注释了源码仓库，如有需要可自行取消注释</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get dist-upgrade</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>



<p>ubuntu的软件安装命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  更新源</span><br><span class="line">sudo apt-get install package 安装包</span><br><span class="line">sudo apt-get remove package 删除包</span><br><span class="line">sudo apt-cache search package 搜索软件包</span><br><span class="line">sudo apt-cache show package  获取包的相关信息，如说明、大小、版本等</span><br><span class="line">sudo apt-get install package --reinstall  重新安装包</span><br><span class="line">sudo apt-get -f install  修复安装</span><br><span class="line">sudo apt-get remove package --purge 删除包，包括配置文件等</span><br><span class="line">sudo apt-get build-dep package 安装相关的编译环境</span><br><span class="line">sudo apt-get upgrade 更新已安装的包</span><br><span class="line">sudo apt-get dist-upgrade 升级系统</span><br><span class="line">sudo apt-cache depends package 了解使用该包依赖那些包</span><br><span class="line">sudo apt-cache rdepends package 查看该包被哪些包依赖</span><br><span class="line">sudo apt-get source package  下载该包的源代码</span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</span><br><span class="line">sudo apt-get check 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>



<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ubuntu中vim下按上下左右键时输入A、B、C、D"><a href="#ubuntu中vim下按上下左右键时输入A、B、C、D" class="headerlink" title="ubuntu中vim下按上下左右键时输入A、B、C、D"></a>ubuntu中vim下按上下左右键时输入A、B、C、D</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim-gtk</span><br></pre></td></tr></table></figure>

<h3 id="将Ubuntu主文件夹里的中文文件夹名称改成英文"><a href="#将Ubuntu主文件夹里的中文文件夹名称改成英文" class="headerlink" title="将Ubuntu主文件夹里的中文文件夹名称改成英文"></a>将Ubuntu主文件夹里的中文文件夹名称改成英文</h3><p><strong>方法一</strong></p>
<p>首先修改现有主文件夹下各文件夹名称：</p>
<p>Desktop、 Documents、 Download、 Music、 Pictures、 Public、 Templates、 Videos ……</p>
<p>然后编辑配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gedit ~&#x2F;.config&#x2F;user-dirs.dirs</span><br></pre></td></tr></table></figure>

<p>把文件夹指向改掉，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XDG_DESKTOP_DIR&#x3D;&quot;$HOME&#x2F;Desktop&quot;</span><br><span class="line"> </span><br><span class="line">XDG_DOWNLOAD_DIR&#x3D;&quot;$HOME&#x2F;Download&quot;</span><br><span class="line"> </span><br><span class="line">XDG_TEMPLATES_DIR&#x3D;&quot;$HOME&#x2F;Templates&quot;</span><br><span class="line"> </span><br><span class="line">XDG_PUBLICSHARE_DIR&#x3D;&quot;$HOME&#x2F;Public&quot;</span><br><span class="line"> </span><br><span class="line">XDG_DOCUMENTS_DIR&#x3D;&quot;$HOME&#x2F;Documents&quot;</span><br><span class="line"> </span><br><span class="line">XDG_MUSIC_DIR&#x3D;&quot;$HOME&#x2F;Music&quot;</span><br><span class="line"> </span><br><span class="line">XDG_PICTURES_DIR&#x3D;&quot;$HOME&#x2F;Pictures&quot;</span><br><span class="line"> </span><br><span class="line">XDG_VIDEOS_DIR&#x3D;&quot;$HOME&#x2F;Videos&quot;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong></p>
<p>为了使用起来方便，装了ubuntu中文版，自然在home文件里用户目录的“桌面”、“图片”、“视频”、“音乐”……都是中文的。</p>
<p>  很多时候都喜欢在桌面上放一些要操作的文件，<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>里命令行操作又多，难免会用命令行操作桌面上的东西，那么就要 “cd 桌面”，打“桌面”的时候要输入法切换，麻烦……所以就想办法把用户目录下的路径改成英文，而其他的中文不变，方法如下：</p>
<p>打开终端，在终端中输入命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LANG&#x3D;en_US</span><br><span class="line">xdg-user-dirs-gtk-update</span><br></pre></td></tr></table></figure>

<p>跳出对话框询问是否将目录转化为英文路径,同意并关闭.<br>在终端中输入命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LANG&#x3D;zh_CN</span><br></pre></td></tr></table></figure>

<p>关闭终端,并重起.下次进入系统,系统会提示是否把转化好的目录改回中文.选择不再提示,并取消修改.主目录的中文转英文就完成了~</p>
<h3 id="Ubuntu关闭图形界面"><a href="#Ubuntu关闭图形界面" class="headerlink" title="Ubuntu关闭图形界面"></a>Ubuntu关闭图形界面</h3><p><strong>1、按ALT+CTRL+F1切换到字符界面（Linux实体机）</strong></p>
<p>如果是VMware虚拟机安装的Linux系统，则切换到字符界面的时候需要以下操作     按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F1。这样就可以切换到字符界面了。</p>
<p><strong>2、按ALT+CTRL+F7切换到图形界面（Linux实体机）</strong>    </p>
<p>如果是VMware虚拟机安装的Linux系统，则切换到图形界面的时候需要以下操作     按下ALT+CTRL+SPACE(空格)，ALT+CTRL不松开，再按F7。这样就可以切换到图形界面了。</p>
<p>在Linux中一般有ALT+CTRL+F1—-F6为字符终端（字符界面），ALT+CTRL+F7为图形界面。不同的发行版本可能有一些差别，但切换方法都是一样的。可以自己试试就可以知道哪些是字符终端，哪些是图形界面。</p>
<p>如果想 Ubuntu 在每次启动到 command prompt ，可以输入以下指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$echo “false” | sudo tee &#x2F;etc&#x2F;X11&#x2F;default-display-manager</span><br></pre></td></tr></table></figure>

<p>当下次开机时，就会以命令行模式启动（text模式，字符界面登录），如果想变回图形界面启动（X windows启动），可以输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$echo “&#x2F;usr&#x2F;sbin&#x2F;gdm” | sudo tee &#x2F;etc&#x2F;X11&#x2F;default-display-manager</span><br></pre></td></tr></table></figure>

<p>如果在Ubuntn以命令行模式启动，在字符终端想回到图形界面的话只需以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$startx</span><br></pre></td></tr></table></figure>

<h3 id="linux下多窗口分屏"><a href="#linux下多窗口分屏" class="headerlink" title="linux下多窗口分屏"></a>linux下多窗口分屏</h3><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20191113224500939.png" alt="image-20191113224500939"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本基础</title>
    <url>/2020/04/19/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><p>查看可用的shell<br><code>cat /etc/shells</code></p>
<p>查看目前使用的shell<br><code>echo $SHELL</code></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>定义变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=value</span><br><span class="line">var2='value1'</span><br><span class="line">var3="value2"</span><br></pre></td></tr></table></figure>
<p>使用变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">var1</span></span><br></pre></td></tr></table></figure>

<p><code>=号之间不能有空格</code></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>shell的变量作用域分为三种：</p>
<ul>
<li>有的变量只能在函数内使用的，被称为局部变量</li>
<li>可以在当前的shell进程中使用的，是被称为全局变量</li>
<li>有的变量还可以在子进程中使用，被称为环境变量</li>
</ul>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>shell脚本在函数中定义的变量，默认也是<code>全局变量</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">    a=99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">调用函数</span></span><br><span class="line">func</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出函数内部的变量</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>想要变量的作用域仅可以使用在函数内部，可以在定义时加上local</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">    local a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="meta">#</span><span class="bash">输出函数内部的变量</span></span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>此时的输出结果就是为空的</p>
<p>shell的全局变量<br>每一个shell进程都有自己的作用域，它们之间互不影响，<br>在shell中定义的变量，默认就是全局变量</p>
<p><code>全局变量的作用范围是当前的shell进程，而不是当前的shell脚本文件</code></p>
<h3 id="shell环境变量"><a href="#shell环境变量" class="headerlink" title="shell环境变量"></a>shell环境变量</h3><p>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用export命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</p>
<p>环境变量被创建时所处的 Shell 进程称为父进程，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 Shell 子进程。当 Shell 子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。</p>
<p><code>两个没有父子关系的Shell进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即传子不传父</code></p>
<p>如何创建shell子进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure>

<h2 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h2><p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "string" # 直接输出一个字符串</span><br><span class="line"></span><br><span class="line">url=xxx</span><br><span class="line">echo $url # 将变量输出的终端</span><br></pre></td></tr></table></figure>

<p>输入<br>read </p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>把读取的数据赋值给数组 array，从下标 0 开始。</td>
</tr>
<tr>
<td>-d</td>
<td>用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。</td>
</tr>
<tr>
<td>-e</td>
<td>在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。</td>
</tr>
<tr>
<td>-n</td>
<td>读取num个字符，而不是整行字符</td>
</tr>
<tr>
<td>-p</td>
<td>显示提示信息，提示内容为 prompt。</td>
</tr>
<tr>
<td>-r</td>
<td>原样读取（Raw mode），不把反斜杠字符解释为转义字符。</td>
</tr>
<tr>
<td>-s</td>
<td>静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。</td>
</tr>
<tr>
<td>-t</td>
<td>设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。</td>
</tr>
<tr>
<td>-u</td>
<td>使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">read -p "Enter some information &gt;" name url age</span><br><span class="line">echo "网站名字: $name"</span><br><span class="line">echo "网址：$url"</span><br><span class="line">echo "年龄：$age"</span><br></pre></td></tr></table></figure>
<p>注意，必须在一行内输入所有的值，不能换行，否则只能给第一个变量赋值，后续变量都会赋值失败。<br><code>每个输入之间需用空格</code></p>
<h2 id="如何运行shell脚本"><a href="#如何运行shell脚本" class="headerlink" title="如何运行shell脚本"></a>如何运行shell脚本</h2><p><code>交互式</code>：在Shell中一个个地输入命令并及时查看它们的输出结果，整个过程都在在跟Shell不停地互动<br><code>非交互式</code>：让所有命令批量化、一次性地执行,使用shell就是非交互式<br><code>登入式</code>：需要使用用户名和密码登入后，才可以使用shell<br><code>非登入式</code>：不需要登入直接使用shell</p>
<p>Shell一共有四种运行方式：</p>
<ul>
<li>交互式的登入的Shell</li>
<li>交互式的非登入Shell</li>
<li>非交互式的登入Shell</li>
<li>非交互式的非登入Shell</li>
</ul>
<h3 id="判断shell是否式交互式"><a href="#判断shell是否式交互式" class="headerlink" title="判断shell是否式交互式"></a>判断shell是否式交互式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $-</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出的值中包含i,表示交互式</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">himBH</span><br></pre></td></tr></table></figure>

<p>我们在shell脚本中在执行下这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo $-</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hB</span><br></pre></td></tr></table></figure>

<h2 id="判断shell是否为登入式"><a href="#判断shell是否为登入式" class="headerlink" title="判断shell是否为登入式"></a>判断shell是否为登入式</h2><p>在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shopt login_shell</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">login_shell    on    登入shi</span><br><span class="line"></span><br><span class="line">login_shell    off  非登入式</span><br></pre></td></tr></table></figure>



<p>运行方法：</p>
<p>方法一：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test.sh</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash ./test.sh   # 作为一个新程序运行</span><br></pre></td></tr></table></figure>

<h2 id="Shell命令替换"><a href="#Shell命令替换" class="headerlink" title="Shell命令替换"></a>Shell命令替换</h2><p>一般有两种方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">variable=`commands`</span><br><span class="line">variable=$(commands)</span><br></pre></td></tr></table></figure>

<p> variable 是变量名，commands 是要执行的命令。commands 可以只有一个命令，也可以有多个命令，多个命令之间以分号<code>;</code>分隔。 </p>
<p><code>将命令的输出结果赋值给某个变量</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=`date` # 多个命令使用;隔开  例如`data;ps;env`</span><br><span class="line">echo $var1</span><br></pre></td></tr></table></figure>

<h4 id="反引号和"><a href="#反引号和" class="headerlink" title="反引号和 $()"></a>反引号和 $()</h4><p><code>有些情况必须使用 $()：$() 支持嵌套，反引号不行。</code></p>
<h2 id="Shell命令行参数"><a href="#Shell命令行参数" class="headerlink" title="Shell命令行参数"></a>Shell命令行参数</h2><p>我执行shell脚本可以传递参数的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./test.sh -V</span><br></pre></td></tr></table></figure>

<p>在脚本中可以使用$1、$2 获取脚本第一个和第二个参数，<code>$0</code>第0个参数就是脚本本身</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "第一个参数: $1"</span><br><span class="line">echo "第二个参数: $2"</span><br></pre></td></tr></table></figure>

<p>给函数传递位置参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">    echo "Language: $1"</span><br><span class="line">    echo "URL: $2"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">调用函数</span></span><br><span class="line">func C++ http://c.biancheng.net/cplus/</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>如果参数个数太多，达到或者超过了 10 个，那么就得用</code>${n}<code>的形式来接收了</code></p>
<h3 id="特殊变量的使用"><a href="#特殊变量的使用" class="headerlink" title="特殊变量的使用"></a>特殊变量的使用</h3><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前脚本的文件名。</td>
</tr>
<tr>
<td>$n（n≥1）</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。当被双引号<code>&quot; &quot;</code>包含时，$@ 与 $* 稍有不同，我们将在《<a href="http://c.biancheng.net/view/vip_4559.html" target="_blank" rel="noopener">Shell $*和$@的区别</a>》一节中详细讲解。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值，我们将在《<a href="http://c.biancheng.net/view/808.html" target="_blank" rel="noopener">Shell $?</a>》一节中详细讲解。</td>
</tr>
<tr>
<td>$$</td>
<td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Process ID: $$"</span><br><span class="line">echo "File Name: $0"</span><br><span class="line">echo "First Parameter : $1"</span><br><span class="line">echo "Second Parameter : $2"</span><br><span class="line">echo "All parameters 1: $@"</span><br><span class="line">echo "All parameters 2: $*"</span><br><span class="line">echo "Total: $#"</span><br></pre></td></tr></table></figure>

<p>给函数传递参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义函数</span></span><br><span class="line">function func()&#123;</span><br><span class="line">    echo "Language: $1"</span><br><span class="line">    echo "URL: $2"</span><br><span class="line">    echo "First Parameter : $1"</span><br><span class="line">    echo "Second Parameter : $2"</span><br><span class="line">    echo "All parameters 1: $@"</span><br><span class="line">    echo "All parameters 2: $*"</span><br><span class="line">    echo "Total: $#"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">调用函数</span></span><br><span class="line">func Java http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>



<p>$*和$@的区别</p>
<ul>
<li><code>&quot;$*&quot;</code>会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。</li>
<li><code>&quot;$@&quot;</code>仍然将每个参数都看作一份数据，彼此之间是独立的。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "print each param from \"\$*\""</span><br><span class="line">for var in "$*"</span><br><span class="line">do</span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br><span class="line">echo "print each param from \"\$@\""</span><br><span class="line">for var in "$@"</span><br><span class="line">do</span><br><span class="line">    echo "$var"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>$?获取上一个命令的退出状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [ "$1" == 100 ]</span><br><span class="line">then</span><br><span class="line">   exit 0  #参数正确，退出状态为0</span><br><span class="line">else</span><br><span class="line">   exit 1  #参数错误，退出状态1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p> <code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行 test.sh，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash ./test.sh 100  #作为一个新进程运行</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<p>获取函数的返回值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">得到两个数相加的和</span></span><br><span class="line">function add()&#123;</span><br><span class="line">    return `expr $1 + $2`</span><br><span class="line">&#125;</span><br><span class="line">add 23 50  #调用函数</span><br><span class="line">echo $?  #获取函数返回值</span><br></pre></td></tr></table></figure>

<h2 id="expect-使用"><a href="#expect-使用" class="headerlink" title="expect 使用"></a>expect 使用</h2><p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install tcl-devel</span><br><span class="line">yum -y install expect</span><br></pre></td></tr></table></figure>



<p><strong>set timeout 30</strong></p>
<p>设置超时时间，单位是秒，如果设为timeout -1 意为永不超市</p>
<p><strong>spawn</strong></p>
<p>spawn是进入expect环境后才能执行的内部命令，不能直接在默认的shell环境中进行执行</p>
<p>主要功能：传递交互指令</p>
<p><strong>expect</strong></p>
<p>主要功能：判断输出结果是否包含某项字符串，没有则立即返回，否则就等待一段时间后返回，等待时间通过timeout进行设置</p>
<p><strong>send</strong></p>
<p>执行交互动作，将交互要执行的动作进行输入给交互指令</p>
<p>命令字符串串结尾加上”r”，如果出现异常等待的状态可以进行稽查</p>
<p><strong>interact</strong></p>
<p>执行完后保持交互状态，把控制权交给控制台</p>
<p>如果不加这一项，交互完成会自动退出</p>
<p><strong>exp_continue</strong></p>
<p>继续执行接下来的交互操作</p>
<p><strong>$argv</strong></p>
<p>expect脚本可以接受从bash传递过来的参数，可以使用[lindex $argv n]获得，n从0开始，分别表示第一个，第二个，第三个……参数</p>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本实战</title>
    <url>/2019/12/05/shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="shell实战"><a href="#shell实战" class="headerlink" title="shell实战"></a>shell实战</h1><p><strong>shell脚本开头</strong></p>
<p>指定一个解释器</p>
<p>以#！开头 + 解释器的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>shell脚本的执行方法</p>
<p>第一种方法：</p>
<p>使用sh命令 + 脚本路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh script.sh</span><br></pre></td></tr></table></figure>

<p>第二种方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 赋予shell脚本权限</span><br><span class="line">chmod a+x script.sh</span><br><span class="line"></span><br><span class="line">2. 执行</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure>

<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><p><strong>echo</strong></p>
<p>使用echo打印，每次代用会默认添加一个换行符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输出双引号的字符串</span></span><br><span class="line">echo "Welcome to Bash"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出不带双引号的文本</span></span><br><span class="line">echo Welcome to Bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出单引号的文本</span></span><br><span class="line">echo 'Welcome to Bash'</span><br></pre></td></tr></table></figure>

<p><strong>printf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">printf "Hello world\n"</span><br><span class="line"></span><br><span class="line">printf "%-5s %-10s %-4s\n" NO Name Mark</span><br><span class="line"><span class="meta">#</span><span class="bash"> “-” 指明一个格式为左对齐（默认的使用右对齐方式）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5s 指定一个字符串长度，不够的添加空格</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用printf不会添加换行符，需要换行需要自己增加</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><strong>定义变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">定义变量 = 左右两边不能有空格</span></span><br><span class="line">fruit=apple </span><br><span class="line">count=5</span><br></pre></td></tr></table></figure>

<p><strong>使用变量</strong></p>
<ul>
<li><p>$变量名</p>
</li>
<li><p>${变量名}</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "We have $count $&#123;fruit&#125;(s)"</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">fruit=apple</span><br><span class="line">count=5</span><br><span class="line"><span class="meta">#</span><span class="bash">变量的使用</span></span><br><span class="line">echo "We have $count $&#123;fruit&#125;(s)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">output</span></span><br><span class="line"><span class="meta">#</span><span class="bash">We have 5 apple(s)</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>

<h1 id="获取变量的长度"><a href="#获取变量的长度" class="headerlink" title="获取变量的长度"></a><strong>获取变量的长度</strong></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=0123456789</span><br><span class="line">length=$&#123;#var&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">output : 10</span></span><br></pre></td></tr></table></figure>

<h1 id="获取当前shell的版本"><a href="#获取当前shell的版本" class="headerlink" title="获取当前shell的版本"></a><strong>获取当前shell的版本</strong></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">或者</span><br><span class="line">echo $0</span><br></pre></td></tr></table></figure>

<h1 id="判断当前的用户是为超级用户"><a href="#判断当前的用户是为超级用户" class="headerlink" title="判断当前的用户是为超级用户"></a>判断当前的用户是为超级用户</h1><p>使用$UID这个变量，因为root用户的UID是0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [$UID -ne 0];then</span><br><span class="line">echo Non root user.Please run as root.</span><br><span class="line">else</span><br><span class="line">echo "Root user"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h1 id="通过shell进行数学运算"><a href="#通过shell进行数学运算" class="headerlink" title="通过shell进行数学运算"></a>通过shell进行数学运算</h1><p>let命令可以直接执行基本的算数操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">no1=4;</span><br><span class="line">no2=5;</span><br><span class="line"></span><br><span class="line">let result=no1+no2;</span><br><span class="line">echo $result</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">output：9</span></span><br></pre></td></tr></table></figure>

<p>自增和自减</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let no1++</span><br><span class="line">let no1--</span><br></pre></td></tr></table></figure>

<p>简写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let no+=6   #等价于 let no=no+6</span><br></pre></td></tr></table></figure>

<p>使用操作符[]的使用方法和let命令类似：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">no1=4;</span><br><span class="line">no2=5;</span><br><span class="line"></span><br><span class="line">result=$[no1 + no2]</span><br><span class="line"></span><br><span class="line">result=$[$no1 + 5]</span><br><span class="line"></span><br><span class="line">result=$((no1 + 50))</span><br><span class="line"></span><br><span class="line">result=`expr 3 + 4`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这些方法只能用于整数运算，而不支持浮点数</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h2><p>bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "4 * 0.56" | bc  #2.24</span><br><span class="line"></span><br><span class="line">no=54;</span><br><span class="line">result=`echo "$no * 1.5" | bc`</span><br><span class="line">echo $result</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">ourput 81.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设定小数精度（数值范围）：在下面的例子中，参数scale=2将小数位个数设置为2</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "scale=2;3/8" | bc</span><br><span class="line"><span class="meta">#</span><span class="bash">output 0.37</span></span><br></pre></td></tr></table></figure>

<p>参数scale=2将小数位个数设置为2</p>
<ul>
<li>进制转换：用bc可以将一种进制系统转换为另一种，来看看如何将十进制转换成二进制，然后再将二进制转换回十进制：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">no=100</span><br><span class="line">echo "obase=2;$no" | bc</span><br><span class="line"></span><br><span class="line">no=1100100</span><br><span class="line">echo "obase=10;ibase=2;$no" | bc</span><br></pre></td></tr></table></figure>

<p>obase=2 二进制 obase=10 十进制</p>
<h2 id="计算平方以及平方根："><a href="#计算平方以及平方根：" class="headerlink" title="计算平方以及平方根："></a>计算平方以及平方根：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "sqrt(100)" | bc #Square root</span><br><span class="line">echo "10^10" | bc #Square</span><br></pre></td></tr></table></figure>



<h1 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "This is a sample text 1" &gt; temp.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>先清空temp.txt文件内容</li>
<li>将“This is  a sample text 1” 写入文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "This is a sample text 2" &gt;&gt; temp.txt</span><br></pre></td></tr></table></figure>

<p>将输出的内容以追加的方式写入文件中。</p>
<h1 id="数组和关联数组"><a href="#数组和关联数组" class="headerlink" title="数组和关联数组"></a>数组和关联数组</h1><p>定义一个数组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_var=(1 2 3 4 5 6)</span><br></pre></td></tr></table></figure>

<p>数组赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_var[0]="test1"</span><br><span class="line">array_var[1]="test2"</span><br><span class="line">array_var[2]="test3"</span><br><span class="line">array_var[3]="test4"</span><br><span class="line">array_var[4]="test5"</span><br><span class="line">array_var[5]="test6"</span><br><span class="line"></span><br><span class="line">echo $&#123;array_var[0]&#125;</span><br></pre></td></tr></table></figure>

<p>获取所有的数组元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_var[*]</span><br></pre></td></tr></table></figure>

<h1 id="获取、设置日期和延时"><a href="#获取、设置日期和延时" class="headerlink" title="获取、设置日期和延时"></a>获取、设置日期和延时</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date</span><br><span class="line"><span class="meta">#</span><span class="bash">output: Thu Aug  1 09:50:07  2019</span></span><br></pre></td></tr></table></figure>

<p>获取秒数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date +%s</span><br><span class="line"><span class="meta">#</span><span class="bash">output: 1564653113</span></span><br></pre></td></tr></table></figure>

<p>获取星期</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date +%A #output: Sat</span><br><span class="line">date +%a #output: Saturday</span><br></pre></td></tr></table></figure>

<p>获取月</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date +%B #output: Nov</span><br><span class="line">date +%b #output: November</span><br></pre></td></tr></table></figure>

<p>获取日</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date +%d #output：01</span><br></pre></td></tr></table></figure>

<p>固定日期格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date +"%Y%m%d%H%M%S" #output: 20190801192735</span><br><span class="line"></span><br><span class="line">date +"%Y %m %d %H %M %S" #output: 2019 08 01 19 28 35</span><br><span class="line"></span><br><span class="line">date +"%d %B %Y" #output:01 August 2019</span><br></pre></td></tr></table></figure>

<h1 id="函数和参数"><a href="#函数和参数" class="headerlink" title="函数和参数"></a>函数和参数</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line">	echo $1,$2;  #访问参数1和参数2</span><br><span class="line">	echo "$@";   #以列表的方式一次性打印所有参数</span><br><span class="line">	echo "$*";	 #类似于$@,但是参数被作为实体</span><br><span class="line">	return 0;    #返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $list;</span><br><span class="line">do </span><br><span class="line">	actions;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line">for((i=0;i&lt;10;i++))</span><br><span class="line">&#123;</span><br><span class="line">	commands;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>用true作为循环条件能够产生无限循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">	conmmands;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h2><p>它的功能是一直执行循环知道给定的条件为真</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=0;</span><br><span class="line">until [$x -eq 9]; # [$x -eq 9] is the condition</span><br><span class="line">do let x++;echo $x;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>等于则为真</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于则为真</td>
</tr>
<tr>
<td>-gt</td>
<td>大于则为真</td>
</tr>
<tr>
<td>-ge</td>
<td>大于则为真</td>
</tr>
<tr>
<td>-lt</td>
<td>小于则为真</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于则为真</td>
</tr>
</tbody></table>
<ul>
<li>[-f $file_var] : 如果给定的变量包含正常的文件路径或文件名，则返回真。</li>
<li>[-x $var] : 如果给定的变量包含的文件可执行，则返回真</li>
<li>[-d $var] : 如果给定的变量包含的是目录，则返回真</li>
<li>[-e $var] : 如果给定的变量包含的文件存在，则返回真</li>
<li>[-c $var] : 如果给定的变量包含的是一个字符设备文件的路径，则返回真</li>
<li>[-b $var] : 如果给定的变量包含的是一个块设备的路径，则返回真</li>
<li>[-w $var] :如果给定的变量包含的文件可写，则返回真</li>
<li>[-r $var] : 如果给定的变量包含的文件可读，则返回真</li>
<li>[-L $var] : 如果给定的变量包含的是一个符号链接，则返回真</li>
</ul>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>使用字符串比较时，最好用双中括号，因为有时候采用单个中括号会产生错误，所以最好避开它们。</p>
<p>可以检查两个字符串</p>
<ul>
<li><code>[[ $str1 = $str2]]</code> : 当str1等于str2时，返回真，也就是说，str1和str2包含的文本是一模一样。</li>
<li><code>[[ $str1 == $str2]]</code>：这是检查字符串是否相等的另一种写法，也可以检查两个字符串是否不同。</li>
<li><code>[[ $str1 ！= $str2]]</code>：这是str1和str2不相同，则返回真。</li>
<li><code>[[$str1 &gt; $str2]]</code>: 如果str1的字母序比str2大，则返回真</li>
<li><code>[[$str1 &lt; $str2]]</code>: 如果str1的字母序比str2小，则返回真</li>
<li><code>[[-z $str1]]</code>: 如果str1包含的是空字符串，则返回真</li>
<li><code>[[-n $str1]]</code>: 如果str1包含的是非空字符串，则返回真</li>
</ul>
<h1 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h1><p>1.压缩空白行</p>
<p>文本中有多个空行需要被压缩成单个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat -s file</span><br></pre></td></tr></table></figure>

<p>2.将制表符显式^|</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat -T file.py</span><br></pre></td></tr></table></figure>

<p>3.显示行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat -n lines.txt</span><br></pre></td></tr></table></figure>

<h1 id="文件查找与文件列表find"><a href="#文件查找与文件列表find" class="headerlink" title="文件查找与文件列表find"></a>文件查找与文件列表find</h1><p>find命令的工作方式如下：沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>
<p>要列出当前目录及子目录下所有的文件和文件夹，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find base_path</span><br></pre></td></tr></table></figure>

<p>bash_path可以是任何位置，find会从改位置开始向下查找。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -print</span><br><span class="line"><span class="meta">#</span><span class="bash">打印文件和目录的列表</span></span><br></pre></td></tr></table></figure>

<p>. 指定当前目录， .. 指定父目录。</p>
<ul>
<li>-print指明打印出匹配文件的文件名（路径）。当使用-print时，’\n’作为用于分隔文件的定界符。</li>
<li>-print0指明使用’\0’作为定界符来打印每一个匹配的文件名，当文件名中包含换行符时</li>
</ul>
<p><strong>根据文件名或正则表达式匹配搜索</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name ".txt" -print</span><br><span class="line"><span class="meta">#</span><span class="bash">查找当前目录中所有的txt文件</span></span><br></pre></td></tr></table></figure>

<p>匹配多个条件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \( -name "*.txt" -o -name "*.pdf" \) -print</span><br><span class="line"><span class="meta">#</span><span class="bash">查找当前目录中所有txt和pdf文件</span></span><br></pre></td></tr></table></figure>

<p>-iregex用于忽略正则表达式的大小写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -iregex ".*\(\.py\|\.sh\)$"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">搜索py（无视大小写）和sh（无视大小写）的后缀的文件，</span></span><br></pre></td></tr></table></figure>

<p>否定参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . ! -name ".txt" -print</span><br><span class="line"><span class="meta">#</span><span class="bash">查找除了txt之外的文件</span></span><br></pre></td></tr></table></figure>

<p>目录深度搜索</p>
<ul>
<li>mindepth 最小深度</li>
<li>maxdepth 最大深度</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -mindepth 2 *</span><br></pre></td></tr></table></figure>

<p>根据文件类型搜索</p>
<p>linux文件类型包括普通文件、目录、字符设备、块设备、符号链接、硬链接、套接字以及FIFO</p>
<p>-type可以对文件搜索进行过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type d -print</span><br></pre></td></tr></table></figure>

<p>根据文件时间进行搜索</p>
<ul>
<li>访问时间（-atime）：用户最近一次访问文件的时间</li>
<li>修改时间（-mtime）：文件内容最后一次被修改的时间</li>
<li>变化时间（-ctime）：文件元数据最后一次改变的时间</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印出在最近七天被访问过的所有文件：</span></span><br><span class="line">find . -type f -atime -7 -print</span><br><span class="line"><span class="meta">#</span><span class="bash">打印出在七天前被访问过的所有文件：</span></span><br><span class="line">find . -type f -atime 7 -print</span><br><span class="line"><span class="meta">#</span><span class="bash">打印出访问时间超过七天的所有文件:</span></span><br><span class="line">find . -type f -atime +7 -print</span><br></pre></td></tr></table></figure>

<p>按分钟作为计量单位的</p>
<ul>
<li>-amin(访问时间)</li>
<li>-mmin（修改时间）</li>
<li>-cmin（变化时间）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印出访问时间超过7分钟的所有文件</span></span><br><span class="line">find . -type f -amin +7 -print</span><br></pre></td></tr></table></figure>

<p>-newer参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查找比参考文件更新的所有文件</span></span><br><span class="line">find . -type -newer file.txt -print</span><br></pre></td></tr></table></figure>

<p>基于文件大小的搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size +2k</span><br><span class="line"><span class="meta">#</span><span class="bash">大于2KB的文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size -2k</span><br><span class="line"><span class="meta">#</span><span class="bash">小于2kb的文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size 2k</span><br><span class="line"><span class="meta">#</span><span class="bash">大于等于2kB的文件</span></span><br></pre></td></tr></table></figure>

<p>-delete可用来删除find查找的匹配文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除当前目录下所有的.swp文件</span></span><br><span class="line">find . -type f -name "*.swp" -delete</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印出权限为644的文件</span></span><br><span class="line">find . -type f -perm 644 -print</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印出用户slynux拥有的所有文件</span></span><br><span class="line">find . -type f -user alynux -print</span><br></pre></td></tr></table></figure>

<p> 结合find执行命令或动作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -user root -exec chown slynux&#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h1 id="xargs命令"><a href="#xargs命令" class="headerlink" title="xargs命令"></a>xargs命令</h1><p>xargs命令把从stdin接收到的数据重新格式化，再将其作为参数提供给其他命令</p>
<p>将多行输入转换成单行输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat example.txt | xarga #将输出的文件内容，输出内容转换为一行</span><br></pre></td></tr></table></figure>

<p>将单行输入转换成多行输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat example.txt | xargs -n 3 #将输出的文件内容，输出内容转换为一行(按照空格为定界符)</span><br></pre></td></tr></table></figure>

<p>使用-d选项为输入指定一个定制的定界符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "splitXsplitXsplitXsplitXsplit" | xargs -d X</span><br><span class="line"><span class="meta">#</span><span class="bash">output: split split split split</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "splitXsplitXsplitXsplitXsplit" | xargs -d X -n 2</span><br><span class="line"><span class="meta">#</span><span class="bash">output:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">split split</span></span><br><span class="line"><span class="meta">#</span><span class="bash">split split</span></span><br></pre></td></tr></table></figure>

<h1 id="校验与核实"><a href="#校验与核实" class="headerlink" title="校验与核实"></a>校验与核实</h1><p>我们从网上下载大文件，经常要求我们校验文件完整性，将从软件中带的MD5和下载后文件生成的MD5进行比较，一样就表示文件完整，否则反之。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">md5sum script.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">output md5sum是32个字符的十六进制串</span></span><br><span class="line">4556bd00d254115c92fb55169e1567ae  script.sh</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">md5sum file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">[checksum1] file1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[checksum1] file2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[checksum1] file3</span></span><br></pre></td></tr></table></figure>

<p>生成md5文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">md5sum file &gt; file_sum.md</span><br><span class="line"></span><br><span class="line">md5su -c file_sum.md # 注意file_sum.md和待检验的文件放在同一目录中</span><br></pre></td></tr></table></figure>

<h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><p>sort命令能够帮助我们对文本文件和stdin进行排序（按行进行排序）</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat file_sum.md5</span><br><span class="line"><span class="meta">#</span><span class="bash">output: 4556bd00d254115c92fb55169e1567ae  script.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########################################################</span></span></span><br><span class="line"></span><br><span class="line">cat script.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">output: </span></span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in &#123;1..20&#125;;</span><br><span class="line">do </span><br><span class="line">echo $i;</span><br><span class="line">done;</span><br><span class="line"><span class="meta">#</span><span class="bash">djisjs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#######################################################</span></span></span><br><span class="line"></span><br><span class="line">sort file_sum.md5 script.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">output:</span></span><br><span class="line">4556bd00d254115c92fb55169e1567ae  script.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">djisjs</span></span><br><span class="line">do </span><br><span class="line">done;</span><br><span class="line">echo $i;</span><br><span class="line">for i in &#123;1..20&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可以看出上面输出将两个文件的内容进行了合并，并按照按照行的首字符进行了排序</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>按照数字进行排序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort -n file.txt</span><br></pre></td></tr></table></figure>

<p>按照逆序进行排序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort -r file.txt</span><br></pre></td></tr></table></figure>

<p>按月份进行排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort -M months.txt</span><br></pre></td></tr></table></figure>

<p>如果需要合并两个排过序的文件，而且不需要对合并后的文件再进行排序，可以使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort -m sorted1 sorted2</span><br></pre></td></tr></table></figure>

<p>按列进行排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat data.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">output:</span></span><br><span class="line">1 mac       2000</span><br><span class="line">2 winxp     4000</span><br><span class="line">3 bsd       1000</span><br><span class="line">4 linux     1000</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">依据第1列，以逆序形式排序 k:指定了排序按照哪一个键（key)来进行， r:sort命令按照逆序进行排序</span></span><br><span class="line">sort -nrk 1 data.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">output:</span></span><br><span class="line">4	linux	1000</span><br><span class="line">3	bsd     1000</span><br><span class="line">2	winxp   4000</span><br><span class="line">1	mac     2000</span><br></pre></td></tr></table></figure>

<p>-b选项</p>
<p>用于忽略文件中的前导白字符，</p>
<p>-d选项</p>
<p>用于指明以字典序进行排序</p>
<h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><p>uniq命令通过消除复杂内容，从给定输入中（stdin或命令行参数文件）找出单一的行，它也可以用来找出输入中出现的复杂行，uniq只能用于排过序的数据输入。</p>
<p>uniq命令通过消除复杂内容，从给定输入中（stdin或命令行参数文件）找出单一的行，它也可以用来找出输入中出现的复杂行，uniq只能用于排过序的数据输入。</p>
<h1 id="分割文件和数据"><a href="#分割文件和数据" class="headerlink" title="分割文件和数据"></a>分割文件和数据</h1><h2 id="spilt"><a href="#spilt" class="headerlink" title="spilt"></a>spilt</h2><p>生成一个大小为100KB的测试文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero bs=100k count=1 of=data.file</span><br></pre></td></tr></table></figure>

<p>上面的命令会创建一个伪100KB而文件内容全部是0的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将文件分割成多个更小的文件</span></span><br><span class="line">spilt -b 10k data.file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将会生成很多文件 xaa xba xac xad ..........</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split -b 10k data.file -d -a 4</span><br><span class="line"><span class="meta">#</span><span class="bash">-d 生成文件名是以数据进行结尾</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-a length就可指定后缀长度</span></span><br></pre></td></tr></table></figure>

<p>如果不想按照数据块大小进行分割，而是需要根据行数来分割文件的话，可以使用<code>-l</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split -l 10 data.file</span><br></pre></td></tr></table></figure>

<h2 id="cspilt"><a href="#cspilt" class="headerlink" title="cspilt"></a>cspilt</h2><p>cspilt是spilt工具的一个变体，spilt只能够根据大小或行数分割文件，而cspilt可以根据文本自身的特点进行分割，是否存在某个单词或文本内容都作为分割文件的条件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat server.log</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">SERVER-1</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">SERVER-2</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">SERVER-3</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br><span class="line">[connection] 192.0.0.1 xxxxx</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cspilt server.log /SERVER/ -n 2 -s &#123;*&#125; -f server -b "%02d.log" ;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">server01.log server02.log server03.log server.log</span><br></pre></td></tr></table></figure>

<ul>
<li><p>/SERVER用来匹配某一行，分割过程即从此处开始</p>
</li>
<li><p>/[REGEX]/表示文本样式。包括从当前行（第一行）直到（但不包括）包含“SERVER”的匹配行</p>
</li>
<li><p>{*}表示根据匹配重复执行分割，直到文件末尾为止。可以用{整数}的形式来指定分割执行的次数。</p>
</li>
<li><p>-s 使命令进入静默模式，不打印其他信息</p>
</li>
<li><p>-n指定分割后的文件名后缀的数字个数，</p>
</li>
<li><p>-f 指定分割后的文件名后缀</p>
</li>
<li><p>-b 指定后缀格式。例如“%02d.log”，类似于C语言中printf的参数格式。在这里文件名=前缀+后缀=server + %02d.log</p>
</li>
</ul>
<h2 id="根据扩展名切分文件名"><a href="#根据扩展名切分文件名" class="headerlink" title="根据扩展名切分文件名"></a>根据扩展名切分文件名</h2><p>获取文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file_jpg="sample.jpg"</span><br><span class="line">name=$&#123;file_jpg%.*&#125;</span><br><span class="line">echo File name is :$name</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line"></span><br><span class="line">File name is: sample</span><br></pre></td></tr></table></figure>

<p>获取文件扩展名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">extension=$&#123;file_jpg#*.&#125;</span><br><span class="line">echo Extension is:$extension</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">echo Extension is:jpg</span><br></pre></td></tr></table></figure>

<p>${VAR%.*}</p>
<ul>
<li>从$VARIABLE中删除位于%左侧的通配符（在前例中是.*）所匹配的字符串。通配符从右向左进行匹配。</li>
<li>给VAR赋值，VAR=sample.jpg.那么，通配符从右向左就会匹配到.jpg，因此，从$VAR中删除匹配结果，机会得到输出“sample”.</li>
</ul>
<p>%属于非贪婪操作，它从右到左找出匹配通配符的最短结果，还有另一个操作符%%，这个操作符与%相似，但行为模式却是贪婪的，这意味着它会匹配符合条件的最长的字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Var=hack.fun.book.txt</span><br><span class="line"></span><br><span class="line">echo $&#123;Var%.*&#125;</span><br><span class="line"></span><br><span class="line">output:hack.fun.book</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############################</span></span></span><br><span class="line"></span><br><span class="line">echo $&#123;Var%%.*&#125;</span><br><span class="line">output:hack</span><br></pre></td></tr></table></figure>

<p>${VAR#*.}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VAR=hack.fun.book.txt</span><br><span class="line"></span><br><span class="line">echo $&#123;VAR#*.&#125;</span><br><span class="line">output:fun.book.txt</span><br><span class="line"></span><br><span class="line">echo $&#123;VAR##*.&#125;</span><br><span class="line">output:txt</span><br></pre></td></tr></table></figure>

<p>example</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">URL="www.googl.com"</span><br><span class="line"></span><br><span class="line">echo $&#123;URL%.*&#125; #output:www.google</span><br><span class="line">echo $&#123;URL%%.*&#125; #output:www</span><br><span class="line">echo $&#123;URL#*.&#125; #output:google.com</span><br><span class="line">echo $&#123;URL##*.&#125; #com</span><br></pre></td></tr></table></figure>



<h1 id="批量重命名和移动"><a href="#批量重命名和移动" class="headerlink" title="批量重命名和移动"></a>批量重命名和移动</h1><h2 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件名rename.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用途： 重命名.jpg和.png</span></span><br><span class="line"></span><br><span class="line">count=1;</span><br><span class="line">for img in *.log *.png</span><br><span class="line">do</span><br><span class="line">new=image-$count.$&#123;img##*.&#125;</span><br><span class="line"></span><br><span class="line">mv "$img" "$new" 2&gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash">2&gt; /dev/null 有时候，我并不想看到任何输出，我只想看到这条命令运行是不是正常，那么我们可以同时禁止标准输出和标准错误的输出,比如上面这个命令有任何错误信息都不会在终端上打印了</span></span><br><span class="line"></span><br><span class="line">if [$? -eq 0] #$? 判断最后的命令的推出状态，0表示没有错误，其他任何值表明有错误</span><br><span class="line">then</span><br><span class="line">echo "Renaming $img to $new"</span><br><span class="line">let count++</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<p>./rename.sh</p>
<p>Renaming hack.jpg to image-1.jpg</p>
<p>Renaming new.jpg to image-2.jpg</p>
<p>Renaming next.jpg to image-3.jpg</p>
<p>该脚本将当前目录下所有的.jpg和.png文件重命名,新文件的格式image-1.jpg、image-2.jpg、image-3.jpg、image-4.png等</p>
<h1 id="拼写检查与词典操作"><a href="#拼写检查与词典操作" class="headerlink" title="拼写检查与词典操作"></a>拼写检查与词典操作</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件名：checkwork.sh</span></span><br><span class="line">word=$1</span><br><span class="line">grep "^$1$" /usr/share/dict/british-english -q</span><br><span class="line"><span class="meta">#</span><span class="bash">在grep中，^标记着单词的开始，$标记着单词的结束，-q禁止产生任何输出</span></span><br><span class="line"></span><br><span class="line">if [$? -eeq 0]; then</span><br><span class="line">	echo $word is a dictionary word;</span><br><span class="line">else</span><br><span class="line">	echo $word is not dictionary word;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./checkword.sh ful</span><br><span class="line"></span><br><span class="line">ful is not a dictionary word</span><br><span class="line"></span><br><span class="line">./checkword.sh fool</span><br><span class="line"></span><br><span class="line">fool is a dictionary word</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件名：aspellcheck.sh</span></span><br><span class="line"></span><br><span class="line">word=$1</span><br><span class="line">output=`echo \"$word\" | aspell list`</span><br><span class="line">if [-z $output];then</span><br><span class="line"><span class="meta">#</span><span class="bash">-z用于确定<span class="variable">$output</span>是否为空</span></span><br><span class="line">	echo $word is a dictionary word;</span><br><span class="line">else</span><br><span class="line">	echo $word is not a dictionary word;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>当给定的输入不是一个词典单词，aspell list命令产生输出文本，反之则不产生任何输出。 -z用于确认$output是否为空</p>
<h1 id="交互输入自动化"><a href="#交互输入自动化" class="headerlink" title="交互输入自动化"></a>交互输入自动化</h1><p>下写一个读取交互式输入的脚本，然后用这个脚本进行自动化的演示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件名：interactive.sh</span></span><br><span class="line">read -p "Enter number:" no;</span><br><span class="line">read -p "Enter name:" name</span><br><span class="line">echo You have entered $no,$name;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "1\nhello\n" | ./interactive.sh</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">You have entered 1,hello</span><br></pre></td></tr></table></figure>

<p>用expect实现自动化</p>
<p>expect等待特定的输入提示，通过检查输入提示来发送数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件名：automate_expect.sh</span></span><br><span class="line"></span><br><span class="line">spawn ./interactive.sh</span><br><span class="line">expect "Enter number:"</span><br><span class="line">send "1\n"</span><br><span class="line">expect "Enter name:"</span><br><span class="line">send "hello\n"</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure>

<ul>
<li>spawn参数指定需要自动化哪个命令；</li>
<li>expect参数提供需要等待的消息；</li>
<li>send是要发送的消息</li>
<li>expect eof指明命令交互结束</li>
</ul>
<h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><h2 id="生成任意大小的文件"><a href="#生成任意大小的文件" class="headerlink" title="生成任意大小的文件"></a>生成任意大小的文件</h2><p>创建特定大小的大文件最简单的方法就是利用dd命令。dd命令会克隆给定的输入内容，然后将一模一样的一份副本写入到输出。stdin、设备文件、普通文件等都可作为输入，stdout、设备文件、普通文件等也作为输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></table></figure>

<p>该命令会创建一个1MB大小的文件junk.data。来看下命令参数：if代表输入文件（input），of代表输出文件（output），bs代表以字节为单位的块大小（Block size），count代表被复制的块数</p>
<p>/dev/zero是一个字符设备，它会不断返回0值字符（\0）</p>
<h2 id="文本文件的交集与差集"><a href="#文本文件的交集与差集" class="headerlink" title="文本文件的交集与差集"></a>文本文件的交集与差集</h2><p>comm命令可用于两个文件之间的比较。</p>
<p>交集：打印出两个文件所共有的行</p>
<p>求集：打印出指定文件所包含的且不相同的那些行</p>
<p>差集：打印出包含在文件A中，但不包含在其他指定文件中的那些行</p>
<p>comm命令必须使用排过序的文件作为输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat A.txt</span><br><span class="line">apple</span><br><span class="line">orange</span><br><span class="line">gold</span><br><span class="line">silver</span><br><span class="line">steel</span><br><span class="line">iron</span><br><span class="line"></span><br><span class="line">cat B.txt</span><br><span class="line">orange</span><br><span class="line">gold</span><br><span class="line">cookies</span><br><span class="line">carrot</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort A.txt -o A.txt;sort B.txt -o B.txt</span><br><span class="line"></span><br><span class="line">comm A.txt B.txt</span><br><span class="line">apple	</span><br><span class="line">		carrot</span><br><span class="line">		cookies</span><br><span class="line">				gold</span><br><span class="line">iron</span><br><span class="line">				orange</span><br><span class="line">silver</span><br><span class="line">steel</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-1从输出中删除第一列</li>
<li>-2从输出中删除第二列</li>
<li>-3从输出中删除第三列</li>
</ul>
<h2 id="查找并删除重复文件"><a href="#查找并删除重复文件" class="headerlink" title="查找并删除重复文件"></a>查找并删除重复文件</h2><p>xxx</p>
<p>创建长路劲目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir dirpath</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [-e /home/slynux];then</span><br><span class="line"><span class="meta">#</span><span class="bash">如果目录存在，返回真</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mdkir /home 2&gt; /dev/null</span><br><span class="line">mdkri /home/slynux 2&gt; /dev/null</span><br><span class="line">mdkri /home/slynux/test 2&gt; /dev/null</span><br><span class="line">mdkri /home/slynux/test/hello 2&gt; /dev/null</span><br><span class="line">mdkri /home/slynux/test/hello/child 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>如果遇到“Directory exists”这种错误，该命令会被忽略，错误信息通过2&gt;被重定向到/dev/null</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p  /home/slynux/test/hello/child</span><br></pre></td></tr></table></figure>

<p>这条命令可以替代前面5条命令，它会忽略所有有已存在的目录，同时创建缺失的部分。</p>
<h1 id="文件权限、所有权"><a href="#文件权限、所有权" class="headerlink" title="文件权限、所有权"></a>文件权限、所有权</h1><p>linux中文件类型：</p>
<ul>
<li>“-” 普通文件</li>
<li>“d” 目录</li>
<li>“c” 字符设备</li>
<li>“b” 块设备</li>
<li>“l” 符号链接</li>
<li>“s” 套接字</li>
<li>“p” 管道</li>
</ul>
<p>u = 指定用户权限</p>
<p>g = 指定用户组权限</p>
<p>o = 指定其他实体权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod o+x filename #给其他实体权限增加可执行权限</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+x filename #给（用户、用户组、其他用户）增加可执行权限</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a-x filename #删除（用户、用户组、其他用户）增加可执行权限</span><br></pre></td></tr></table></figure>

<p>r– = 4</p>
<p>-w- = 2</p>
<p>–x = 1</p>
<p>rwx = 4 +２＋１＝７</p>
<p>rw = 4 +２＝６</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 764 filename</span><br><span class="line"><span class="meta">#</span><span class="bash">为用户增加读写执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">为用户组增加读写</span></span><br><span class="line"><span class="meta">#</span><span class="bash">为其他用户增加写执行</span></span><br></pre></td></tr></table></figure>

<h2 id="更改所有权"><a href="#更改所有权" class="headerlink" title="更改所有权"></a>更改所有权</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown user.group filename</span><br><span class="line"><span class="meta">#</span><span class="bash">变更文件所有权为user，user是用户，group是组</span></span><br></pre></td></tr></table></figure>

<h3 id="以递归的方式设置权限"><a href="#以递归的方式设置权限" class="headerlink" title="以递归的方式设置权限"></a>以递归的方式设置权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 . -R</span><br></pre></td></tr></table></figure>

<p>选项-R指定以递归的方式修改权限，“.”指定当前工作目录</p>
<h3 id="以递归的方式设置所有权"><a href="#以递归的方式设置所有权" class="headerlink" title="以递归的方式设置所有权"></a>以递归的方式设置所有权</h3><p>用chown命令结合-R就可以以递归的方式设置所有权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown user.group . -R</span><br></pre></td></tr></table></figure>

<h3 id="以不同的用户运行可执行文件"><a href="#以不同的用户运行可执行文件" class="headerlink" title="以不同的用户运行可执行文件"></a>以不同的用户运行可执行文件</h3><p>一些可执行文件需要以不同的用户身份（除启动该文件的当前用户之外的用户），用文件路径来执行（如./executable_name）。有一个叫做setuid的特殊文件权限，他允许其他用户以文件所有者的身份来执行文件</p>
<p>首先将该文件的所有权替换为该用户，这项操作每次都会执行，使改用户能以文件所有者的身份登入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +s executable_file</span><br><span class="line">chmod root.root executable_file</span><br><span class="line">chmod +s executable_file</span><br><span class="line">./executable_file</span><br></pre></td></tr></table></figure>

<p>setuid的使用不是无限制的。为了确保安全，它只能应用在Linux ELF格式二进制文件上，而不能用于脚本文件。</p>
<h2 id="创建不可修改文件"><a href="#创建不可修改文件" class="headerlink" title="创建不可修改文件"></a>创建不可修改文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chattr +i file #将一个文件设置为不可修改</span><br></pre></td></tr></table></figure>

<p>使用rm file也不可使用删除文件</p>
<p>如果需要使文件重新可写，可以移除不可修改属性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chattr -i file</span><br></pre></td></tr></table></figure>

<p>批量生成空白文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for name in &#123;1..100&#125;.txt</span><br><span class="line">do</span><br><span class="line">touch $name</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>touch -a 只更改文件访问时间</p>
<p>touch -m 只更改文件内容修改时间</p>
<p>除了将时间更改为当前时间，我们还能够为时间戳指定特定的时间和日期：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch -d "Fri Jun 25 20:50:14 IST 1999" filename</span><br></pre></td></tr></table></figure>

<p>-d使用的日期串不一定总是以同样的格式呈现，-d可以接受任何的目标标准日期格式。</p>
<h2 id="查看文件类型信息"><a href="#查看文件类型信息" class="headerlink" title="查看文件类型信息"></a>查看文件类型信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file filename</span><br></pre></td></tr></table></figure>



<h2 id="显示文件内容"><a href="#显示文件内容" class="headerlink" title="显示文件内容"></a>显示文件内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure>

<h3 id="打印文件的前10行和后10行"><a href="#打印文件的前10行和后10行" class="headerlink" title="打印文件的前10行和后10行"></a>打印文件的前10行和后10行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head file #默认前10行</span><br><span class="line">tail file #默认后10行</span><br><span class="line"></span><br><span class="line">head -n 4 file #打印前4行</span><br><span class="line"></span><br><span class="line">head -n -N file #打印除了最后N行之外的所有行</span><br></pre></td></tr></table></figure>

<h3 id="统计文件的行数、单词数、字符数"><a href="#统计文件的行数、单词数、字符数" class="headerlink" title="统计文件的行数、单词数、字符数"></a>统计文件的行数、单词数、字符数</h3><p>使用wc工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">统计行数</span></span><br><span class="line">wc -l file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">统计file文件的行数</span></span><br><span class="line">cat file | wc -1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">统计单词书</span></span><br><span class="line">wc -w file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">统计字符数</span></span><br><span class="line">wc -c  file</span><br><span class="line">cat file |wc -c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">它会打印出文件的函数、单词数、字符数，彼此之间用制表符分隔</span></span><br><span class="line">wc file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打印最长行的长度</span></span><br><span class="line">wc file -L</span><br></pre></td></tr></table></figure>

<h2 id="打印目录树"><a href="#打印目录树" class="headerlink" title="打印目录树"></a>打印目录树</h2><p>tree命令（这个命令需要自行安装）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree 目录</span><br></pre></td></tr></table></figure>
<h1 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行起始标记</td>
<td>^tux匹配以tux起始的行</td>
</tr>
<tr>
<td>$</td>
<td>行尾标记</td>
<td>tux$匹配以tux结尾的行</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个字符</td>
<td>yua. 可以匹配yuan或者yua1</td>
</tr>
<tr>
<td>[]</td>
<td>匹配[字符]之中的任意的一个字符</td>
<td>coo[kl]匹配cook或cool</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配[^]之外的任意一个字符</td>
<td>9[^01]匹配92、93，但是不匹配91或90</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配[]中指定范围内任意一个字符</td>
<td>[1-5]匹配从1~5的任意一个数字</td>
</tr>
<tr>
<td>?</td>
<td>匹配之前的项一次或0次</td>
<td>colou?r匹配color或colour,但是不能匹配colouur</td>
</tr>
<tr>
<td>+</td>
<td>匹配之前的项1次或多次</td>
<td>Rollno-9+匹配ROLLno-99、Rollno-9，但是不能匹配Rollno-</td>
</tr>
<tr>
<td>*</td>
<td>匹配之前的项0次或多次</td>
<td>co*l匹配cl、col、coool等</td>
</tr>
<tr>
<td>()</td>
<td>创建一个用于匹配的字串</td>
<td>ma(tri)?匹配max或maxtrix</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配之前的项n次</td>
<td>[0-9]{3}匹配任意一个三位数，[0-9]{3}</td>
</tr>
<tr>
<td>{n,}</td>
<td>之前的项至少需要匹配n次</td>
<td>[0-9]{2,}匹配任意一个两位或更多位的数字</td>
</tr>
<tr>
<td>{n,m}</td>
<td>指定之前的项所必需匹配的最小次数和最大次数</td>
<td>[0-9]{2,5}匹配从两位数到五位数之间的任意一个数字</td>
</tr>
<tr>
<td>|</td>
<td>交替——–匹配|两边的任意一项</td>
<td>Oct (1st | 2nd)匹配Oct lst或Oct 2nd</td>
</tr>
<tr>
<td>\</td>
<td>转义符可以将上面介绍的特殊字符进行转义</td>
<td>a\ .b匹配a.b,但不能匹配ajb，通过在. 之间加上前缀,从而忽略了.的特殊意义</td>
</tr>
</tbody></table>
<h2 id="匹配文本中所有单词"><a href="#匹配文本中所有单词" class="headerlink" title="匹配文本中所有单词"></a>匹配文本中所有单词</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">( ?[a-zA-Z]+ ?)</span><br></pre></td></tr></table></figure>

<ul>
<li>“?”用于匹配单词前后可能出现的空格。[a-zA-Z]+代表一个或多个字母（a<del>z和A</del>Z）.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;</span><br><span class="line">或者</span><br><span class="line">[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;</span><br></pre></td></tr></table></figure>

<p>[0-9]或者[:digit:]匹配数字0~9。{1，3}匹配1到3个数字，.匹配”.”。</p>
<h2 id="用grep在文件中搜索文本"><a href="#用grep在文件中搜索文本" class="headerlink" title="用grep在文件中搜索文本"></a>用grep在文件中搜索文本</h2><p>在文件中搜索一个单词</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep match_pattern filename</span><br></pre></td></tr></table></figure>

<p>会输出包含单词的所在行</p>
<p>命令会返回包含给定match_pattern的文本行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e "this is a word\nnext line" | grep word</span><br></pre></td></tr></table></figure>

<p>一个grep命令也可以对多个文件进行搜索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "match_text" file1 file2 file3 ..</span><br></pre></td></tr></table></figure>

<p>用–color选项可以在输出行中重点标记出匹配到的单词：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep word filename --color=auto</span><br></pre></td></tr></table></figure>

<p>grep也可以使用正则表达式，也可以使用默认允许正则表达式的grep命令—–egrep</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -E "[a-z]+"</span><br><span class="line">或者</span><br><span class="line">egrep "[a-z]+"</span><br></pre></td></tr></table></figure>

<p>为了只输出文件中匹配的文本部分，可以使用选项-o</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a line.|grep -o -E "[a-z]+\." #output line</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -v match_pattern file #打印除包含match_pattern的行之外的所有行</span><br><span class="line">选项-v可以将匹配结果进行反转</span><br></pre></td></tr></table></figure>

<p>统计文件或者文本中包含匹配字符的行数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -c "text" filename #10</span><br></pre></td></tr></table></figure>

<p>需要注意的是-c只是统计匹配行的数量，并不是匹配的次数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e "1 2 3  4\nhello\n5 6" | egrep -c "[0-9]"  #输出2</span><br></pre></td></tr></table></figure>

<p>为了文件中统计匹配项的数量，可以使用下面的技巧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e "1 2 3  4\nhello\n5 6" | egrep -c "[0-9]" | wc -l #output:6</span><br></pre></td></tr></table></figure>

<p>打印除包含匹配字符串的行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "match_pattern" -n sample1.txt</span><br></pre></td></tr></table></figure>

<p>递归搜索文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "text" . -R -n</span><br></pre></td></tr></table></figure>

<p>选项-i可以使匹配样式不考虑字符的大小写，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello world | grep -i "HELLO" #output:hello</span><br></pre></td></tr></table></figure>

<p>用grep匹配多个样式</p>
<p>在进行匹配的时候只指定一个样式。然而。我们可以用选项-e来指定多个匹配样式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo this is a line of text | grep -e "this" -e "line" -o #this line</span><br></pre></td></tr></table></figure>

<p>在grep搜索中包括或排除文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">递归搜索所有的.c和.cpp文件</span></span><br><span class="line">grep "main()" . -r --include *.(c,cpp) </span><br><span class="line"><span class="meta">#</span><span class="bash">排除所有的README文件：</span></span><br><span class="line">grep "main()" . -r --include "README"</span><br><span class="line"><span class="meta">#</span><span class="bash">如果需要从文件中读取所需排除的文件列表，使用--exclude-from FILE</span></span><br><span class="line">grep "main()" . -r -exclude-from FILE</span><br></pre></td></tr></table></figure>

<p>项目-q（grep的静默输出）</p>
<p>在静默模式下，grep命令不会像标准输出打印任何输出。它仅是运行命令。然后根据命令执行成功与否返回退出状态</p>
<h2 id="测试文件是否包含的文件内容"><a href="#测试文件是否包含的文件内容" class="headerlink" title="测试文件是否包含的文件内容"></a>测试文件是否包含的文件内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">判断参数个数</span></span><br><span class="line">if [$# -ne 2];</span><br><span class="line">then</span><br><span class="line">echo "$0 match_text filename"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">match_text=$1 #第一个参数</span><br><span class="line">filename=$2 #第二个参数</span><br><span class="line"></span><br><span class="line">grep -q $match_text $filename</span><br><span class="line"></span><br><span class="line">if [$? -eq 0];then</span><br><span class="line">echo "The text exists in the file"</span><br><span class="line">eles</span><br><span class="line">echo "Text does not exist in the file"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>打印出匹配文本之前或之后的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "xxx" -A 3 #打印查找的结果后的前3行</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "xxx" -B 3 #打印查找的结果后的后3行</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep "xxx" -C 3 #打印查找的结果之前以及之后的3行，使用-c选项</span><br></pre></td></tr></table></figure>

<h2 id="用cut按列切分文件"><a href="#用cut按列切分文件" class="headerlink" title="用cut按列切分文件"></a>用cut按列切分文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2,3 filenaem #第2列和第3列</span><br></pre></td></tr></table></figure>

<p>制表符是字段或列的默认定界符，没有定界符的行也会被打印出来，要避免打印出这种不包含定界符的行，则可以使用cut的-s选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat student_data.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NO	Name　Mark	percent</span><br><span class="line">1	11	  45       90</span><br><span class="line">2	22    49       98</span><br><span class="line">3	33    45       90</span><br></pre></td></tr></table></figure>

<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>sed是stream editor的缩写。sed命令众所周知的一个用法是进行文本替换。</p>
<p>sed可以替换给定文本中的字符串。它可以利用正则表达式进行匹配。</p>
<p>sed是一种在线编辑器，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区，，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用量定向存储输出。Sed主要用来自动编辑一个或多个文件，简化对文件的反复操作；编写转换程序等。</p>
<h2 id="定址"><a href="#定址" class="headerlink" title="定址"></a>定址</h2><p>定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。</p>
<p>地址是一个数字，则表示行号；是“$”符号，则表示最后一行。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n '3p' datafile #只打印第三行</span><br></pre></td></tr></table></figure>

<p>值显示指定行范围的文件内容，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n '100,200p' mysql_slow_query.log</span><br></pre></td></tr></table></figure>

<p>地址是逗号分隔的，那么需要处理的地址是这两行之间的范围（包括这两行在内）。范围可以用数字、正则表达式、或二者的组合表示。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '2,5d' datafile</span><br><span class="line"><span class="meta">#</span><span class="bash">删除第二到第五行</span></span><br><span class="line"></span><br><span class="line">sed '/My/,/You/d' datafile</span><br><span class="line"><span class="meta">#</span><span class="bash">删除包含“My”的行到包含<span class="string">"You"</span>的行之间的行</span></span><br><span class="line"></span><br><span class="line">sed '/My/,10d' datafile</span><br><span class="line"><span class="meta">#</span><span class="bash">删除包含“My”的行到第十行的内容</span></span><br></pre></td></tr></table></figure>



<p>3.命令与选项</p>
<p>sed命令告诉sed如何处理有地址指定的各输入行，如果没有指定地址则处理所有的输入行。</p>
<p>选项：</p>
<p>-n：使用安静（silent）模式。在一般sed的用法中，所有来自STDIN的数据一般都会被列出到终端上，加上-n参数后，则只有被sed处理的那些行才会被输出。</p>
<p>-e：指定在指令列模式上执行的命令文本。默认不需要指定，只有同时要执行多个命令文本时才需要显示的指定-e选项。</p>
<p>-f：同时要执行多个命令文本时，可以将这些命令文本写到一个文件中，然后通过-f filename 的方式使用。</p>
<p>-r：sed默认使用基础正则表达式语法，指定-r选项后使用扩展正则表达式语法。</p>
<p>-i：直接修改读取的文档，而不是输出到终端。</p>
<p>命令：</p>
<p>a：新增行，a的后面接字串，这些字串会被添加到匹配行的下面。</p>
<p>c：替换行，c的后面接字串，这些字符串替换掉匹配到的行。</p>
<p>d：删除行，删除匹配到的行。</p>
<p>i：插入行，i的后面接字符串，这些字符串会被插入到匹配行的上面</p>
<p>p：打印，将某些行输出，通常p会与参数-n一起使用这样会输出匹配到的行。</p>
<p>s：字符串替换，主要搭配正则表达式</p>
<h2 id="选项i"><a href="#选项i" class="headerlink" title="选项i"></a>选项i</h2><p>如果想要直接在原文件上进行修改（其实是先修改文件的内容，然后保存到原文件中，需要使用选项I：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i '1d' test.txt</span><br></pre></td></tr></table></figure>

<p>注意，应用-i选项后命令行上没有输出内容，但是源文件被更新了。</p>
<h2 id="新增行"><a href="#新增行" class="headerlink" title="新增行"></a>新增行</h2><p>a命令可以在匹配的行下面新增行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 'la Hello world' test.txt	#在第一行下面新增一行，内容为“Hello world”</span><br><span class="line">sed '$a Hello world' test.txt	#在最后一行下面新增加一行，内容为"Hello world"</span><br><span class="line">sed '1,3a Hello world' test.txt #在第一行，第二行和第三行下面分别增加一行</span><br><span class="line"></span><br><span class="line">sed '1a Hello world!\nHello China!' test.txt #一次增加多行需要使用换行符</span><br></pre></td></tr></table></figure>

<h2 id="选项-e"><a href="#选项-e" class="headerlink" title="选项-e"></a>选项-e</h2><p>-e选项用来指定命令文本，如果只有一个命令文本时-e选项可以省略。如果要指定多个命令文本就需要使用-e选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -e 'la xxx' -e '2a yyy' test.txt</span><br></pre></td></tr></table></figure>

<h2 id="插入行"><a href="#插入行" class="headerlink" title="插入行"></a>插入行</h2><p>i命令可以在匹配的行上面插入行，语法与新增行相同，只能新行在指定行的上面（与a命令的区别）：</p>
<h2 id="选项-f"><a href="#选项-f" class="headerlink" title="选项-f"></a>选项-f</h2><p>前面我们通过选项-e添加了多个命令文本，但是如果需要添加比较多的命令文本，使用选项-e就不合适了，应为把所有的命令文本全部写在命令行中会导致维护困难。我们可以把多个命令文本写入到文本文件中，然后通过-f选项进行引用。</p>
<h2 id="替换行"><a href="#替换行" class="headerlink" title="替换行"></a>替换行</h2><p>使用c命令可以轻松的进行整行替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '1c Hello world' test.txt 	#把第一行替换为“Hello world”</span><br><span class="line">sed '1,3c Hello world' test.txt #把第一行到第三行替换为“Hello world”</span><br></pre></td></tr></table></figure>

<p>注意，上图中命令把三行文本替换成一行文本</p>
<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>与行替换不同，s命令只替换匹配到的内容（一般为字符串）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 's/Hello/Hi' hello.txt   #把Hello 替换为Hi （只能匹配第一行）</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 's/Hello/Hi/g' hello.txt #把匹配到的所有Hello都替换为Hi（匹配整个文件）</span><br></pre></td></tr></table></figure>

<p>我们还可以限制执行替换操作的行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '2,3s/Hello/Hi/g' hello.txt  #只在第二行和第三行替换操作</span><br></pre></td></tr></table></figure>

<p>当然也可以通过替换来删除不需要的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 's/hello//g' hello.txt  #删除字符串hello</span><br></pre></td></tr></table></figure>

<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>sed所有的操作都是建立在行定位之上的。也就是说无论你要干什么，都要先找到（匹配）目标行。连最简单的删除‘1d’，也得先定位到第一行，然后才能删除，所以唯一能限制我们发挥sed能力的因素就是：如何匹配到期望的行？</p>
<p>p命令sed只输出哪些匹配到的行，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n '1p' test.txt</span><br></pre></td></tr></table></figure>

<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p><strong>结构</strong></p>
<p>awk “BEGIN {print “start”} pattern  {commands} END {print “end”}” file</p>
<p><strong>工作原理</strong></p>
<p>awk命令的工作方式如下所示：</p>
<p>（1）执行BEGIN{commands} 语句块中语句。</p>
<p>（2）从文件或stdin中读取一行，然后执行pattern{commands}。重复这个过程，直到文件全部被读取完毕。</p>
<p>（3）当读至读入流末尾是，执行END{commands}语句块。</p>
<p>BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，诸如变量初始化、打印输出格式的表头等语句通常都可以写入BEGIN语句块。</p>
<p>END语句块和BEGIN语句块类似。END语句块在awk从输入流中读取完所有的行之后即被执行。像打印所有行的分析结果这类汇总信息，都是在END语句块中实现的常见任务。它也是一个可选的语句块。</p>
<p>最重要的部分就是pattern语句块中的通用命令。这个语句块同样是可选的。如果不提供该语句块，则默认执行{print}，即打印每一个读取到的行，都会执行这个语句块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e "line1\nline2" | awk 'BEGIN &#123;print "Start"&#125; &#123;print&#125; END&#123;print "End"&#125;'</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<p>Start</p>
<p>line1</p>
<p>line2</p>
<p>End</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo | awk '&#123;var1="v1";var2="v2";var3="v3"; \</span><br><span class="line">print var1,var2,var3;&#125;'</span><br></pre></td></tr></table></figure>

<p>v1 v2 v3</p>
<p><strong>特殊变量</strong></p>
<ul>
<li>NR：表示记录数量（number of records）,执行过程中国对应于当前行号。</li>
<li>NF：表示字段数量（number of fields），在执行过程中对应于当前行的字段数。</li>
<li>$0：这个变量包含执过程中当前行的文本内容。</li>
<li>$1：这个变量包含第一个字段的文本内容。</li>
<li>$2：这个变量包含第二个字段的文本内容。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "line1 f2 f3\nline2 f4 f5\nline3 f6 f7" | \</span><br><span class="line">awk '&#123;print "Line no:"NR",No of fields:"NF, "$0="$0,"$1="$1,"$2="$2,"$3="$3&#125;'</span><br></pre></td></tr></table></figure>

<p>打印每一行第2和第3个字段:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '&#123;print $3,$2&#125;' file</span><br></pre></td></tr></table></figure>

<p>统计文件中行数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk ‘END &#123;print NR&#125;’ file</span><br></pre></td></tr></table></figure>



<h1 id="对文件中的行、单词和字符进行迭代"><a href="#对文件中的行、单词和字符进行迭代" class="headerlink" title="对文件中的行、单词和字符进行迭代"></a>对文件中的行、单词和字符进行迭代</h1><h2 id="1-迭代文件中的每一行"><a href="#1-迭代文件中的每一行" class="headerlink" title="(1)迭代文件中的每一行"></a>(1)迭代文件中的每一行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while read line;</span><br><span class="line">do </span><br><span class="line">echo $line</span><br><span class="line">done &lt; file.txt</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代一行中的每一个单词"><a href="#2-迭代一行中的每一个单词" class="headerlink" title="(2)迭代一行中的每一个单词"></a>(2)迭代一行中的每一个单词</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for word in $line;</span><br><span class="line">do</span><br><span class="line">echo $word</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="3-迭代一个单词中每一字符"><a href="#3-迭代一个单词中每一字符" class="headerlink" title="(3)迭代一个单词中每一字符"></a>(3)迭代一个单词中每一字符</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((i=0;i&lt;$&#123;#word&#125;;i++))</span><br><span class="line">do</span><br><span class="line">echo $(word:i:1);</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="按列合并文件"><a href="#按列合并文件" class="headerlink" title="按列合并文件"></a>按列合并文件</h1><h2 id="可以用paste命令实现按列拼接"><a href="#可以用paste命令实现按列拼接" class="headerlink" title="可以用paste命令实现按列拼接"></a>可以用paste命令实现按列拼接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">paste file1 file2 file3 ...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat paste1.txt</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat paste2.txt</span><br><span class="line">slynux</span><br><span class="line">gnu</span><br><span class="line">bash</span><br><span class="line">back</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">paste paste1.txt paste2.txt</span><br><span class="line">1slynux</span><br><span class="line">2gnu</span><br><span class="line">3bash</span><br><span class="line">4hack</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="打印文件或行中的第n个单词或列"><a href="#打印文件或行中的第n个单词或列" class="headerlink" title="打印文件或行中的第n个单词或列"></a>打印文件或行中的第n个单词或列</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '&#123;print $5&#125;' filename</span><br></pre></td></tr></table></figure>

<p>也可以打印多列数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l | awk '&#123;print $1" : " $8&#125;' #打印第1列和第8列进行</span><br></pre></td></tr></table></figure>

<h1 id="网站下载"><a href="#网站下载" class="headerlink" title="网站下载"></a>网站下载</h1><p>wget是一个用于文件下载的命令行工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget URL</span><br></pre></td></tr></table></figure>

<p>-o指定一个日志文件，从而不必将日志信息打印到stdout。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://xxxxxxxx,img -o xxx.img -o log</span><br></pre></td></tr></table></figure>

<p>运行改命令，屏幕上不会显示任何内容，日志或进度信息会被写入文件log，输出文件为xxx.img</p>
<p>-t指定重试次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -t 5 URL</span><br></pre></td></tr></table></figure>

<p>–limit-rate按照下面的方式对wget限速：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --limit-rate 20k URL</span><br></pre></td></tr></table></figure>

<p>–quota 或 -Q指定下载量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -Q 100m URL</span><br></pre></td></tr></table></figure>

<p>-c断点续传</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c URL</span><br></pre></td></tr></table></figure>

<p>–mirror以递归的方式收集网页上所有的URL的链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --mirror URL</span><br></pre></td></tr></table></figure>

<p>–user和–password提供认证信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --user username --password pass URL</span><br></pre></td></tr></table></figure>

<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h3 id="打印网络接口列表"><a href="#打印网络接口列表" class="headerlink" title="打印网络接口列表"></a>打印网络接口列表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig | cut -c-10 |tr -d ' ' | tr -s '\n'</span><br></pre></td></tr></table></figure>

<p>ifconfig 输出到前10个字符是保留用于打印网络接口的名称，因此我们用cut命令提取每一行前10个字符。tr -d ‘ ‘删除每一行的所有空格。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig wlan0</span><br></pre></td></tr></table></figure>

<ul>
<li>HWaddr 00:-1c:bf:87:25:d2是硬件地址（MAC地址）</li>
<li>inet addr:192.168.0.82是IP地址</li>
<li>Bcast:192.168.3.255是广播地址</li>
<li>MASK:255.255.252.0是子网掩码</li>
</ul>
<h3 id="FTP自动传输"><a href="#FTP自动传输" class="headerlink" title="FTP自动传输"></a>FTP自动传输</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">HOST='domain.com'</span><br><span class="line">USER='foo'</span><br><span class="line">PASSWD='password'</span><br><span class="line">ftp -i -n $HOST &lt;&lt;EOF</span><br><span class="line">user $&#123;USER&#125; $&#123;PASSWD&#125;</span><br><span class="line">binary</span><br><span class="line">cd /home/slynux</span><br><span class="line">put testfile.jpg</span><br><span class="line">get serverfile.jpg</span><br><span class="line">quit</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="SFTP"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/slynux</span><br><span class="line">put testfile.jpg</span><br><span class="line">get serverfile.jpg</span><br></pre></td></tr></table></figure>

<p>运行sftp：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sftp user@domainname</span><br></pre></td></tr></table></figure>

<p>SCP</p>
<p>scp是一项比传统远复制工具rcp更安全的文件复制技术。文件都是通过SSH加密通道进行传输</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp filename user@remotehost:/home/path</span><br></pre></td></tr></table></figure>

<h2 id="网络流量与端口分析"><a href="#网络流量与端口分析" class="headerlink" title="网络流量与端口分析"></a>网络流量与端口分析</h2><p>要列出系统中的开发端口已经在端口上的服务的详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure>

<p>用netstat查看开放端口与服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tnp</span><br></pre></td></tr></table></figure>
















































]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh</title>
    <url>/2019/12/05/zsh/</url>
    <content><![CDATA[<h2 id="查看当前环境shell"><a href="#查看当前环境shell" class="headerlink" title="查看当前环境shell"></a>查看当前环境shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>


<h2 id="查看系统自带那些shell"><a href="#查看系统自带那些shell" class="headerlink" title="查看系统自带那些shell"></a>查看系统自带那些shell</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;shells</span><br></pre></td></tr></table></figure>


<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y instal zsh #centos 安装zsh</span><br><span class="line"></span><br><span class="line">pacman -S zsh #arch 安装zsh</span><br></pre></td></tr></table></figure>

<h2 id="zsh配置文件"><a href="#zsh配置文件" class="headerlink" title="zsh配置文件"></a>zsh配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置文件</span></span><br><span class="line">cat $HOME/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主题</span></span><br><span class="line">ZSH_THEME="robbyrussell"</span><br></pre></td></tr></table></figure>

<h2 id="将zsh设置为默认shell"><a href="#将zsh设置为默认shell" class="headerlink" title="将zsh设置为默认shell"></a>将zsh设置为默认shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>


<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><p>自动安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>


<p>zsh主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls ~/.oh-my-zsh/themes</span></span><br></pre></td></tr></table></figure>


<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.zsh/zsh-syntax-highlighting</span><br><span class="line">echo "source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure>


<h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions</span><br></pre></td></tr></table></figure>


<p>Add the following to your .zshrc:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>原样输出html标签</title>
    <url>/2019/12/21/%E5%8E%9F%E6%A0%B7%E8%BE%93%E5%87%BAhtml%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>转载：<a href="https://www.cnblogs.com/jiayu123/p/10612852.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiayu123/p/10612852.html</a></p>
<p>第一种</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/html"</span> <span class="attr">style</span>=<span class="string">'display:block'</span>&gt;</span></span><br><span class="line"><span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"banner-text p-5"</span>&gt;</span></span><br><span class="line"><span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"banner-text-con"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color:;"</span>&gt;</span>html代码不被解析<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xmp</span>&gt;</span></span><br><span class="line">xxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">xpm</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三种</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">style</span>=<span class="string">"width:'800px';height:300px;"</span>&gt;</span></span><br><span class="line">xxxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意的是记得写display:block，不然没有效果的，直接输出，没有任何格式化效果</p>
<p>第四种</p>
<p>如果是有空格和回车这样的特殊字符的简单文本可以使用<code>&lt;pre&gt;</code> <code>&lt;/pre&gt;</code>标签</p>
<p>第五种</p>
<p>将&lt;&gt;转换成特殊字符<code>&lt;</code> 转化为<code>&amp;lt</code>, <code>&gt;</code> 转化为<code>&amp;gt</code>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/06/22/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>什么是反射?</p>
<p>通用解释：指程序在运行期间可以拿到一个对象的所有信息。</p>
<p>Java中的反射：</p>
<ul>
<li>运行时和获取对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<p>go中反射：</p>
<p>为什么用反射？</p>
<p>反射应用场景有哪些？</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2017/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>我们需要知道数据结构的分类和每种数据结构的特点、应用、优缺点。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200801170533850.png" alt="image-20200801170533850"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p> 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200801170915162.png" alt="image-20200801170915162"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200801172818083.png" alt="image-20200801172818083"></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 </p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。 </p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。 </p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。 </p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。 </p>
]]></content>
  </entry>
  <entry>
    <title>docker安装jenkins持续集成环境</title>
    <url>/2021/04/22/%E5%AE%89%E8%A3%85jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>环境先需先安装docker</p>
<p>先创建挂载目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;data&#x2F;jenkins_home</span><br><span class="line"></span><br><span class="line">chown -R 1000 &#x2F;data&#x2F;jenkins_home</span><br></pre></td></tr></table></figure>

<p>编写docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;    # 定义版本，不指定默认为版本 1，新版本功能更多</span><br><span class="line">services:       # 容器</span><br><span class="line">  jenkins:</span><br><span class="line">    image: &#39;jenkins&#x2F;jenkins:2.289-centos7&#39;    # 镜像</span><br><span class="line">    container_name: jenkins         # 容器名称</span><br><span class="line">    privileged: true                # 解决权限问题</span><br><span class="line">    restart: always                 # 同 --restart 参数</span><br><span class="line">    ports:                          # 端口映射，同 -p 参数，本地端口:容器端口</span><br><span class="line">      - &#39;8080:8080&#39;</span><br><span class="line">      - &#39;50000:50000&#39;</span><br><span class="line">    volumes:                        # 数据卷,本地文件夹:容器文件夹</span><br><span class="line">      - &#39;&#x2F;data&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home&#39;</span><br><span class="line">    environment:</span><br><span class="line">      - JAVA_OPTS&#x3D;-Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION&#x3D;true</span><br></pre></td></tr></table></figure>

<p>配置国内插件源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;updates&#x2F;update-center.json</span><br></pre></td></tr></table></figure>

<p>安装插件NodeJs</p>
<p>配置node<img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210423160953979.png" alt="image-20210423160953979"></p>
<p>在jenkins中安装python2</p>
<p>下载python包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.18&#x2F;Python-2.7.18.tgz</span><br></pre></td></tr></table></figure>

<p>进入jenkins容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it -u root 容器id &#x2F;bin&#x2F;bash  #进入容器</span><br></pre></td></tr></table></figure>

<p>查看系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure>

<p>这里我们是：</p>
<p>Debian GNU/Linux 10 \n \l</p>
<p>配置Debian 10的国内源</p>
<p>/ect/apt/source.list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian buster main</span><br><span class="line">deb http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian buster-updates main</span><br><span class="line">deb http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian-security&#x2F; buster&#x2F;updates main</span><br><span class="line">deb http:&#x2F;&#x2F;ftp.cn.debian.org&#x2F;debian buster-backports main</span><br></pre></td></tr></table></figure>

<p>更新apt-get</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p>安装常用包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install vim</span><br><span class="line">apt-get -y install gcc automake autoconf libtool make</span><br><span class="line">apt-get -y install make*</span><br><span class="line">apt-get -y install zlib*</span><br><span class="line">apt-get -y install openssl libssl-dev</span><br><span class="line">apt-get install sudo</span><br></pre></td></tr></table></figure>

<p>安装python2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;jenkins_home&#x2F;</span><br><span class="line">mkdir python2</span><br><span class="line">cd &#x2F;python2</span><br><span class="line">docker cp Python-2.7.18.tgz jenkins:&#x2F;var&#x2F;jenkins_home&#x2F;python2</span><br><span class="line">tar -xvf Python-2.7.18.tgz</span><br><span class="line">cd Python-2.7.18</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;var&#x2F;jenkins_home&#x2F;python2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;var&#x2F;jenkins_home&#x2F;python3 --with-ssl</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">ln -s &#x2F;var&#x2F;jenkins_home&#x2F;python2&#x2F;bin&#x2F;python2 &#x2F;usr&#x2F;bin&#x2F;python2</span><br></pre></td></tr></table></figure>

<p>报错 Failed to add SSH key. Message [invalid privatekey:</p>
<p>Jenkins  ssh server 配置key</p>
<p>不支持<code>-----BEGIN OPENSSH PRIVATE KEY——</code> 这种格式的私钥，通过以下方式命令进行生成私钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -m PEM -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p> <em>触发远程构建</em> ,报403</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210423221344799.png" alt="image-20210423221344799"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>生成和调试core文件</title>
    <url>/2017/03/16/%E7%94%9F%E6%88%90%E5%92%8C%E8%B0%83%E8%AF%95core%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="core-dump的产生"><a href="#core-dump的产生" class="headerlink" title="core dump的产生"></a>core dump的产生</h1><p>core文件又称为内核转储文件，它是进程运行时突然崩溃的那一刻的内存快照</p>
<p>作用：</p>
<p>(1) 内核转储的最大好处是能够保存问题发生时的状态。<br>(2) 只要有可执行文件和内核转储，就可以知道进程当时的状态。<br>(3) 只要获取内核转储，那么即使没有复现环境，也能调试。</p>
<p>配置操作系统的内核转储功能</p>
<p>(1) 查看当前转储文件大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -c</span><br></pre></td></tr></table></figure>

<p>输出的结果为0，表示没有启动内核转储。</p>
<p>(2) 开启内核转储</p>
<p>在/etc/profile 然后，在profile中添加下面这些命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -c unlimited  #设置coredump 大小为无限大</span><br><span class="line"></span><br><span class="line">ulimit -c 1073741824      --1G大小</span><br></pre></td></tr></table></figure>

<p>source /etc/profile 就会永久生效</p>
<p>(3) 指定内核转储的文件名和目录</p>
<p><code>如果没有配置一般会生成的位置和运行程序的路径相同</code></p>
<p>可以通过在/etc/sysctl.conf文件中，对sysctl变量kernel.core_pattern的设置。</p>
<p>在sysctl.conf文件中添加下面两句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.core_pattern &#x3D; &#x2F;var&#x2F;core&#x2F;core_%e_%p</span><br><span class="line">kernel.core_uses_pid &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>这里%e, %p分别表示：<br>%c 转储文件的大小上限<br>%e 所dump的文件名<br>%g 所dump的进程的实际组ID<br>%h 主机名<br>%p 所dump的进程PID<br>%s 导致本次coredump的信号<br>%t 转储时刻(由1970年1月1日起计的秒数)<br>%u 所dump进程的实际用户ID</p>
<p>可以使用以下命令，使修改结果马上生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl –p &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure>

<h1 id="调试core-dump"><a href="#调试core-dump" class="headerlink" title="调试core dump"></a>调试core dump</h1><p>示例程序:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpCrash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pStr = (<span class="keyword">char</span> *)<span class="string">"test_content"</span>;</span><br><span class="line">    <span class="built_in">free</span>(pStr); <span class="comment">//使用free释放栈或者常量区，程序就会core dump</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dumpCrash();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb打开core文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb 可执行程序 core文件</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200316215341036.png" alt="image-20200316215341036"></p>
<p>查看coredump时的堆栈</p>
<p>使用bt或者where命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200316215908758.png" alt="image-20200316215908758"></p>
<p>可以从第四帧开始看，因为上面的一看就是调用动态库中的代码，不是我们的代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200316220146910.png" alt="image-20200316220146910"></p>
<p><code>f 4</code>跳转到第四帧上</p>
<p>执行<code>disassemble</code>,打开该帧的反汇编代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200316220406667.png" alt="image-20200316220406667"></p>
<p>如上箭头位置标示coredump该函数调用的位置</p>
<p>使用下面的命令去掉函数的名词修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell echo free@plt |C++filt</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/Center.png" alt="img"></p>
<p>当然这里使用去掉名词修饰效果和之前还是一样的，在虚函数的调试中就很大作用了。</p>
<p>我们下面可以推测，是调用free函数才出现的问题。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2018/12/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行首</td>
</tr>
<tr>
<td>$</td>
<td>行尾</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面第子表达式一次或多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n之外第任何单字符</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的子表达式零次或一次</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<ul>
<li>“^”：^会匹配行或者字符串的起始位置，有时还会匹配整个文档第起始位置</li>
<li>“$”：$会匹配行或字符串的结尾</li>
</ul>
<h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\cx</td>
<td></td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\s</td>
<td>空白符，匹配任何空白字符，包括空格、制表符、换页符等等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符</td>
</tr>
</tbody></table>
<h2 id="表达式全集"><a href="#表达式全集" class="headerlink" title="表达式全集"></a>表达式全集</h2><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\</code>”而“<code>\(</code>”则匹配“<code>(</code>”。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“<code>z</code>”以及“<code>zoo</code>”。</em>等价于{0,}。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td>
</tr>
<tr>
<td align="center">{<em>n</em>}</td>
<td align="center"><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td>
</tr>
<tr>
<td align="center">{<em>n</em>,}</td>
<td align="center"><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o*</code>”。</td>
</tr>
<tr>
<td align="center">{<em>n</em>,<em>m</em>}</td>
<td align="center"><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">当该字符紧跟在任何一个其他限制符（<em>,+,?，{*n</em>}，{<em>n</em>,}，{<em>n</em>,<em>m</em>}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配除“<code>\</code><em><code>n</code></em>”之外的任何单个字符。要匹配包括“<code>\</code><em><code>n</code></em>”在内的任何字符，请使用像“`(.</td>
</tr>
<tr>
<td align="center">(pattern)</td>
<td align="center">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>\(</code>”或“<code>\)</code>”。</td>
</tr>
<tr>
<td align="center">(?:pattern)</td>
<td align="center">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td>
</tr>
<tr>
<td align="center">(?=pattern)</td>
<td align="center">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td>
</tr>
<tr>
<td align="center">(?!pattern)</td>
<td align="center">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td>
</tr>
<tr>
<td align="center">(?&lt;=pattern)</td>
<td align="center">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td>
</tr>
<tr>
<td align="center">(?&lt;!pattern)</td>
<td align="center">反向否定预查，与正向否定预查类拟，只是方向相反。例如“<code>(?”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td>
</tr>
<tr>
<td align="center">x|y</td>
<td align="center">匹配x或y。例如，“`z</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="center">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="center">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="center">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td align="center">[^a-z]</td>
<td align="center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td align="center">\cx</td>
<td align="center">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9_]</code>”。</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td>
</tr>
<tr>
<td align="center">\x<em>n</em></td>
<td align="center">匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td align="center">*num*</td>
<td align="center">匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center">*n*</td>
<td align="center">标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td>
</tr>
<tr>
<td align="center">*nm*</td>
<td align="center">标识一个八进制转义值或一个向后引用。如果*nm*之前至少有*nm*个获得子表达式，则*nm*为向后引用。如果*nm*之前至少有<em>n</em>个获取，则<em>n</em>为一个后跟文字<em>m</em>的向后引用。如果前面的条件都不满足，若<em>n</em>和<em>m</em>均为八进制数字（0-7），则*nm*将匹配八进制转义值*nm*。</td>
</tr>
<tr>
<td align="center">*nml*</td>
<td align="center">如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td>
</tr>
<tr>
<td align="center">\u<em>n</em></td>
<td align="center">匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
</tbody></table>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><table>
<thead>
<tr>
<th align="center">用户名</th>
<th>/^[a-z0-9_-]{3,16}$/</th>
</tr>
</thead>
<tbody><tr>
<td align="center">密码</td>
<td>/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td align="center">十六进制值</td>
<td>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</td>
</tr>
<tr>
<td align="center">电子邮箱</td>
<td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@(<a href="-[\da-z]">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
</tr>
<tr>
<td align="center">URL</td>
<td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]<em>)</em>/?$/</td>
</tr>
<tr>
<td align="center">IP 地址</td>
<td>/((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</td>
</tr>
<tr>
<td align="center">HTML 标签</td>
<td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</td>
</tr>
<tr>
<td align="center">删除代码\注释</td>
<td>(?&lt;!http:|\S)//.*$</td>
</tr>
<tr>
<td align="center">Unicode编码中的汉字范围</td>
<td>/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>typora+Pocgo+gitee实现笔记图片上传到图床</title>
    <url>/2019/12/05/typora+Pocgo+gitee%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="typora-配置图片上传"><a href="#typora-配置图片上传" class="headerlink" title="typora 配置图片上传"></a>typora 配置图片上传</h2><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/Xmhp8nIkoiCj1F5.png" alt></p>
<h2 id="下载PicGo-app"><a href="#下载PicGo-app" class="headerlink" title="下载PicGo.app"></a>下载PicGo.app</h2><p><a href="https://github.com/Molunerfinn/picgo/releases" target="_blank" rel="noopener">官方网址</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210227105055830.png" alt="image-20210227105055830"></p>
<h2 id="打开PicGo"><a href="#打开PicGo" class="headerlink" title="打开PicGo"></a>打开PicGo</h2><p>安装gitee插件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210227105157350.png" alt="image-20210227105157350"></p>
<h2 id="在gitee创建一个公开仓库"><a href="#在gitee创建一个公开仓库" class="headerlink" title="在gitee创建一个公开仓库"></a>在gitee创建一个公开仓库</h2><h2 id="在gitee生成私人令牌"><a href="#在gitee生成私人令牌" class="headerlink" title="在gitee生成私人令牌"></a>在gitee生成私人令牌</h2><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210227105703528.png" alt="image-20210227105703528"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210227105803433.png" alt="image-20210227105803433"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210227105836551.png" alt="image-20210227105836551"></p>
<h2 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h2><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200413215105622.png" alt="image-20200413215105622"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/2017/12/05/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="IP地址定义"><a href="#IP地址定义" class="headerlink" title="IP地址定义"></a>IP地址定义</h2><p>IP协议有个概念叫做IP地址，所谓的IP地址就是主机与主机之间沟通的识别码。</p>
<p>IP地址现在有两个版本32位的IPv4和128的IPv6，后者是为了解决数据包不够用而产生，每个数据包都必须携带目的IP地址和源IP地址，路由器依靠此信息为数据包选择路由。</p>
<p>IPV4为例，IP地址是由4个数字组成的，每个数字的取值范围0~255，</p>
<p>（1）十进制表示，比如192.168.0.1</p>
<p>（2）二进制表示，比如11000000.10101000.00000000.00000001</p>
<p>根据网络地址和主机地址在IP地址中所占的位数可将IP地址分为A、B、C、D、E五类，每一类网络可以从IP地址的第一个数字看出</p>
<p>A: 0xxxxxxx  xxxxxxxx  xxxxxxxx  xxxxxxxx</p>
<p>0  -   126</p>
<p>B: 10xxxxxx  xxxxxxxx  xxxxxxxx  xxxxxxxx</p>
<p>128 -191</p>
<p>C: 110xxxxx  xxxxxxxx  xxxxxxxx  xxxxxxxx</p>
<p>192  -223</p>
<p>D: 1110xxxx  xxxxxxxx  xxxxxxxx  xxxxxxxx</p>
<p>224 - 239</p>
<p>E: 11110xxx  xxxxxxxx  xxxxxxxx  xxxxxxxx</p>
<p>240 - 255</p>
<p>特殊的IP地址：</p>
<table>
<thead>
<tr>
<th>特殊的IP地址</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0.0.0.0</td>
<td>表示默认的路由，这个值用于简化IP路由表</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>表示本主机，使用这个地址，应用程序可以像访问远程主机一样访问本主机</td>
</tr>
<tr>
<td>网络号全为0的IP地址</td>
<td>表示本网络的某主机，如0.0.0.88将访问本网络中节点为88的主机</td>
</tr>
<tr>
<td>主机号全为0的IP地址</td>
<td>表示网络本身</td>
</tr>
<tr>
<td>网络号全为0的IP地址</td>
<td>表示所有主机</td>
</tr>
<tr>
<td>255.255.255.255</td>
<td>表示本网络广播</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网</title>
    <url>/2018/12/22/%E4%BA%92%E8%81%94%E7%BD%91/</url>
    <content><![CDATA[<h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><p>​    互联网，又称为国际网络，指的是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。</p>
<p>​    它始于1969年美国军方项目阿帕网，这就是因特网的前身，通常Internet泛指互联网，而Internet特指互联网。</p>
<h2 id="互联网是如何工作的？"><a href="#互联网是如何工作的？" class="headerlink" title="互联网是如何工作的？"></a>互联网是如何工作的？</h2><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/internet-schema-1.png" alt="Two computers linked together"></p>
<p>1.两台电脑需要通信的时候，必须连接两台电脑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/internet-schema-2-20210119165158409.png" alt></p>
<p>2.连接10台电脑，需要每台电脑有九个插头，总共需要45条网线，每台电脑相互连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/internet-schema-3.png" alt="Ten computers with a router"></p>
<p>3.我们把路由器加入到这个系统，我们的网络中便只需要十条网线；每台电脑一个插头，路由器上十个插口。</p>
<blockquote>
<p>网络的连接和快递运输一样，一个区域有个<code>中转站</code>，这个中转站区域范围内中的所有快递，汇总到这个中转站，再由中转站进行安排运输，不太可能专门为一个用户单独运输一次，效率太低了，针对下面快递点只需要将快递运到中转站就行了，其他不用它管了。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/internet-schema-4.png" alt="Two routers linked together"></p>
<p>4.当有更多的计算机时，此时一台路由器肯定不够，我们可以像连接电脑一样，将两个路由器相互连接。</p>
<blockquote>
<p>接着上面快递的例子，两个中转站相连，通过中转站相互通信就行了。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/internet-schema-5.png" alt="Routers linked to routers"></p>
<p>5.当接入的电脑不停的增加，我们使用路由器连接路由器，我们就会有无穷的规模。</p>
<blockquote>
<p>比如这个快递有跨国业务，我们将华东地区的所有中转站的快递，集中到上海一个专门的中转站，有这个中转站，专门跨国运输。</p>
</blockquote>
<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h2><p>HTTP(Hypertext Transfer Protocol) 超文本传输协议，是一个简单的请求-响应协议。它是运行在tcp协议之上的。</p>
<p>对于HTTP协议来说，客户端给服务器发送一个请求，服务器返回一个消息，这个请求就结束了，HTTP无法做到服务端主动给客户端主动推送数据。</p>
<h2 id="浏览器及其运行机制"><a href="#浏览器及其运行机制" class="headerlink" title="浏览器及其运行机制"></a>浏览器及其运行机制</h2><p><strong>浏览器是多进程的</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1460000021775003.png" alt="img"></p>
<p>每个tab页都是一个渲染进程。</p>
<h3 id="Browser进程-主进程"><a href="#Browser进程-主进程" class="headerlink" title="Browser进程(主进程)"></a>Browser进程(主进程)</h3><p>浏览器的主进程(负责协、主控)，只有一个。</p>
<p>负责浏览器的页面显示，与用户交互。如前进、后退等</p>
<p>负责各个页面的管理，创建和销毁其他进程</p>
<p>将Renderer进程得到的内存中的bitmap，绘制到用户界面上</p>
<h3 id="第三方插件进程"><a href="#第三方插件进程" class="headerlink" title="第三方插件进程"></a>第三方插件进程</h3><p>一个插件对应一个进程，</p>
<h3 id="GPU进程"><a href="#GPU进程" class="headerlink" title="GPU进程"></a>GPU进程</h3><p>用于3D绘制，只有一个。</p>
<h3 id="Renderer进程-渲染进程"><a href="#Renderer进程-渲染进程" class="headerlink" title="Renderer进程(渲染进程)"></a>Renderer进程(渲染进程)</h3><p>​    每个tab页面都会产生渲染进程，主要于页面渲染，脚本执行，事件处理等</p>
<p>渲染进程是多线程，它包含以下的线程</p>
<h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><p>负责渲染浏览器界面，解析<code>HTML</code>、<code>CSS</code>构建DOM树和RenderObject树，布局和绘制等</p>
<p>当界面需要绘制或者由于某种操作引发回流(reflow)时，该线程就执行。</p>
<p><code>GUI渲染线程</code>和<code>JS引擎线程</code>是互斥的，当JS引擎执行时GUI线程是会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时会被执行 。</p>
<p><strong>页面的渲染过程</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/format,png.png" alt="https://user-gold-cdn.xitu.io/2018/9/27/16618c829b879f35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/format,png-20210120142322685.png" alt="https://user-gold-cdn.xitu.io/2018/9/27/16619d637d220b20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><strong>特性</strong></p>
<p>默认情况下，CSS是阻塞的资源，浏览器在构建CSSOM的过程中，不会渲染任何已处理的内容。即便DOM已经解析完毕了，只要CSSOM不OK，那么渲染这个事情就不OK。</p>
<p>我们知道，只有当我们开始解析 HTML 后、解析到 link 标签或者 style 标签时，CSS 才登场，CSSOM 的构建才开始。很多时候，DOM 不得不等待 CSSOM。因此我们可以这样总结：</p>
<p>事实上，现在很多团队都已经做到了尽早（<code>将 CSS 放在 head 标签里</code>）和尽快（启用 CDN 实现静态资源加载速度的优化）。</p>
<p><strong>为什么互斥</strong>？</p>
<blockquote>
<p>因为JS可以操作DOM，如果同时修改元素属性并同时渲染界面（即JS线程和UI线程同时运行），那么就会导致数据不正确。</p>
</blockquote>
<h4 id="js引擎线程"><a href="#js引擎线程" class="headerlink" title="js引擎线程"></a>js引擎线程</h4><blockquote>
<p>js内核负责处理Javascript脚本程序</p>
</blockquote>
<p>一个tab页中只有一个JS线程</p>
<h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>对应事件触发，如鼠标点击，该线程会将事件对应的回调函数放入callback queue(任务队列)中，等待js引擎线程的处理。</p>
<h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><p>对应setTimeout,setInterval API，由该线程来计时，当计时结束，将事件对应的回调函数放入任务队列中。</p>
<h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h4><p>每有一个http请求就开一个该线程，当检测到状态变更的化，就会产生一个状态变更事件，如果该状态变更事件对应有回调函数的化，则放入任务队列中。</p>
<p><strong>多进程的优缺点</strong></p>
<p>防止单个功能crash，影响整个浏览器，多进程充分利用多核优势，提高浏览器的稳定性。</p>
<p>多个进程会消耗大量的系统资源。</p>
<h2 id="DNS及其运行机制"><a href="#DNS及其运行机制" class="headerlink" title="DNS及其运行机制"></a>DNS及其运行机制</h2><blockquote>
<p>在互联网中两台电脑想要通信，必须知道对方的IP地址，例如“202.95.134.213”这样的IP地址，实际上这样的ip地址非常不利于记忆，所以人们就想能不能用其他的好记的东西代替ip地址—–域名就诞生了，我们只需要在浏览器地址输入框中输入域名，就可以访问对应的页面了，这里就是用到<code>DNS服务器</code>，它的作用就是自动将域名翻译为ip地址。</p>
</blockquote>
<p>DNS（Domain Name System）域名系统，他是一个将域名和IP地址相互映射的一个分布式数据库，把容易记忆的主机名解析为主机的IP地址。</p>
<blockquote>
<p>DNS使用TCP和UDP端口53</p>
<p>每一级域名长度限制63个字符，域名总长度不能超过253个字符</p>
</blockquote>
<p><strong>DNS服务器分类</strong></p>
<p>​    一般分为三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。</p>
<img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/Center.jpeg" alt="img" style="zoom:150%;">

<p><strong>域名解析顺序</strong></p>
<p>​        <strong>1）</strong> <strong>浏览器缓存</strong></p>
<p>　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p>
<p>　　<strong>2）</strong> <strong>系统缓存</strong></p>
<p>　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；</p>
<p>　　<strong>3）</strong> <strong>路由器缓存</strong></p>
<p>　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</p>
<p>　　<strong>4）</strong> <strong>ISP</strong>（互联网服务提供商）DNS缓存</p>
<p>　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</p>
<p>　　<strong>5）</strong> <strong>根域名服务器</strong></p>
<p>　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；</p>
<p>　　<strong>6）</strong> <strong>顶级域名服务器</strong></p>
<p>　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；</p>
<p>　　<strong>7）</strong> <strong>主域名服务器</strong></p>
<p>　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；</p>
<p>　　<strong>8</strong>）保存结果至缓存</p>
<p>　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p>
<blockquote>
<p>这个就像找人一样，你想要找张三，但是你知道李四好像知道，你找到李四，李四说赵五知道，你找到赵五，赵五说韩六知道，你找到韩六，最终知道张三的地址。</p>
</blockquote>
<h2 id="网站托管"><a href="#网站托管" class="headerlink" title="网站托管"></a>网站托管</h2><p>网站托管的主要服务内容包括以下几个方面：</p>
<p>​    1、在网站正式上线之后，日常的更新是必不可少的，例如公司的动态、产品信息、服务项目、客户案例等。网站及时的更新可以让用户及时了解到企业的发展状况和动向，增强品牌知名度，关注行业的发展形势，让客户了解到企业的产品资讯。同时，网站的日常更新会更容易受到搜索引擎的青睐，有利于网站的排名提升，给企业带来更多的潜在客户。</p>
<p>​    2、网站的正常访问是网站建设的基础保障，如果企业的网站在运行过程中出现不能访问、数据库访问出错、网站被黑客入侵、空间域名到期等情况，会给企业带来无法估计的后果。往往很多闲置的网站因为没有专人维护，发生上述情况的概率会大大提升。</p>
<p>​    3、网站托管公司可以为企业提供专业的SEO技术团队，解决企业网站搜索引擎的排名问题。通过搜索引擎中搜索产品或服务关键词时企业的网站能够排名靠前，可以为企业带来更多的流量和潜在客户。SEO除了自身的优化外，还需要对网站本身代码结构及网站外部链接展开全面的工作，而具体的关键词等则需要企业和网站托管公司协商制定。</p>
<p>​    4、企业网站的运营需要具备丰富的网络营销经验和市场判断力，对网站流量的监控分析、潜在用户的行为分析、网络营销策划的效果分析等都至关重要。</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云账号注册</title>
    <url>/2021/03/24/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h1><p><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">官方网址</a></p>
<h2 id="申请腾讯云账号"><a href="#申请腾讯云账号" class="headerlink" title="申请腾讯云账号"></a>申请腾讯云账号</h2><p><a href="https://jingyan.baidu.com/article/20b68a88f158be796cec62c6.html" target="_blank" rel="noopener">指导链接</a></p>
<p>建议使用微信直接申请</p>
<h2 id="企业实名认证"><a href="#企业实名认证" class="headerlink" title="企业实名认证"></a>企业实名认证</h2><blockquote>
<p>使用企业实名认证，不要使用个人实名认证</p>
</blockquote>
<p><a href="https://cloud.tencent.com/document/product/378/10496" target="_blank" rel="noopener">官网文档指导链接</a></p>
<p><a href="https://boke112.com/postwd/8103.html" target="_blank" rel="noopener">指导链接</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20210324201724391.png" alt="image-20210324201724391"></p>
<p>认证方式看下哪种方式方便选择哪种。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>在私人服务器创建git仓</title>
    <url>/2019/11/26/%E5%9C%A8%E7%A7%81%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9B%E5%BB%BAgit%E4%BB%93/</url>
    <content><![CDATA[<h2 id="安装GIT"><a href="#安装GIT" class="headerlink" title="安装GIT"></a>安装GIT</h2><p>创建git账户并登录，直接指定用户目录到/home/git</p>
<h2 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd git -d &#x2F;home&#x2F;git -m -s &#x2F;bin&#x2F;bash</span><br><span class="line">su git</span><br></pre></td></tr></table></figure>

<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git init --bare mygit.git</span><br></pre></td></tr></table></figure>

<h2 id="设置SSH-Key"><a href="#设置SSH-Key" class="headerlink" title="设置SSH Key"></a>设置SSH Key</h2><p>在客户端和服务端都执行下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa &#x2F;&#x2F;生成密钥对</span><br><span class="line">id_rsa.pub传到服务器上，执行cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@&lt;服务器公网IP&gt;:/home/git/myserver.git</span><br></pre></td></tr></table></figure>

<h2 id="数据仓库的迁移"><a href="#数据仓库的迁移" class="headerlink" title="数据仓库的迁移"></a>数据仓库的迁移</h2><p>增加一个远端仓库</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1574780797750.png" alt="1574780797750"> </p>
<p>推送时选择新增的地址<br><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1574780839801.png" alt="1574780839801"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="利用公钥私钥解决Linux中git-clone-git库需要输入密码的问题"><a href="#利用公钥私钥解决Linux中git-clone-git库需要输入密码的问题" class="headerlink" title="利用公钥私钥解决Linux中git clone git库需要输入密码的问题"></a>利用公钥私钥解决Linux中git clone git库需要输入密码的问题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 700 .ssh</span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>git上的仓库对git用户要有写权限，同时需要将/etc/ssh/sshd_config中将RSA认证打开,即</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line"> </span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"> </span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>home/git属于git用户所有，且权限为755即drwxr-xr-x。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发学习路线</title>
    <url>/2021/01/16/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="前端路线"><a href="#前端路线" class="headerlink" title="前端路线"></a>前端路线</h1><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/e6e3185a-f3a1-4f91-8976-c4d46288f499.png" alt="e6e3185a-f3a1-4f91-8976-c4d46288f499"></p>
<h1 id="后端路线"><a href="#后端路线" class="headerlink" title="后端路线"></a>后端路线</h1><p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/68747470733a2f2f64617379646f6e672e6769746875622e696f2f696d672f6261636b656e642d6d61702d632e706e67.png" alt="68747470733a2f2f64617379646f6e672e6769746875622e696f2f696d672f6261636b656e642d6d61702d632e706e67"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>静态库和动态库</title>
    <url>/2018/12/05/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="库的分类"><a href="#库的分类" class="headerlink" title="库的分类"></a>库的分类</h1><p>linux下的库分为静态库和动态库。</p>
<p>静态库在程序编译时就已经被链接到目标代码中，目标程序运行不再需要该动态库。</p>
<p>优点：移植方便，就一个执行文件，不需要依赖。</p>
<p>缺点：体积较大，但是浪费空间和资源</p>
<p>动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。</p>
<p>优点：可执行文件体积较小，有了动态库，程序的升级相对变得简单，比如某个动态库文件升级，只需要更换这个动态库文件，而不需要去更换可执行文件，但要主要，可执行程序在运行时需要能找到动态库文件，可执行文件是动态库的调用者。</p>
<p>缺点：移植不方便，移植需要将依赖的动态库一起移植。</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>静态库在程序编译时就已经被链接到目标代码中，目标程序运行不再需要该动态库。</p>
<h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>使用ar创建静态库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ar [option] libxxx.a xx1.o xx1.o xx2.o .....</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>用来创建一个库，无论库</td>
</tr>
<tr>
<td>s</td>
<td>创建目标文件索引，这在创建较大的库时能加快时间</td>
</tr>
<tr>
<td>r</td>
<td>在库中插入模块，若插入的模块名已经在库中存在，则将替换同名的模块。</td>
</tr>
<tr>
<td>t</td>
<td>显示库文件中有哪些目标文件。</td>
</tr>
<tr>
<td>tv</td>
<td>显示库文件中有哪些目标文件。显示的信息包括文件名、时间、大小</td>
</tr>
<tr>
<td>s</td>
<td>显示静态库文件中的索引表</td>
</tr>
</tbody></table>
<p>静态库的命名规则：</p>
<p><code>lib + 库名称 + .a</code></p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"your age is "</span>&lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ -c test.cpp</span><br><span class="line"></span><br><span class="line">ar rcs libtest.a test.o <span class="comment">//将目标文件创建成名叫test的静态库</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">66</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"H I"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ -o main main.cpp -L . -ltest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-L用来告诉gcc哪里去找库文件。（.）表示当前路径</span><br><span class="line">-l的作用是用来指定具体的库，其中的lib和.a不用显式写出，g++或gcc会自动去寻找libtest.a,</span><br></pre></td></tr></table></figure>


<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>动态库又称为共享库，相比较静态库，动态库在编译时并没有被编译进目标代码，我们的程序执行到相关函数时才调用该函数库，所以动态函数库所产生的可执行文件比较小，由于函数库没有被整合到可执行代码中，而是程序运行时动态地申请并调用，所以程序的运行环境中必须提供相应的库。</p>
<p>生成so文件</p>
<h3 id="如何创建-1"><a href="#如何创建-1" class="headerlink" title="如何创建"></a>如何创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -fPIC -shared -o libtest.so <span class="comment">//生成so文件</span></span><br></pre></td></tr></table></figure>


<p>test.cpp是库函数源文件</p>
<p>libtest.so 是动态库文件</p>
<p>命令规则：</p>
<p><code>lib + 库名称 + .so</code></p>
<h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="so文件存放指定路径"><a href="#so文件存放指定路径" class="headerlink" title="so文件存放指定路径"></a>so文件存放指定路径</h4><p>存放在指定路径中，无需请他配置，系统会默认加载以下的目录的库文件。</p>
<p>将库复制到/usr/lib和/lib（不包含子目录）下，这两个路径是默认搜索的地方，复制到指定目录下，在执行ldconfig。</p>
<p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p>
<ul>
<li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li>
</ul>
<blockquote>
<p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p>
</blockquote>
<h4 id="将文件路径设置到环境变量"><a href="#将文件路径设置到环境变量" class="headerlink" title="将文件路径设置到环境变量"></a>将文件路径设置到环境变量</h4><p>告诉系统需要到环境变量中配置的路径去找动态库</p>
<ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
<h4 id="将文件路径增加到配置文件中"><a href="#将文件路径增加到配置文件中" class="headerlink" title="将文件路径增加到配置文件中"></a>将文件路径增加到配置文件中</h4><p>修改/etc/Id.so.conf,我们将动态库文件的路径加到/etc/id.so.conf中，接着执行Idconfig。</p>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>socket网络编程</title>
    <url>/2019/12/05/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="linux-网络编程"><a href="#linux-网络编程" class="headerlink" title="linux 网络编程"></a>linux 网络编程</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><p>协议就是一种规则，就是这传输的双方按照规定进行传输数据和返回数据。</p>
<h3 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h3><p>传输层，常见协议有TCP/UDP协议</p>
<p>应用层，常见的协议有HTTP协议，FTP协议</p>
<p>网络层，常见协议有IP协议、ICMP协议、IGMP协议</p>
<p>网络接口层 协议有ARP协议、RARP协议</p>
<p><strong>TCP</strong>传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<p><strong>UDP</strong>用户数据报协议是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p><strong>HTTP</strong>超文本传输协议是互联网上应用最为广泛的一种网络协议。</p>
<p><strong>FTP</strong>是文件传输协议</p>
<p><strong>IP</strong>协议是因特网互联协议</p>
<p><strong>ICMP</strong>协议是internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息</p>
<p><strong>IGMP</strong>协议是internet组管理协议是因特网协议家族中一个组播协议。该协议运行在主机和组播路由器之间。</p>
<p><strong>ARP</strong>协议是正向地址解析协议通过已知的IP，寻找对应主机的MAC主机</p>
<p><strong>RARP</strong>是反向地址转换协议，通过MAC地址确定IP地址</p>
<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><h3 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h3><p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/78310a55b319ebc4e6e4dff08d26cffc1e17163e.png" alt="img"> </p>
<p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输<code>比特流</code>（就是1、0转化为电流强弱来进行传输，到达目的地后转化为1、0，也就是我i们常说的数模转换与模数转换）。</p>
<p><strong>数据链路层</strong>：定义了如何让格式化数据以<code>帧</code>为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和矫正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1。</p>
<p><strong>网络层</strong>：在位于不同物理位置的网络中两个主机系统之间提供连接和路径选择。internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是这种连接的层。</p>
<p><strong>传输层</strong>：定义了一些传输数据的协议和端口号(www端口80等)，如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段和传输，到达目的地址后在进行重组。</p>
<p><strong>会话层</strong>：通过传输层（端口号：传输端口与接口端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p>
<p><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p>
<p><strong>应用层</strong>：是靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网路服务。</p>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p><code>TCP/IP</code>是Transmission Control Protocol/Internet Protocol的简写，传输控制协议/因特网互联协议，又名网络通信协议，是Internet基本协议。</p>
<p><code>TCP/IP</code>协议是为了解决不同系统的计算机之间的传输通信而提出的一个标准，不同系统的计算机采用同一种协议后，就能互相通信，从而建立网络连接，实现资源共享和网络通信。</p>
<p><code>TCP/IP</code>协议簇按照层次由上而下可以分成4层：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200608201136398.png" alt="image-20200608201136398"></p>
<p><strong>应用层</strong>：包含所以高层协议，比如虚拟终端协议、文件传输协议、电子邮件传输协议、域名服务、超文本传送协议等等，这些就是对应用户常用的应用软件。</p>
<p><strong>传输层</strong>：这层就是TCP协议和UDP协议这层，TCP是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务，UDP协议是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。</p>
<p><strong>网络层</strong>： 网络层实现数据包的选路和转发，通常使用众多分级的路由器来连接分散的主机或LAN， 该层是整个TCP/IP体系结构的关键部分，其功能是使主机把分组发往任何网络，并使分组独立地传向目标，这些分组可能经不同的网络，到达的顺序和发送的顺序也可能不同，协议包括IP协议、ICMP协议，IP协议。IP协议根据数据包的目的地址来决定如何投递它。ICMP协议（因特网控制报文协议），主要用于检测网络连接。</p>
<p><strong>网络接口层</strong> : 或称数据链路层，该层是整个体系结构的基础部分，负责接收IP和IP数据包，通过网络向外发送，或接收处理从网络上传的物理帧，抽出IP数据包，向IP层发送。该层是主机与网络的实际连接层。数据链路层两个常用的协议是<code>ARP协议（地址解析协议）和RARP协议（逆地址解析协议）</code>，<strong>它实现了IP地址和实际物理地址的之间的相互转换。</strong></p>
<p><strong>封装</strong></p>
<p>上层协议是如何使用下层协议提供的服务的呢？其实这是通过封装实现的，应用程序数据在发送到物理网络之前，需要经过传输层 —&gt; 网络层  —-&gt; 链路层，每一层的协议都将在上层数据的基础上加上自己的头部信息，以实现改层的功能，这个过程就叫封装</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td></td>
<td></td>
<td></td>
<td>应用程序数据</td>
</tr>
<tr>
<td>传输层</td>
<td></td>
<td></td>
<td>TCP/UDP头部</td>
<td>应用程序数据</td>
</tr>
<tr>
<td>网络层</td>
<td></td>
<td>IP头部</td>
<td>TCP/UDP头部</td>
<td>应用程序数据</td>
</tr>
<tr>
<td>网络接口层</td>
<td>以太网头部</td>
<td>IP头部</td>
<td>TCP/UDP头部</td>
<td>应用程序数据</td>
</tr>
</tbody></table>
<h4 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h4><p>ARP协议能实现任意网络层地址到任意物理地址的转换，其工作原理是：主机向自己的网络广播一个ARP请求，该请求包含目标机器的网络地址，此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>
<h4 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h4><p>我们通常使用机器的域名来访问这台机器，而不直接使用其IP地址，比如访问网站，那么如何将机器的域名转换成IP地址，这就需要使用域名查询服务，就是使用DNS协议向DNS服务器查询目标主机的IP地址。</p>
<p>需要访问DNS服务器，就需要知道DNS服务器的IP地址。我们需要配置DNS服务器的IP地址，常用有114.114.114.114 或者 8.8.8.8 。linux机器可以在/etc/resolv.conf文件中增加IP地址，可以配置两条IP地址（首选DNS服务器地址和备选DNS服务器地址）。</p>
<h3 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h3><p>TCP传输是可靠的，首先，TCP协议采用发送应答机制，即发送端发送的每个TCP报文段搜必须得到接收方的应答，才认为这个TCP报文段传输成功，其次，TCP协议采用超时重传机制，发送端在发送一个TCP报文之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段，最后，因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序、重复，所有TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用层。</p>
<p>Linux网络编程是通过socket（套接字）接口实现，socket是一种文件描述符，socket起源于UNIX，在Unix一切皆文件哲学思想下，socket是以一种“打开—-读/写—-关闭”模式的实现，服务器和客服端各自维护一个文件，在建立连接后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>Socket，英文含义是“插座”，在linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p>
<p>我们可以将socket看作为一个文件，可以通过文件描述符进行操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200627182817665.png" alt="image-20200627182817665"></p>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端和小端之分，网络数据流同样有大端和小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把网络上接到的字节一次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应该这样规定：先发的数据是低地址，后发出的数据是高地址。</p>
<p>TCP/IP协议规定，<strong>网络数据流应采用大端字节序</strong>。</p>
<h4 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>htonl</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint32_t htonl(uint32_t hostint32);</span><br></pre></td></tr></table></figure>

<p>功能：将32位主机字节序数据转换为网络字节序数据</p>
<p>参数：需要转换的43位主机字节序数据，无符号整型</p>
<p>返回值：若成功，返回网络字节序的值</p>
<p><strong>htons</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int16_t htons(uint16_t hostint16);</span><br></pre></td></tr></table></figure>

<p>功能：将16位主机字节序数据转换成网络字节序数据</p>
<p>参数：hostint16，需要转换的16位主机字节序数据，uint16_t为16为无符号短整型</p>
<p>返回值：若成功，返回网络字节序的值 </p>
<p><strong>ntohl</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint32_t ntohl(uint32_t netint32);</span><br></pre></td></tr></table></figure>

<p>功能：将32位网络字节序数据转换为主机字节序数据</p>
<p>参数：需要转换的32位网络字节序数据，uint32_t为32位无符号整型</p>
<p>返回值：若成功，返回主机字节序的值</p>
<p><strong>ntohs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint16_t ntohs(uint16_t netint16);</span><br></pre></td></tr></table></figure>

<p>功能：将16位网络字节序数据转换成主机字节序数据</p>
<p>参数：需要转换的16位网络字节序数据，uint16_t为16位无符号短整型</p>
<p>返回值，若成功，返回主机字节序的值</p>
<blockquote>
<p>h表示host，n表示network，l表示32位长整数，s表示16位短整数</p>
</blockquote>
<p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p>
<h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="comment">//转换网络主机地址cp为二进制数值，并存储在struct in_addr结构中，即第二个参数*inp</span></span><br><span class="line"><span class="comment">//返回值非0表示cp主机地址有效，返回0表示主机地址无效。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换网络主机地址为网络字节序二进制值，如果参数cp无效，函数返回-1（INADDR_NONE），这个函数处理地址为255.255.255.255时，也是返回-1，这个地址是有效的，只是这个函数无法处理。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">//转换网络字节序排序的地址为标准的ASCII以点分开的地址，该函数返回指向点分开的字符串地址的指针，该字符串的空间为静态分配的，</span></span><br></pre></td></tr></table></figure>

<p><strong>通用socket地址</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>sa_family</strong> 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。</p>
<table>
<thead>
<tr>
<th align="center">协议族</th>
<th align="center">地址族</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PE_UNIX</td>
<td align="center">AF_UNIX</td>
<td align="center">UNIX本地域协议族</td>
</tr>
<tr>
<td align="center">PE_INET</td>
<td align="center">AF_INET</td>
<td align="center">TCP/IPv4协议族</td>
</tr>
<tr>
<td align="center">PF_INET6</td>
<td align="center">AF_INET6</td>
<td align="center">TCP/IPv6协议族</td>
</tr>
</tbody></table>
<p>宏PE_ * 和 AF_ *  都定义在bits/socket.h 头文件中，两者的值一样的，所以二者通常混用</p>
<p><strong>sa_data</strong> 成员用于存放socket地址值</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达到108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td>PE_INET6</td>
<td>16bit端口号，32bit流标识，128bit IPv6地址，32bit 范围ID，共26字节。</td>
</tr>
</tbody></table>
<p>由于原来的结构体中 sa_data根本<strong>无法完全容纳多数协议族的地址值</strong>。</p>
<p><strong>新的通用socket地址结构体：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ss_align;</span><br><span class="line">    <span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_ailgn)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>专用socket地址</strong></p>
<p>由于之前两个socket地址结构体，操作起来很麻烦，所以linux为各个协议族提供了专门的socket地址结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;		<span class="comment">/*地址族：AF_UNIX*/</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];			<span class="comment">/*文件路径名*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;		<span class="comment">/*地址族：AF_INET*/</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;			<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">/*IPv4 地址结构体*/</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;			<span class="comment">/*IPv4 地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;	<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;	    <span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_flowinfo;	<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>	<span class="comment">/*IPv6 地址结构体*/</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_scope_id;	<span class="comment">/*scope ID，尚处于实验阶段*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];	<span class="comment">/*IPv6 地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>socket类型</strong></p>
<p>常见的socket分为3种：</p>
<ol>
<li>流式sokcet（<strong>SOCK_STREAM</strong>）</li>
</ol>
<p>   流式套接字提供可靠的，面向连接的通信流；它使用TCP协议，从而保证了数据传输的正确性，和顺序性。</p>
<ol start="2">
<li>数据报socket（<strong>SOCK_DGRAM</strong>）</li>
</ol>
<p>   数据报套接字定义了一种无连接的，数据通过相互独立报文进行传输，是无序的，并且不保证是可靠、无差错的，它使用数据报协议UDP。</p>
<ol start="3">
<li><p>原始socket（<strong>SOCK_RAW</strong>）</p>
<p>原始套接字允许对底层协议如“IP”或“ICMP”进行直接访问，功能强大但使用较为不便，主要用于一些协议的开发。</p>
</li>
</ol>
<p><strong>相关API</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr * my_addr.<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr *addr,<span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* serv_addr,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbyte)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">void</span> *msg,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> * buf,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">void</span> *msg,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,struct sockaddr *to,<span class="keyword">int</span> tolen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,struct sockaddr * from,<span class="keyword">int</span> *fromlen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="API参数取值介绍"><a href="#API参数取值介绍" class="headerlink" title="API参数取值介绍"></a>API参数取值介绍</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><ul>
<li><em>domain</em></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_UNIX, AF_LOCAL</td>
<td>本地通信</td>
</tr>
<tr>
<td>AF_INET</td>
<td>IPv4 Internet协议</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPv6 Internet协议</td>
</tr>
<tr>
<td>AF_IPX</td>
<td>IPX-Novell协议</td>
</tr>
<tr>
<td>AF_NETLINK</td>
<td>内核用户界面设备</td>
</tr>
<tr>
<td>AF_X25</td>
<td>ITU-T X25 / ISO-8208协议</td>
</tr>
<tr>
<td>AF_AX25</td>
<td>Amateur radio AX.25</td>
</tr>
<tr>
<td>AF_ATMPVC</td>
<td>原始ATM PVC访问</td>
</tr>
<tr>
<td>AF_APPLETALK</td>
<td>Appletalk</td>
</tr>
<tr>
<td>AF_PACKET</td>
<td>底层包访问</td>
</tr>
<tr>
<td>AF_ALG</td>
<td>内核加密API</td>
</tr>
</tbody></table>
<ul>
<li><em>type</em></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>TCP连接（提供序列化的、可靠的、双向连接的字节流，支持带外数据传输）</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>UDP连接（无连接状态、不可靠的报文）</td>
</tr>
<tr>
<td>SOCK_SEQPACKET</td>
<td>序列化包，提供一个序列化的、可靠的、双向的基本连接的数据传输通道，数据长度定常。每次调用读系统调用时数据需要将全部数据读出</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>RAW类型，提供原始网络协议访问</td>
</tr>
<tr>
<td>SOCK_RDM</td>
<td>提供可靠的数据报文，不过可能数据会有乱序</td>
</tr>
</tbody></table>
<ul>
<li><em>protocol</em> </li>
</ul>
<p>常取值0</p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><ul>
<li><p><em>backlog</em></p>
<p>用来描述sockfd的等待连接队列能够达到的最大值。 </p>
</li>
</ul>
<h4 id="send-recv-sendto-recvfrom"><a href="#send-recv-sendto-recvfrom" class="headerlink" title="send/recv/sendto/recvfrom"></a>send/recv/sendto/recvfrom</h4><blockquote>
<p>sendto 和 recvfrom 中flag取值一样</p>
</blockquote>
<ul>
<li><em>flags</em></li>
</ul>
<table>
<thead>
<tr>
<th>flags</th>
<th>说明</th>
<th>recv</th>
<th>send</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_CONFIRM</td>
<td>指示数据链路层协议持续监听对方的回应，知道得到答复，它仅用于SOCK_DGRAM和 SOCK_RAW类型的socket</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>绕过路由表查找</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>仅本操作非阻塞</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>告诉内核应用程序还有更多数据要发送，内核将超时等待新数据写入TCP发送缓冲区后一并发送，这样可防止TCP发送过多小的报文段，从而提高传输效率</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>等待所有消息</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>窥看外消息</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>发送或接收带外数据</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>往读端关闭的管道或者socket连接中写数据时不引发SIGPIPE信号</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<p>服务器端编程：**</p>
<p>（1）创建服务端套接字（使用socket）</p>
<p>（2）绑定套接字到一个IP地址和一个端口上（使用bind）</p>
<p>（3）将套接字设置为监听模式等待连接请求（使用listen），这个套接字就是监听套接字。</p>
<p>（4）请求到来后，接受连接请求，返回一个新的对应此次连接的套接字（accept）。</p>
<p>（5）用返回的新的套接字和客户端进行通信，即发送或接受数据（使用函数send或recv），通信结束就关闭这个套接字（使用closesocket）</p>
<p>（6）监听套接字继续处于监听状态，等待其他客户端的连接请求。</p>
<p>（7）如果要退出服务器程序，则先关闭监听套接字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));           <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                     <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>); <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);                   <span class="comment">//端口</span></span><br><span class="line">    bind(serv_sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a><strong>客户端编程</strong></h3><p>（1）创建客户端套接字（使用函数socket）</p>
<p>（2）向服务器发出连接请求（使用函数connect）</p>
<p>（3）和服务器进行通信，即发送或接收数据（使用函数send或recv）</p>
<p>（4）如果要关闭客户端程序，则先关闭套接字（使用函数closesocket）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">read</span>(sock, <span class="built_in">buffer</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>)<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message form server: %s\n"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>我们可以将使用的函数进行封装下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_SOCKET_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_SOCKET_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(domain, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perr_exit(<span class="string">"socket Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *net_addr, <span class="keyword">socklen_t</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, net_addr, addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perr_exit(<span class="string">"bind Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">listen</span>(sockfd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perr_exit(<span class="string">"listen Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *sa, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((clnt_sock = accept(sockfd, sa, addrlen)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perr_exit(<span class="string">"accept Error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clnt_sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">connect</span>(sockfd, sa, len)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perr_exit(<span class="string">"connect Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(sockfd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">write</span>(sockfd, ptr, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字节读取</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;  <span class="comment">//剩余未读取的字节数</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread; <span class="comment">//实际读取到的字节数</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="keyword">char</span> *)vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(sockfd, ptr, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">//被中断，一个都没有读</span></span><br><span class="line">            &#123;</span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) <span class="comment">//读0个字节 读取完毕</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = (<span class="keyword">char</span> *)vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = <span class="built_in">write</span>(sockfd, ptr, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nleft -= nwritten;</span><br><span class="line">            ptr += nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>字符大写转换</strong></p>
<p><strong>服务端</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = Socket(AF_INET, SOCK_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));           <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                     <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>); <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);                   <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    Bind(serv_sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    Listen(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> clnt_sock = Accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">read</span>(clnt_sock, <span class="built_in">buffer</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">buffer</span>[i] = <span class="built_in">toupper</span>(<span class="built_in">buffer</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(clnt_sock, <span class="built_in">buffer</span>, len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));           <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;                     <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>); <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);                   <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> read_buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> write_buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建套接字</span></span><br><span class="line">        <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Connect(sock, (struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; write_buffer;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(sock, write_buffer, <span class="built_in">strlen</span>(write_buffer));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span>(sock, read_buffer, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Message form server: %s\n"</span>, read_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">memset</span>(write_buffer, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭套接字</span></span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环服务器"><a href="#循环服务器" class="headerlink" title="循环服务器"></a>循环服务器</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    Bind(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line"></span><br><span class="line">    Listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_connect</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> read_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">char</span> write_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> connfd = Accept(sockfd, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ip: "</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">" port: "</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">size</span> = <span class="built_in">read</span>(connfd, read_buffer, BUFFLEN);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"接收："</span> &lt;&lt; read_buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(write_buffer, read_buffer);</span><br><span class="line">                <span class="built_in">write</span>(connfd, write_buffer, <span class="built_in">strlen</span>(write_buffer) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">            <span class="built_in">memset</span>(write_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = getsockfd();</span><br><span class="line">    handle_connect(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    Connect(sockfd, (<span class="keyword">const</span> struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_request</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> read_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">char</span> write_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; write_buffer;</span><br><span class="line">        <span class="built_in">write</span>(sockfd, write_buffer, <span class="built_in">strlen</span>(write_buffer) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span>(sockfd, read_buffer, BUFFLEN);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"接收: "</span> &lt;&lt; read_buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(read_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">        <span class="built_in">memset</span>(write_buffer,<span class="number">0</span>,<span class="keyword">sizeof</span>(write_buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = getsockfd();</span><br><span class="line">    handle_request(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    Bind(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> read_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">char</span> write_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> = recvfrom(sockfd, read_buffer, BUFFLEN, <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ip: "</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">" port:"</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="string">" data:"</span> &lt;&lt; read_buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(write_buffer, read_buffer);</span><br><span class="line">            sendto(sockfd, write_buffer, <span class="built_in">strlen</span>(write_buffer) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">        <span class="built_in">memset</span>(write_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建UDP套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> read_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">char</span> write_buffer[BUFFLEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">to</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(to);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; write_buffer;</span><br><span class="line"></span><br><span class="line">        sendto(sockfd, write_buffer, <span class="built_in">strlen</span>(write_buffer) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line"></span><br><span class="line">        recvfrom(sockfd, read_buffer, BUFFLEN, <span class="number">0</span>, (struct sockaddr *)&amp;to, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"接收: "</span> &lt;&lt; read_buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(write_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_buffer));</span><br><span class="line">        <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h3><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    Bind(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line"></span><br><span class="line">    Listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_connect</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> read_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">char</span> write_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> connfd = Accept(sockfd, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ip: "</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">" port: "</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">size</span> = <span class="built_in">read</span>(connfd, read_buffer, BUFFLEN);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"接收："</span> &lt;&lt; read_buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(write_buffer, read_buffer);</span><br><span class="line">                <span class="built_in">write</span>(connfd, write_buffer, <span class="built_in">strlen</span>(write_buffer) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">            <span class="built_in">memset</span>(write_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = getsockfd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pid[i] = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            handle_connect(sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<blockquote>
<p>客户端的代码不需要重复写，使用之前循环服务器的就可以了</p>
</blockquote>
<h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h4><p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> read_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">char</span> write_buffer[BUFFLEN];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> = recvfrom(sockfd, read_buffer, BUFFLEN, <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">size</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" ip: "</span> &lt;&lt; inet_ntoa(client.sin_addr) &lt;&lt; <span class="string">" port:"</span> &lt;&lt; ntohs(client.sin_port) &lt;&lt; <span class="string">" data:"</span> &lt;&lt; read_buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(write_buffer, <span class="string">"服务端的处理进程: %d 数据: %s"</span>, getpid(), read_buffer);</span><br><span class="line">            sendto(sockfd, write_buffer, <span class="built_in">strlen</span>(write_buffer) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;client, <span class="keyword">sizeof</span>(client));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">        <span class="built_in">memset</span>(write_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    Bind(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">    <span class="keyword">pid_t</span> pid[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid[i] = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            handle(sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><p>linux系统在处理io操作时，一般先等数据传到 kernel  space，然后在从kernel space拷贝到用户空间（ 进程或者线程的缓冲区 ）。</p>
<p>下面介绍的select多路复用的机制。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><ul>
<li>每次调用select，需要把fd集合从用户态拷贝到内核态，内核中轮询查找所有fd，找打那个准备好的，select函数就会返回。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p><em>nfds</em> ：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的。</p>
<p><em>readfds</em>： 可读 描述符集合 </p>
<p><em>writefds</em>： 可写 描述符集合 </p>
<p><em>exceptfds</em>： 异常等事件对应的描述符集合 </p>
<p><em>timeout</em>： 用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间 </p>
<p>返回值：超时返回0，失败返回-1，成功返回大于0的整数，这个整数表示就绪描述符的数目。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span>      </span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相关的宏</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;	<span class="comment">//将fd从set清除出去</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//判断fd是否在集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;	 <span class="comment">//将fd设置到set集合中去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;			<span class="comment">//将set清空</span></span><br></pre></td></tr></table></figure>

<p>使用步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd_set readfds;</span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(fd1,&amp;readfds);</span><br><span class="line">FD_SET(fd2,&amp;readfds);</span><br><span class="line">FD_SET(fd3,&amp;readfds);</span><br><span class="line"></span><br><span class="line">select ---&gt; 返回一个准备就绪的fd总数</span><br></pre></td></tr></table></figure>

<ol>
<li>select 能监听的文件描述符个数受限于FD_SIZE的大小，一般为1024，单纯改变进程打开的文件描述符个数不能改变select监听文件个数</li>
<li>解决1024以下客户端时使用select是很适合的，但如果连接客户过多，select采用的是轮询模型，会大大降低服务器响应效率，不应该在select上研究过多。</li>
</ol>
<p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysocket.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZ 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = Socket(AF_INET, SOCK_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>, <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">    server_addr.sin_addr.s_addr = htons(PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nready, client[FD_SETSIZE];</span><br><span class="line"></span><br><span class="line">    fd_set rset, allset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        client[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;allset);          <span class="comment">//清空集合</span></span><br><span class="line">    FD_SET(listenfd, &amp;allset); <span class="comment">//将监听套接字放入集合中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxfd = listenfd;</span><br><span class="line">    <span class="keyword">int</span> maxi = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"select Error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断监听套接字是否在集合中</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> connfd = Accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;len);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ip: "</span> &lt;&lt; inet_ntoa(client_addr.sin_addr) &lt;&lt; <span class="string">" port: "</span> &lt;&lt; ntohs(client_addr.sin_port) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    client[i] = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"too many clients"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">            &#123;</span><br><span class="line">                maxi = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxi; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历已经登记的fd，哪个是待读取的文件描述符</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">size</span> = <span class="built_in">read</span>(sockfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);</span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sleep(<span class="number">10</span>);</span><br><span class="line">                    <span class="built_in">write</span>(sockfd, buf, <span class="built_in">size</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>server.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>server.cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p> <img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/v2-14e0536d872474b0851b62572b732e39_1440w.jpg" alt="img"> </p>
<h1 id="select、poll、epoll之间的区别"><a href="#select、poll、epoll之间的区别" class="headerlink" title="select、poll、epoll之间的区别"></a>select、poll、epoll之间的区别</h1><h2 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h2><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<h2 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h2><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p>
<h2 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200731210247804.png" alt="image-20200731210247804"></p>
<h3 id="epoll的两种触发模式"><a href="#epoll的两种触发模式" class="headerlink" title="epoll的两种触发模式"></a>epoll的两种触发模式</h3><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。</p>
<p>LT（水平触发）模式下，只要这个文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；</p>
<p>ET（边缘触发）模式下，在它检测到有 I/O 事件时，通过 epoll_wait 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 errno 返回 EAGAIN 为止，否则下次的 epoll_wait 不会返回余下的数据，会丢掉事件。如果ET模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200731210300948.png" alt="image-20200731210300948"></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/2018/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><blockquote>
<p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
</blockquote>
<p>计算机中的数据都是以二进制形式进行存储的，早期计算机只支持ASCII码。</p>
<p>ASCII码我们知道，是使用一个字节（8位二进制）来表示字符的。</p>
<p>那计算机使用ASCII编码格式来进行处理字符，即一个字节表示一个字符，下图是ASCII码表</p>
<blockquote>
<p>例如：空格space，十进制位32，二进制00100000</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/ascii-Table.jpg" alt="ASCII码表"></p>
<p>ASCII码是使用一个字节来表示字符的，二进制表示它最大支持256个字符，ASCII码取正整数的128个数字来对应表示英文字母和一些常用字符，这个标准最早是美国人发明的，从现在来看它远远不够，比如说，光光中文就有几万个字符，所以各个国家都制定自己都标准。</p>
<p>世界上存在很多种编码方式，同一个二进制数字可以被解释成不同的的符号，当我们打开一个文本文件，就必须知道它的编码方式，不然会出现很多乱码字符。</p>
<p>为了解决这个问题，需要一个统一的标准，Unicode由此应运而生，它现在的规模就可以容纳100多万个字符，为世界上已知的所有文字都赋予一个独一无二的的编码。</p>
<p><strong>unicode只是一个字典，具体使用还是需要看各种字符集怎么使用</strong></p>
<p>unicode的表示的字符从2个字节到4个字节，那就出现一个问题，<strong>计算机怎么去识别两个字节是一个字符或者二个字节是两个字符</strong>？，<strong>如果将所以字符都存储为4个字节的话，就会使数据大小急剧增加</strong>。</p>
<p><strong>UTF-8</strong>就是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号而变化长度。</p>
<blockquote>
<p>1. 对于单字节的符号，字节的第一位为0，后面的7位就是这个符号的Unicode的码。</p>
<p>2.  对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 </p>
</blockquote>
<ol>
<li>第一位为0时，则这个字节单独就表示一个字符。</li>
<li>获取一个字节，如果第一1，就继续往后读，有多少个1就是几个字节的字符。</li>
</ol>
<blockquote>
<p>举个列子: “严” 的unicode的编码是4E25（ 100111000100101 ），根据上面的转换逻辑，”严”的UTF-8的编码就是 11100100 10111000 10100101, 转换成十六进制就是E4B8A5 </p>
</blockquote>
<h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>我们平时使用就是十进制，它是由0~9共十个数字组成第，它的计算规则是“逢十进一”</p>
<p>比如：8+5的结果，就是大于9，一个数字不够表示，这时只能进位，用13来表示；</p>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>它是由0和1，两个数字组成的。</p>
<p>学过计算机的人都知道，计算机中使用的是二进制，它的规则是“逢二进一”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1A45323b-0.png" alt="img"></p>
<p>如果想要使用二进制表示11这个数字，我们可以使用二进制从1开始加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+1 &#x3D; 10 &#x3D;&gt; 2</span><br><span class="line"></span><br><span class="line">10 +1 &#x3D; 11 &#x3D;&gt; 3</span><br><span class="line"></span><br><span class="line">11 + 1&#x3D; 100 &#x3D;&gt; 4</span><br><span class="line"></span><br><span class="line">100 + 1 &#x3D; 101 &#x3D;&gt; 5</span><br><span class="line"></span><br><span class="line">101 + 1 &#x3D; 110 &#x3D;&gt; 6</span><br><span class="line"></span><br><span class="line">110 + 1 &#x3D; 111 &#x3D;&gt; 7</span><br><span class="line"></span><br><span class="line">111 + 1 &#x3D; 1000 &#x3D;&gt; 8</span><br><span class="line"></span><br><span class="line">1000 + 1 &#x3D; 1001 &#x3D;&gt; 9</span><br><span class="line"></span><br><span class="line">1001 + 1 &#x3D; 1010 &#x3D;&gt; 10</span><br><span class="line"></span><br><span class="line">1010 + 1 &#x3D; 1011 &#x3D;&gt; 11</span><br></pre></td></tr></table></figure>

<h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p>它是由0~7共8个数字组成的，规则是逢八进一。</p>
<p>计算方法和其他的类似。</p>
<h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>它是由0~F共16个数字和字符组成的，规则是逢十六进一。</p>
<p>0~9和十进制一样，A表示10，B表示11，C表示12，D表示13，E表示14，F表示15。</p>
<h2 id="进制之间的转换"><a href="#进制之间的转换" class="headerlink" title="进制之间的转换"></a>进制之间的转换</h2><h3 id="目标十进制"><a href="#目标十进制" class="headerlink" title="目标十进制"></a>目标十进制</h3><p>二进制转换为十进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11010 &#x3D; 1×2^4 + 1×2^3 + 0×2^2 + 1×2^1 + 0×2^0 &#x3D; 26（十进制）</span><br></pre></td></tr></table></figure>

<p>八进制转换为十进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">53627 &#x3D; 5×8^4 + 3×8^3 + 6×8^2 + 2×8^1 + 7×8^0 &#x3D; 22423（十进制）</span><br></pre></td></tr></table></figure>

<p>十六进制转换为十进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9FA8C &#x3D; 9×16^4 + 15×16^3 + 10×16^2 + 8×16^1 + 12×16^0 &#x3D; 653964（十进制）</span><br></pre></td></tr></table></figure>

<p>带小数(八进制转十进制)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">423.5176 &#x3D; 4×8^2 + 2×8^1 + 3×8^0 + 5×8^-1 + 1×8^-2 + 7×8^-3 + 6×8^-4 &#x3D; 275.65576171875（十进制）</span><br></pre></td></tr></table></figure>

<h3 id="目标二进制"><a href="#目标二进制" class="headerlink" title="目标二进制"></a>目标二进制</h3><p>十进制转换为二进制</p>
<p>方法：使用十进制数进行除二取余数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1AP56100-1.png" alt="img"></p>
<p>小数部分</p>
<p> 十进制小数 0.6875 转换成二进制小数的过程： </p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1AP5H92-3.png" alt="img"></p>
<p>八进制转化为二进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200219163422725.png" alt="image-20200219163422725"></p>
<p>十六进制转化为二进制</p>
<p>和八进制一样，将没一位拆分成4位二进制。</p>
<h3 id="目标八进制"><a href="#目标八进制" class="headerlink" title="目标八进制"></a>目标八进制</h3><p>十进制转化为八进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1AP56143-0.png" alt="img"></p>
<p>二进制转化为八进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/image-20200219163508936.png" alt="image-20200219163508936"></p>
<p>十六进制转化为八进制</p>
<p>先转化为而二进制，再转换为八进制</p>
<h3 id="目标十六进制"><a href="#目标十六进制" class="headerlink" title="目标十六进制"></a>目标十六进制</h3><p>二进制转化为十六进制</p>
<p>拆分法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1001 1100 1111</span><br><span class="line"> 9     C    F</span><br></pre></td></tr></table></figure>



<p>八进制转化为十六进制</p>
<p>先转化为二进制，在转化为十六进制</p>
<p>十进制转化为十六进制</p>
<p>十进制除以16，再取余。小数部分，乘以16取整。</p>
<h1 id="原码反码和补码"><a href="#原码反码和补码" class="headerlink" title="原码反码和补码"></a>原码反码和补码</h1><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p> 将一个整数转换成二进制形式，就是其原码。例如<code>short a = 6;</code>，a 的原码就是<code>0000 0000 0000 0110</code>；更改 a 的值<code>a = -18;</code>，此时 a 的原码就是<code>1000 0000 0001 0010</code>。 </p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>谈到反码，正数和负数要区别对待，因为它们的反码不一样。</p>
<p>对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。例如<code>short a = 6;</code>，a 的原码和反码都是<code>0000 0000 0000 0110</code>；更改 a 的值<code>a = -18;</code>，此时 a 的反码是<code>1111 1111 1110 1101</code>。 </p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p> 正数和负数的补码也不一样，也要区别对待。</p>
<p>对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。例如<code>short a = 6;</code>，a 的原码、反码、补码都是<code>0000 0000 0000 0110</code>；更改 a 的值<code>a = -18;</code>，此时 a 的补码是<code>1111 1111 1110 1110</code>。</p>
<p>可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。</p>
<p>原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。</p>
<p>最后我们总结一下 6 和 -18 从原码到补码的转换过程： </p>
<p><img src="https://cdn.jsdelivr.net/gh/Amdeo/blogImg/img/1121446295-0.jpg" alt="img"></p>
<p><strong>在计算机内存中，整数一律采用补码的形式来存储。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。将补码转换为原码也很简单：先减去 1，再将数值位取反即可。</strong> </p>
<h3 id="补码到底是如何简化硬件电路的"><a href="#补码到底是如何简化硬件电路的" class="headerlink" title="补码到底是如何简化硬件电路的"></a>补码到底是如何简化硬件电路的</h3><p> 假设 6 和 18 都是 short 类型的，现在我们要计算 6 - 18 的结果 </p>
<p> 如果采用<strong>原码</strong>计算，那么运算过程为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 - 18 &#x3D; 6 + (-18)</span><br><span class="line">&#x3D; [0000 0000 0000 0110]原 + [1000 0000 0001 0010]原</span><br><span class="line">&#x3D; [1000 0000 0001 1000]原</span><br><span class="line">&#x3D; -24 （很明显结果不对）</span><br></pre></td></tr></table></figure>

<p>下面人才采用<strong>反码</strong>进行计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 - 18 &#x3D; 6 + (-18)</span><br><span class="line">&#x3D; [0000 0000 0000 0110]反 + [1111 1111 1110 1101]反</span><br><span class="line">&#x3D; [1111 1111 1111 0011]反</span><br><span class="line">&#x3D; [1000 0000 0000 1100]原</span><br><span class="line">&#x3D; -12</span><br></pre></td></tr></table></figure>

<p>结果是正确的。</p>
<p>但是是否适用于所有场景？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18 - 6 &#x3D; 18 + (-6)</span><br><span class="line">&#x3D; [0000 0000 0001 0010]反 + [1111 1111 1111 1001]反</span><br><span class="line">&#x3D; [1 0000 0000 0000 1011]反 (第一位的1是加法的进位，它溢出了，内存容纳不了，所以截掉了)</span><br><span class="line">&#x3D; [0000 0000 0000 1011]反</span><br><span class="line">&#x3D; [0000 0000 0000 1011]原</span><br><span class="line">&#x3D; 11</span><br></pre></td></tr></table></figure>

<p> 按照反码计算的结果是 11，而真实的结果应该是 12 才对，它们相差了 1。 </p>
<p>下面我们继续使用补码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 - 18 &#x3D; 6 + (-18)</span><br><span class="line">&#x3D; [0000 0000 0000 0110]补 + [1111 1111 1110 1110]补</span><br><span class="line">&#x3D; [1111 1111 1111 0100]补</span><br><span class="line">&#x3D;  [1111 1111 1111 0011]反</span><br><span class="line">&#x3D; [1000 0000 0000 1100]原</span><br><span class="line">&#x3D; -12</span><br><span class="line"></span><br><span class="line">18 - 6 &#x3D; 18 + (-6)</span><br><span class="line">&#x3D; [0000 0000 0001 0010]补 + [1111 1111 1111 1010]补</span><br><span class="line">&#x3D; [1 0000 0000 0000 1100]补</span><br><span class="line">&#x3D; [0000 0000 0000 1100]补</span><br><span class="line">&#x3D; [0000 0000 0000 1100]反</span><br><span class="line">&#x3D; [0000 0000 0000 1100]原</span><br><span class="line">&#x3D; 12</span><br><span class="line"></span><br><span class="line">5 - 13 &#x3D; 5 + (-13)</span><br><span class="line">&#x3D;  [0000 0000 0000 0101]补 + [1111 1111 1111 0011]补</span><br><span class="line">&#x3D; [1111 1111 1111 1000]补</span><br><span class="line">&#x3D; [1000 1111 1111 0111]反</span><br><span class="line">&#x3D; [1000 0000 0000 1000]原</span><br><span class="line">&#x3D; -8</span><br><span class="line"></span><br><span class="line">13 - 5 &#x3D; 13 + (-5)</span><br><span class="line">&#x3D; [0000 0000 0000 1101]补 + [1111 1111 1111 1011]补</span><br><span class="line">&#x3D; [1 0000 0000 0000 1000]补 </span><br><span class="line">&#x3D; [0000 0000 0000 1000]补</span><br><span class="line">&#x3D; [0000 0000 0000 1000]反</span><br><span class="line">&#x3D; [0000 0000 0000 1000]原</span><br><span class="line">&#x3D; 8</span><br></pre></td></tr></table></figure>

<p>可以看出来所有的计算都真确了。</p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>位(bit)：又称为比特，是计算机中最小单位，即0或者1</p>
<p>字节(Byte)：是计算机的内存中基本单位</p>
<p>字：指在计算机中作为一个整体被存取、传送、处理的一组二进制数。一个字的位数（即字长）是计算机系统结构中的一个重要特性。字长是由CPU的类型所决定，不同的计算机系统的字长是不同的，常见的有8位、16位、32位、64位等，字长越长，计算机一次处理的信息位就越多，精度就越高，字长是计算机性能的一个重要指标，目前主流微机正在由32位机向64位机转变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1B</span>yte = <span class="number">8b</span>it</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>KB (Kilobyte 千字节) = <span class="number">1024B</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>MB (Megabyte 兆字节 简称“兆”) = <span class="number">1024</span>KB</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>GB (Gigabyte 吉字节 又称“千兆”) = <span class="number">1024</span>MB</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>TB (Trillionbyte 万亿字节 太字节) = <span class="number">1024</span>GB </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>PB（Petabyte 千万亿字节 拍字节) = <span class="number">1024</span>TB</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>EB（Exabyte 百亿亿字节 艾字节) = <span class="number">1024</span>PB</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>ZB (Zettabyte 十万亿亿字节 泽字节) = <span class="number">1024</span>EB</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>YB (Jottabyte 一亿亿亿字节 尧字节) = <span class="number">1024</span>ZB</span><br><span class="line"></span><br><span class="line"><span class="number">1B</span>B (Brontobyte 一千亿亿亿字节) = <span class="number">1024</span>YB</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器</title>
    <url>/2021/12/12/%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>传统的编译器通常分为：前端、优化器和后端。</p>
<p>前端：主要负责词法和语法分析，将源代码转化为抽象语法树</p>
<p>优化器：在前端的基础上，对中间代码进行优化，使代码更加高效</p>
<p>后端：将已经优化的中间代码转化为针对各自平台的机器代码</p>
<p>常用的两大编译器：</p>
<p>GCC和clang</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC是一套由GNU开发的编程语言编译器。GCC原名为GNU C语言编译器，因为它原本只能处理C语言，现在可以支持C++、Fortan、Pascal、Objective-C、Java以及Ada等其他语言。</p>
<p>许多操作系统，包括类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。</p>
<p>GCC支持的主要处理器架构：ARM、x86、x86-64、MIPS、PowerPC等。</p>
<h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h2><blockquote>
<p>是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端</p>
</blockquote>
<p>它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装GCC的替代品。Clang主要由C++编写。</p>
<p>GCC与Clang区别：</p>
<p><strong>GCC特性</strong>：除支持C/C++/ Objective-C/Objective-C++语言外，还是支持Java/Ada/Fortran/Go等；当前的Clang的C++支持落后于GCC；支持更多平台；更流行，广泛使用，支持完备。<br><strong>Clang特性</strong>：编译速度快；内存占用小；兼容GCC；设计清晰简单、容易理解，易于扩展增强；基于库的模块化设计，易于IDE集成；出错提示更友好。</p>
]]></content>
  </entry>
  <entry>
    <title>前端开发知识收集</title>
    <url>/2022/07/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h3 id="获取浏览器大小"><a href="#获取浏览器大小" class="headerlink" title="获取浏览器大小"></a>获取浏览器大小</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.innerWidth</span><br><span class="line"><span class="built_in">window</span>.innerHeight</span><br></pre></td></tr></table></figure>

<h3 id="var变量提升"><a href="#var变量提升" class="headerlink" title="var变量提升"></a>var变量提升</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(ar); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> ar = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(et); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> et = <span class="number">512</span>;</span><br></pre></td></tr></table></figure>

<h3 id="restful-规范"><a href="#restful-规范" class="headerlink" title="restful 规范"></a>restful 规范</h3><table>
<thead>
<tr>
<th align="center">HTTP动词</th>
<th><strong>URI路径</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td>http://域名/news</td>
<td>获取列表数据</td>
</tr>
<tr>
<td align="center">GET</td>
<td>http://域名/news/:id</td>
<td>根据id获取一条数据</td>
</tr>
<tr>
<td align="center">POST</td>
<td>http://域名/news</td>
<td>添加一条数据</td>
</tr>
<tr>
<td align="center">PUT</td>
<td>http://域名/news/:id</td>
<td>根据id修改一条数据</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td>http://域名/news/:id</td>
<td>根据id“删除“一条数据</td>
</tr>
</tbody></table>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><table>
<thead>
<tr>
<th>方式</th>
<th>年份</th>
<th>出处</th>
</tr>
</thead>
<tbody><tr>
<td>require/exports</td>
<td>2009</td>
<td>CommonJS</td>
</tr>
<tr>
<td>import/export</td>
<td>2015</td>
<td>ECMAScript2015（ES6）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>环境</th>
<th>require/exports</th>
<th>import/export</th>
</tr>
</thead>
<tbody><tr>
<td>Nodejs</td>
<td>所有版本</td>
<td>Node 9.0+（启动需加上 flag –experimental-modules）Node 13.2+（直接启动）</td>
</tr>
<tr>
<td>Chorme</td>
<td>不支持</td>
<td>61+</td>
</tr>
<tr>
<td>Firefox</td>
<td>不支持</td>
<td>60+</td>
</tr>
<tr>
<td>Safari</td>
<td>不支持</td>
<td>10.1+</td>
</tr>
<tr>
<td>Edge</td>
<td>不支持</td>
<td>16+</td>
</tr>
</tbody></table>
<p>require/exports是运行时动态加载</p>
<p>import/export是静态编译</p>
<p>require/exports输出的是一个值的拷贝</p>
<p>import/export模块输出的是值的引用</p>
<h4 id="require-exports-的用法"><a href="#require-exports-的用法" class="headerlink" title="require/exports 的用法"></a>require/exports 的用法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">exports.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//utils.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">exports.a = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports) <span class="comment">//&#123;a : 200&#125;</span></span><br><span class="line">exports = &#123;<span class="attr">a</span>:<span class="number">300</span>&#125;; <span class="comment">//exports 指向其他内存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 打印为 &#123;a : 200&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.js</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">    <span class="built_in">console</span>.log(args);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    test</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; test &#125; = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'this is a test.'</span>);</span><br></pre></td></tr></table></figure>

<p>引入 export default 导出的模块不用加 {},引入非 export default 导出的模块需要加 {}。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import fileSystem, &#123;readFile&#125; from &#39;fs&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.js:</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出模块，一个文件中只能定义一个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"lyn"</span>;</span><br><span class="line"></span><br><span class="line">b.js:</span><br><span class="line"></span><br><span class="line"><span class="comment">// _代表引入的export default的内容</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; test, name &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>C++ primer</title>
    <url>/2022/07/17/cpp-primer/</url>
    <content><![CDATA[<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">df<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<p>通过测试发现<br>cin遇到空格和回车，表示一个变量赋值结束</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const 修饰普通变量，变量不能修改</p>
<p>const 修改对象，对象只能访问被const修饰的函数，和不能修改成员变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> age &#123;<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> height&#123;<span class="number">20</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Student b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.GetAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// b.height = 2; 不能修改成员变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
